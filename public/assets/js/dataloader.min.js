(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactDataloader"] = factory(require("react"));
	else
		root["ReactDataloader"] = factory(root["React"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_9__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Datasource = __webpack_require__(1);
	var DependentDatasource = __webpack_require__(2);
	var BasicDatasource = __webpack_require__(3);
	var FilteredDatasource = __webpack_require__(4);
	var Collection = __webpack_require__(5);
	var ObjectTest = __webpack_require__(6);
	var DSManager = __webpack_require__(7);
	var uuid = __webpack_require__(8);
	// Exports components
	module.exports = {
	  FilteredDatasource: FilteredDatasource,
	  Datasource: Datasource,
	  BasicDatasource: BasicDatasource,
	  Collection: Collection,
	  ObjectTest: ObjectTest,
	  DSManager: DSManager,
	  uuid: uuid };

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);
	var Reflux = __webpack_require__(19);

	var UtilityMixin = __webpack_require__(10);
	var DataMixin = __webpack_require__(11);
	var _ = __webpack_require__(20);

	/**
	 * Datasource
	 */
	var Datasource = React.createClass({
	  displayName: 'Datasource',

	  propTypes: {
	    config: React.PropTypes.shape({
	      /**
	       * Resource Name
	       */
	      name: React.PropTypes.string,
	      /**
	       * Resource BasePath
	       */
	      basePath: React.PropTypes.string,
	      /**
	       * Resource endpoint
	       */
	      endpoint: React.PropTypes.string,
	      /**
	       * Type of store, enum: [shared, unique]
	       */
	      storeType: React.PropTypes.string.isRequired,
	      /**
	       * ID attr to query on
	       */
	      idAttr: React.PropTypes.string,
	      /**
	       * Determine if the store should populate himself initially
	       */
	      autoPopulate: React.PropTypes.bool }),
	    /**
	     * Initial data
	     */
	    data: React.PropTypes.array
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      autoPopulate: true,
	      config: {
	        idAttr: 'id',
	        storeType: 'unique'
	      }
	    };
	  },

	  mixins: [Reflux.ListenerMixin, UtilityMixin, DataMixin],

	  _reloadCollection: function _reloadCollection(props, state) {
	    var id = props.objectId;
	    var _props = this.props;
	    var onData = _props.onData;
	    var autoPopulate = _props.autoPopulate;
	    var dataSource = state.dataSource;

	    if (dataSource) {
	      var data = id ? dataSource.get(id) : dataSource.getCollection();
	      if (!data) {
	        autoPopulate && this._populate(props, state);
	      } else {
	        onData && onData(data);
	        this.setState({ data: data });
	      }
	    }
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var oldName = this.props.config && this.props.config.name;
	    var newName = nextProps.config && nextProps.config.name;

	    if (newName !== oldName) {
	      this.stopListeningToAll();
	      this._prepareDatasource(nextProps.config);
	    } else if (nextProps.objectId !== this.props.objectId) {
	      this._reloadCollection(nextProps, this.state);
	    }
	  },

	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (this.state.dataSource != nextState.dataSource) {
	      this.props.autoPopulate && this._populate(nextProps, nextState);
	    } else {}
	  },

	  _populate: function _populate(props, state) {
	    var dataSource = state.dataSource;

	    var object = props.objectId ? { id: props.objectId } : null;
	    dataSource.listenables.populate(object);
	  },

	  componentDidMount: function componentDidMount() {
	    this._prepareDatasource(this.props.config);
	    this._reloadCollection(this.props, this.state);
	    // todo instead of id use fkAttr or something
	  }
	});

	module.exports = Datasource;

	// this._reloadCollection(nextProps, nextState);

/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);
	var Reflux = __webpack_require__(19);

	var UtilityMixin = __webpack_require__(10);
	var DataMixin = __webpack_require__(11);
	var _ = __webpack_require__(20);

	/**
	 * DependentDatasource
	 */
	var DependentDatasource = React.createClass({
	  displayName: 'DependentDatasource',

	  propTypes: {
	    config: React.PropTypes.shape({
	      /**
	       * Resource Name
	       */
	      name: React.PropTypes.string,
	      /**
	       * Resource BasePath
	       */
	      basePath: React.PropTypes.string,
	      /**
	       * Resource endpoint
	       */
	      endpoint: React.PropTypes.string,
	      /**
	       * Type of store, enum: [shared, unique]
	       */
	      storeType: React.PropTypes.string.isRequired,
	      /**
	       * ID attribute to query on
	       */
	      idAttr: React.PropTypes.string,
	      /**
	       * ForeignKey attribute to query on
	       */
	      fkAttr: React.PropTypes.string
	    }),
	    /**
	     * Parent object (we use this object's ID as the FK)
	     */
	    data: React.PropTypes.object,
	    /**
	     * Collection Tag
	     */
	    tag: React.PropTypes.string,
	    /**
	     * Scope requests to parentID?
	     */
	    scoped: React.PropTypes.bool
	  },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      config: {
	        idAttr: 'id',
	        fkAttr: 'parent_id',
	        storeType: 'unique'
	      }
	    };
	  },

	  mixins: [Reflux.ListenerMixin, UtilityMixin, DataMixin],

	  _updateDynamicView: function _updateDynamicView(props) {
	    if (props.tag) {

	      var data = props.data;
	      var _props$config = props.config;
	      var idAttr = _props$config.idAttr;
	      var fkAttr = _props$config.fkAttr;

	      if (data && data[idAttr]) {
	        var query = {};
	        query[fkAttr] = data[idAttr];
	        this.dataSource.listenables.filter(props.tag, query);
	      }
	    }
	  },

	  _reloadCollection: function _reloadCollection(props) {
	    var data = this.dataSource.getCollection(props.tag);
	    this.setState({ data: data });
	  },

	  _repopulate: function _repopulate(props) {
	    if (!props.data) return;
	    var _props$config2 = props.config;
	    var idAttr = _props$config2.idAttr;
	    var fkAttr = _props$config2.fkAttr;
	    var idRootAttr = _props$config2.idRootAttr;
	    var fkRootAttr = _props$config2.fkRootAttr;

	    var query = {};
	    query[fkAttr] = props.data[idAttr];
	    query.rootId = props.rootId;
	    query[fkAttr] && this.dataSource.listenables.populate(query);
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _nextProps$config = nextProps.config;
	    var idAttr = _nextProps$config.idAttr;
	    var fkAttr = _nextProps$config.fkAttr;

	    // Checks for data source switches
	    if (nextProps.config.name !== this.props.config.name) {
	      this.stopListeningToAll();
	      this._prepareDatasource(nextProps);
	    }

	    // Checks for endpoint changes
	    else if (nextProps.config.endpoint !== this.props.config.endpoint) {
	      this._prepareDatasource(nextProps);
	    }

	    // Checks for parent changes
	    if (!nextProps.data) {
	      return;
	    } else if (nextProps.data[idAttr] !== this.props.data[idAttr]) {
	      this._updateDynamicView(nextProps);
	      this._repopulate(nextProps);
	    }
	  },

	  componentDidMount: function componentDidMount() {
	    var config = _.extend({}, this.props.config);
	    config.dependent = true;
	    config.rootId = this.props.rootId;
	    this._prepareDatasource(config);
	    this._updateDynamicView(this.props);
	    this._repopulate(this.props);
	  }
	});

	module.exports = DependentDatasource;

/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);

	// PULL OUT
	var q = __webpack_require__(21);
	var _ = __webpack_require__(20);
	var qwest = __webpack_require__(22);

	function apiRequest(url, queryParams) {
	  var deferred = q.defer();

	  if (!url) return console.warn('No url specified.');

	  qwest({
	    url: url,
	    method: 'get',
	    data: queryParams,
	    error: function error(err) {
	      return deferred.reject(err);
	    },
	    success: function success(res) {
	      return deferred.resolve(res);
	    } });

	  return deferred.promise;
	}
	// END PULL OUT

	function makeCombinator(uniqueKey) {
	  return function (base, additional) {
	    return _.chain(base || []).concat(additional).uniq(false, function (obj) {
	      return obj[uniqueKey];
	    }).value();
	  };
	}

	var BasicDatasource = React.createClass({
	  displayName: 'BasicDatasource',

	  propTypes: {
	    /**
	     * Resource URL
	     */
	    url: React.PropTypes.string,
	    /**
	     * Determine if the store should populate itself initially
	     */
	    autoPopulate: React.PropTypes.bool,
	    /**
	     * Query parameters
	     */
	    queryParams: React.PropTypes.object,
	    /**
	     * Children
	     */
	    children: React.PropTypes.array,
	    /**
	     * Serializer
	     */
	    serializer: React.PropTypes.func,
	    /**
	     * uniqueKey
	     */
	    uniqueKey: React.PropTypes.string.isRequired,
	    /*
	     * Parent wrapper
	     */
	    wrapper: React.PropTypes.string,

	    /*
	    * style class names for component
	    */
	    className: React.PropTypes.string,

	    onData: React.PropTypes.func },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      autoPopulate: true,
	      queryParams: {},
	      serializer: function serializer(data) {
	        return data;
	      },
	      uniqueKey: 'id',
	      wrapper: 'div',
	      className: '' };
	  },

	  getInitialState: function getInitialState() {
	    return {
	      data: [] };
	  },

	  componentWillMount: function componentWillMount() {
	    this.props.autoPopulate && this.populate(this.props);
	    this.limitedPopulate = _.throttle(this.populate, 750);
	    this.combineData = makeCombinator(this.props.uniqueKey);
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _this = this;

	    if (!_.isEqual(nextProps.queryParams, this.props.queryParams)) {
	      this.limitedPopulate(nextProps);
	    }

	    if (nextProps.url != this.props.url) {
	      this.setState({ data: [] }, function () {
	        _this.populate(nextProps);
	      });
	    }
	  },

	  render: function render() {
	    var className = this.props.className;

	    var Wrapper = this.props.wrapper;

	    var children = this.cloneWithProps(this.state);
	    return React.createElement(
	      Wrapper,
	      { className: className },
	      children
	    );
	  },

	  cloneWithProps: function cloneWithProps(state) {
	    var children = React.Children.map(this.props.children, function (child) {
	      if (!child) {
	        return null;
	      }
	      return React.cloneElement(child, state);
	    }, this.context);

	    return children;
	  },

	  populate: function populate() {
	    var _this2 = this;

	    var props = arguments[0] === undefined ? this.props : arguments[0];
	    var url = props.url;
	    var queryParams = props.queryParams;
	    var serializer = props.serializer;
	    var uniqueKey = props.uniqueKey;

	    var combineData = makeCombinator(uniqueKey);
	    if (!url) return false;

	    apiRequest(url, queryParams).then(function (rawData) {
	      var onData = _this2.props.onData;

	      var data = combineData(_this2.state.data, serializer(rawData));
	      _this2.setState({ data: data }, function () {
	        onData && onData(data);
	      });
	    }).fail(function (err) {
	      console.error('BasicDatasource failed!', url, err);
	    });
	  } });

	module.exports = BasicDatasource;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);
	var Reflux = __webpack_require__(19);

	var UtilityMixin = __webpack_require__(10);
	var DataMixin = __webpack_require__(11);

	var _ = __webpack_require__(20);

	/**
	 * FilteredDatasource
	 */
	var FilteredDatasource = React.createClass({
	  displayName: 'FilteredDatasource',

	  propTypes: {
	    config: React.PropTypes.shape({
	      /**
	       * Resource Name
	       */
	      name: React.PropTypes.string,
	      /**
	       * Resource BasePath
	       */
	      basePath: React.PropTypes.string,
	      /**
	       * Resource endpoint
	       */
	      endpoint: React.PropTypes.string,
	      /**
	       * Type of store, enum: [shared, unique]
	       */
	      storeType: React.PropTypes.string.isRequired,
	      /**
	       * ID attribute to query on
	       */
	      idAttr: React.PropTypes.string,
	      /**
	       * Determine if the store should populate himself initially
	       */
	      autoPopulate: React.PropTypes.bool }),
	    /**
	     * Sort Parameters
	     */
	    sortBy: React.PropTypes.shape({
	      attribute: React.PropTypes.string,
	      isDescending: React.PropTypes.boolean
	    }),
	    /**
	     * Filter Criteria (mongo style)
	     */
	    filters: React.PropTypes.object,
	    /**
	     * Optional parent object
	     */
	    data: React.PropTypes.object,
	    /**
	     * Collection Tag
	     */
	    tag: React.PropTypes.string.isRequired,
	    /**
	     * Optional Request Params
	     */
	    params: React.PropTypes.object },

	  getDefaultProps: function getDefaultProps() {
	    return {
	      autoPopulate: true,
	      config: {
	        idAttr: 'id',
	        storeType: 'unique'
	      }
	    };
	  },

	  mixins: [Reflux.ListenerMixin, UtilityMixin, DataMixin],

	  _registerView: function _registerView(props, state) {
	    var tag = props.tag;
	    var sortBy = props.sortBy;
	    var filters = props.filters;
	    var search = props.search;
	    var data = props.data;
	    var config = props.config;
	    var idAttr = config.idAttr;
	    var fkAttr = config.fkAttr;
	    var dataSource = state.dataSource;

	    var fk,
	        query = {};
	    if (data) {
	      query[fkAttr] = data[idAttr] || props.objectId || -1;
	    }
	    filters = _.extend(query, filters);

	    return dataSource.listenables.registerView(tag, { sortBy: sortBy, filters: filters, search: search });
	  },

	  _reloadCollection: function _reloadCollection(props, state) {
	    var dataSource = state.dataSource;
	    var onData = this.props.onData;

	    var data = dataSource.getCollection(props.tag);

	    onData && onData(data, dataSource.listenables);
	    // this clone bug was absolutely insane. let's put this on our dev guide
	    this.setState({ data: _.clone(data) });
	  },

	  _repopulate: function _repopulate(props, state) {
	    var autoPopulate = props.autoPopulate;
	    var params = props.params;
	    var dataSource = state.dataSource;
	    var _props$config = props.config;
	    var idAttr = _props$config.idAttr;
	    var fkAttr = _props$config.fkAttr;

	    var query = {};

	    if (props.autoPopulate) {
	      if (props.rootId) {
	        query.rootId = props.rootId;
	      }
	      if (props.loadId) {
	        query.loadId = props.loadId;
	      }
	      if (props.data) {
	        query[fkAttr] = props.data[idAttr];
	      }
	      if (props.objectId) {
	        query[fkAttr] = props.objectId;
	      }

	      dataSource.listenables.populate(query, params);
	    }
	  },

	  didViewChange: function didViewChange(nextProps) {
	    return !_.isEqual(nextProps.filters, this.props.filters) || !_.isEqual(nextProps.search, this.props.search) || !_.isEqual(nextProps.sortBy, this.props.sortBy);
	  },

	  didConfigChange: function didConfigChange(nextProps) {
	    return nextProps.config.name !== this.props.config.name || nextProps.config.endpoint !== this.props.config.endpoint;
	  },

	  didWatchedPropsChange: function didWatchedPropsChange(nextProps, watchProps) {
	    var _this = this;

	    return watchProps && _.every(watchProps, function (prop) {
	      if (_this.props.data[prop] !== nextProps.data[prop]) {
	        return true;
	      }
	    });
	  },

	  didIdChange: function didIdChange(nextProps) {
	    var idAttr = nextProps.config.idAttr;

	    var id = this.props.data && this.props.data[idAttr] || this.props.objectId;
	    var nextId = nextProps.data && nextProps.data[idAttr] || nextProps.objectId;

	    var idChanged = nextId !== id;
	    idChanged = idChanged || nextProps.loadId !== this.props.loadId;

	    return idChanged;
	  },

	  didParamsChange: function didParamsChange(nextProps) {
	    if (!_.isEqual(nextProps.params, this.props.params)) {
	      return true;
	    }
	    return false;
	  },

	  componentWillReceiveProps: function componentWillReceiveProps(nextProps) {
	    var _nextProps$config = nextProps.config;
	    var idAttr = _nextProps$config.idAttr;
	    var fkAttr = _nextProps$config.fkAttr;
	    var watchProps = _nextProps$config.watchProps;

	    var viewChanged = this.didViewChange(nextProps);
	    var configChanged = this.didConfigChange(nextProps);
	    var watchedPropsChanged = this.didWatchedPropsChange(nextProps, watchProps);
	    var idChanged = this.didIdChange(nextProps);
	    var queryChanged = this.didParamsChange(nextProps);

	    if (configChanged) this._prepareDatasource(nextProps.config);

	    if (this.state.dataSource && (viewChanged || idChanged)) {
	      this.state.dataSource.listenables.resetView(nextProps.tag, false);
	      this._registerView(nextProps, this.state);
	    }

	    // Checks for parent changes
	    if (this.state.dataSource) {
	      if (idChanged || queryChanged) {
	        this._repopulate(nextProps, this.state);
	      }
	    }

	    //if watching parent then repopulate if props.data has changed
	  },

	  componentWillUpdate: function componentWillUpdate(nextProps, nextState) {
	    if (this.state.dataSource != nextState.dataSource) {
	      this._registerView(nextProps, nextState);
	    }
	  },

	  shouldComponentUpdate: function shouldComponentUpdate(nextProps, nextState) {
	    if (!_.isEqual(nextState, this.state) || !_.isEqual(nextProps, this.props)) {
	      return true;
	    }
	    return false;
	  },

	  componentDidMount: function componentDidMount() {
	    var config = _.extend({}, this.props.config);
	    var data = this.props.data;

	    if (data && data[config.idAttr]) {
	      config.dependent = true;
	      config.rootId = this.props.rootId;
	    }
	    this._prepareDatasource(config);
	  }
	});

	module.exports = FilteredDatasource;

/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);
	var _ = __webpack_require__(20);
	/**
	 * Generic Collection
	 */
	var Collection = React.createClass({
	  displayName: 'Collection',

	  propTypes: {
	    /**
	     * Array of objects to display
	     */
	    data: React.PropTypes.array.isRequired
	  },
	  getDefaultProps: function getDefaultProps() {
	    return {
	      data: []
	    };
	  },
	  render: function render() {
	    var _this = this;

	    var firstObject;
	    if (this.props.data) {
	      firstObject = Object.keys(this.props.data[0] || {});
	    } else {
	      firstObject = [];
	    }

	    return React.createElement(
	      'section',
	      null,
	      React.createElement(
	        'table',
	        { className: 'item-list' },
	        React.createElement(TableHeader, { keys: firstObject }),
	        React.createElement(
	          'tbody',
	          null,
	          _.isArray(this.props.data) && this.props.data.map(function (object, i) {
	            return React.createElement(TableRow, {
	              object: object,
	              key: object.id || i,
	              onClick: _this.props.handleSelect });
	          })
	        )
	      )
	    );
	  }
	});

	var TableRow = React.createClass({
	  displayName: 'TableRow',

	  propTypes: {
	    object: React.PropTypes.object
	  },
	  render: function render() {
	    var _this2 = this;

	    var onClick = this.props.onClick && this.props.onClick.bind(null, this.props.object.id) || function () {};
	    return React.createElement(
	      'tr',
	      { onClick: onClick },
	      Object.keys(this.props.object).map(function (key) {
	        return React.createElement(
	          'td',
	          { key: key },
	          JSON.stringify(_this2.props.object[key])
	        );
	      })
	    );
	  }
	});

	var TableHeader = React.createClass({
	  displayName: 'TableHeader',

	  propTypes: {
	    keys: React.PropTypes.array
	  },
	  render: function render() {
	    return React.createElement(
	      'thead',
	      null,
	      this.props.keys.map(function (key, i) {
	        return React.createElement(
	          'th',
	          { key: i },
	          key
	        );
	      })
	    );
	  }
	});

	module.exports = Collection;

/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var React = __webpack_require__(9);

	var ObjectTest = React.createClass({
	  displayName: "ObjectTest",

	  propTypes: {
	    data: React.PropTypes.object
	  },
	  getDefaultProps: function getDefaultProps() {
	    return {
	      data: {}
	    };
	  },
	  render: function render() {
	    var _this = this;

	    return React.createElement(
	      "table",
	      { className: "edit" },
	      this.props.data && Object.keys(this.props.data).map(function (key) {
	        var value = JSON.stringify(_this.props.data[key]);
	        return React.createElement(
	          "tr",
	          { key: key },
	          React.createElement(
	            "th",
	            null,
	            key
	          ),
	          React.createElement(
	            "td",
	            null,
	            value
	          )
	        );
	      })
	    );
	  }
	});

	module.exports = ObjectTest;

/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var Reflux = __webpack_require__(19);
	var DataActionGenerator = __webpack_require__(12);
	var nsync = __webpack_require__(13);
	var client = __webpack_require__(14);

	var storeTemplates = {
	  // Shared/persistent stores are Loki
	  shared: __webpack_require__(15),

	  // Unique/ephemeral stores are Immutable
	  unique: __webpack_require__(16) };

	var urlBuilders = {
	  'default': __webpack_require__(17),
	  dependent: __webpack_require__(18) };

	function defaultErrorHandler(method, err) {
	  console.error('' + this.name + ' error', method, err);
	}

	/**
	 * @class DataStoreManager
	 */

	var DataStoreManager = (function () {
	  function DataStoreManager() {
	    _classCallCheck(this, DataStoreManager);

	    this.generatedStores = {};
	    this.headers = {};
	    this.synchronizer = nsync;
	    this.client = client;
	    this.urlBuilders = urlBuilders;
	    this.onError = defaultErrorHandler;
	  }

	  _createClass(DataStoreManager, [{
	    key: 'implode',

	    /**
	     * @public
	     * The nuclear option
	     */
	    value: function implode() {
	      this.constructor();
	    }
	  }, {
	    key: '_memoizeStore',

	    /**
	     * @private
	     * Memoizes a store
	     * @param  {RefluxStore} store Store to be memoized
	     * @return {RefluxStore} Memoized Store
	     */
	    value: function _memoizeStore(store) {
	      if (!this.generatedStores[store.name]) {
	        this.generatedStores[store.name] = store;
	      }
	      return this.generatedStores[store.name];
	    }
	  }, {
	    key: '_memoizeClient',

	    /**
	     * @private
	     * Memoizes a store
	     * @param  {RefluxStore} store Store to be memoized
	     * @return {RefluxStore} Memoized Store
	     */
	    value: function _memoizeClient(client) {
	      if (!this.generatedClients[client.name]) {
	        this.generatedClients[client.name] = client;
	      }
	      return this.generatedClients[client.name];
	    }
	  }, {
	    key: '_getStore',

	    /**
	     * @private
	     * Gets a memoized store
	     * @param  {string} name Store name
	     * @return {RefluxStore} MemoizedStore
	     */
	    value: function _getStore(name) {
	      return this.generatedStores[name];
	    }
	  }, {
	    key: 'setHeaders',

	    /**
	     * @DEPRECATED
	     */
	    value: function setHeaders(headers) {
	      console.warn('Deprecated Method, use setDefaultHeaders');
	      this.setDefaultHeaders(headers);
	    }
	  }, {
	    key: 'setDefaultHeaders',

	    /**
	     * onSyncError
	     */

	    /**
	     * @public
	     * Sets headers for synchronizer requests
	     * @param  {object} headers Request Headers
	     */
	    value: function setDefaultHeaders(headers) {
	      this.headers = headers;
	    }
	  }, {
	    key: 'getHeaders',

	    /**
	     * @public
	     * Gets headers for synchronizer requests
	     * @param  {object} headers Request Headers
	     */
	    value: function getHeaders() {
	      return this.headers;
	    }
	  }, {
	    key: 'registerBuilder',

	    /**
	     * @public
	     * Registers new url builder for synchronizers
	     * @param  {string} name Name of builder
	     * @param  {func} url builder
	     */
	    value: function registerBuilder(name, builder) {
	      this.urlBuilders[name] = builder;
	    }
	  }, {
	    key: 'setSynchronizer',

	    /**
	     * @public
	     * Sets synchronizer
	     * @param  {object} synchronizer
	     */
	    value: function setSynchronizer(storeName, synchronizer) {
	      this.generatedStores['' + storeName + 'Synchronizer'] = synchronizer;
	    }
	  }, {
	    key: 'getSynchronizer',

	    /**
	     * @public
	     * Sets synchronizer
	     * @param  {object} synchronizer
	     */
	    value: function getSynchronizer(storeName) {
	      return this.generatedStores['' + storeName + 'Synchronizer'];
	    }
	  }, {
	    key: 'setErrorHandler',

	    /**
	     * @public
	     * setErrorHandler
	     * @param {func} cb Error handler callback
	     */
	    value: function setErrorHandler(cb) {
	      this.onError = cb;
	    }
	  }, {
	    key: 'on',

	    /**
	     * @public
	     * Used to dispatch actions to stores
	     * @param Name of store
	     * @param actionType name of action to listen for
	     * @param func function to execute on event emit
	     */
	    value: function on(storeName, actionType, func) {
	      var options = {
	        storeType: 'shared',
	        name: storeName,
	        builder: 'procore' };
	      var dispatcherOptions = {
	        storeType: 'shared',
	        name: 'dispatcher' };

	      var store = this.getStore(options);
	      var dispatcherStore = this.getStore(dispatcherOptions);

	      dispatcherStore.listenTo(store, function (type, data) {
	        if (actionType === type) {
	          func(data);
	        }
	      });
	    }
	  }, {
	    key: 'getStore',

	    /**
	     * @public
	     * Generates a store
	     * @param {object} options Store options
	     */
	    value: function getStore(options) {
	      var name = options.name;
	      var storeType = options.storeType;

	      var memoized = this._getStore(name);

	      if (memoized) {
	        return memoized;
	      }
	      if (this.headers !== {}) {
	        options.headers = this.getHeaders.bind(this);
	      }
	      if (this.onError) {
	        options.onError = this.onError;
	      }
	      return this[storeType || 'unique'](options);
	    }
	  }, {
	    key: 'shared',

	    /**
	     * @private
	     * Generates a singleton store
	     * @param  {object} options Store options
	     * @return {RefluxStore} Generated store
	     */
	    value: function shared(options) {
	      var name = options.name;
	      var builder = options.builder;

	      // This seems like a code smell ~
	      var chosenStore = new storeTemplates.shared(options);
	      chosenStore.listenables = DataActionGenerator(name);
	      var store = Reflux.createStore(chosenStore);

	      // Probably need to move this logic
	      var urlBuilder = new this.urlBuilders[builder || 'default'](options);
	      var client = new this.client(urlBuilder, options);
	      var synchronizer = this.synchronizer(options, store, client);

	      this._memoizeStore(synchronizer);
	      this._memoizeStore(store);

	      return store;
	    }
	  }, {
	    key: 'unique',

	    /**
	     * @private
	     * Generates an ephemeral store
	     * @param  {object} options Store options
	     * @return {RefluxStore} Generated store
	     */
	    value: function unique(options) {
	      var name = options.name;
	      var builder = options.builder;

	      name = '' + name + '' + Date.now();

	      // This seems like a code smell ~
	      var chosenStore = new storeTemplates.shared(options);
	      chosenStore.listenables = DataActionGenerator();
	      var store = Reflux.createStore(chosenStore);

	      // Probably need to move this logic
	      var urlBuilder = new this.urlBuilders[builder || 'default'](options);
	      var client = new this.client(urlBuilder, options);
	      var synchronizer = this.synchronizer(options, store, client);

	      return store;
	    }
	  }]);

	  return DataStoreManager;
	})();

	/**
	 * Retrieves store generator from the window
	 * @return {object} DataStoreManager
	 */
	module.exports = window.DataStoreManager = new DataStoreManager();

/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var uuid = {
	  v4: function v4() {
	    var id = Math.round(1000000 - Math.random() * 500000);
	    return id;
	  }

	};

	module.exports = uuid;

/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_9__;

/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);
	var _ = __webpack_require__(20);

	/**
	 * @module UtilityMixin
	 * @type {Object}
	 */
	var UtilityMixin = {

	  _buildProps: function _buildProps() {
	    var props = _.clone(this.props);
	    delete props.children;
	    delete props.className;
	    delete props.wrapper;
	    delete props.tag;
	    delete props.config;
	    return props;
	  },

	  /**
	   * Clones children with given props
	   * @param  {object} props Props to give to children
	   * @return {array}       Array of child components with new props
	   */
	  _cloneWithProps: function _cloneWithProps(props) {
	    var children = React.Children.map(this.props.children, function (child) {
	      if (!child) {
	        return null;
	      }
	      return React.cloneElement(child, props);
	    }, this.context);
	    return children;
	  },

	  /**
	   * Console warns with component display name
	   * @param  {string} warning Warning message
	   */
	  _warn: function _warn(warning) {
	    console.warn(this.constructor.displayName, warning);
	  }
	};

	module.exports = UtilityMixin;

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var React = __webpack_require__(9);
	var _ = __webpack_require__(20);
	var DSManager = __webpack_require__(7);

	module.exports = {

	  getInitialState: function getInitialState() {
	    return {
	      data: [],
	      dataSource: null
	    };
	  },

	  _buildDataProps: function _buildDataProps() {
	    var props = this._buildProps();
	    // Nil hack basically.
	    var data = this.state.data || this.props.objectId && {} || [];

	    var actions = {};
	    if (this.state.dataSource) {
	      actions = this.state.dataSource && this.state.dataSource.listenables;
	    }
	    return _.extend(props, { data: data, actions: actions });
	  },

	  _prepareDatasource: function _prepareDatasource(config) {
	    var dataSource = DSManager.getStore(config);
	    this.listenTo(dataSource, this.onStoreChange);
	    this.setState({ dataSource: dataSource });
	  },

	  _onViewRegistered: function _onViewRegistered() {
	    var dataSource = this.state.dataSource;
	    var _props = this.props;
	    var tag = _props.tag;
	    var autoPopulate = _props.autoPopulate;

	    var data = dataSource.getCollection(tag);
	    _.isEmpty(data) && this._repopulate(this.props, this.state);
	  },

	  onStoreChange: function onStoreChange(type, payload) {
	    if (type === 'viewRegistered' && payload === this.props.tag) {
	      this._onViewRegistered();
	    }
	    this._reloadCollection(this.props, this.state);
	  },
	  render: function render() {
	    var children = this._cloneWithProps(this._buildDataProps());
	    var Wrapper = this.props.wrapper || 'div';
	    return React.createElement(
	      Wrapper,
	      { className: this.props.className },
	      children
	    );
	  }
	};

/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Reflux = __webpack_require__(19);
	var cached = {};

	/**
	 * DataActionGenerator - Generates Reflux Actions
	 * @param {string} resourceName name of resource for memoization (optional)
	 * @returns {RefluxActions} returns reflux actions
	 */
	var DataActionGenerator = function DataActionGenerator(resourceName) {
	  if (cached[resourceName]) {
	    return cached[resourceName];
	  }

	  var actions = Reflux.createActions(['add', 'update', 'destroy', 'filter', 'sort', 'search', 'registerView', 'resetView', 'reload', 'populate', 'destroyAll', 'setObject', 'setCollection']);

	  if (resourceName) {
	    cached[resourceName] = actions;
	  }

	  return actions;
	};

	module.exports = DataActionGenerator;

/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var Reflux = __webpack_require__(19);
	var _ = __webpack_require__(20);

	function defaultDeserializer(_x, object) {
	  var query = arguments[0] === undefined ? null : arguments[0];

	  return object;
	}

	/**
	 * @class Store Synchronizer
	 */

	var Nsynchronizer = {
	  /**
	   * @public Initializer
	   * @param {object} options hash of options
	   * @param {string} options.idAttribute idAttribute of resource
	   * @param {string} options.basePath basePath of resource
	   * @param {string} options.endpoint endpoint of resource
	   *
	   * @param {RefluxStore} store Store to synchronize
	   */
	  registerStore: function registerStore(options, store, client) {
	    this.store = store;
	    this.name = '' + store.name + 'Synchronizer';
	    this.idAttribute = options.idAttribute;
	    this.client = client;
	    this.onError = options.onError;

	    this.setDeserializer();
	    this.listenTo(store, this.onStoreChange);
	    this.listenTo(store.listenables.populate, this.populate);
	  },

	  /**
	   * @public Persists store to remote when updated
	   */
	  onStoreChange: function onStoreChange(action, data) {
	    var trigger = arguments[2] === undefined ? true : arguments[2];

	    // move me out
	    var allowedActions = ['add', 'update', 'destroy'];
	    if (trigger && _.contains(allowedActions, action)) {
	      this[action](data);
	    }
	  },

	  /**
	   * @public Sets serializer
	   */

	  setSerializer: function setSerializer(serializer) {
	    this.serializer = serializer;
	  },

	  /**
	   * @public Sets deserializer
	   */

	  setDeserializer: function setDeserializer() {
	    var deserializer = arguments[0] === undefined ? defaultDeserializer : arguments[0];

	    this.deserializer = deserializer;
	  },

	  /**
	   * @public Sets client
	   */
	  setClient: function setClient(client) {
	    this.client = client;
	  },

	  /**
	   * Log errors
	   */

	  _logError: function _logError(method, err) {
	    this.onError && this.onError(this.name, method, err);
	  },

	  /**
	   * @public Populates store from remote
	   */
	  populate: function populate(object, params) {
	    var _this = this;

	    this.client.getAll(object, params).then(function (objects) {
	      // @todo: find a better way to sync w/ remote
	      // this.store.listenables.destroyAll();
	      var formatted;

	      if (objects.constructor === Array) {
	        formatted = objects.map(_this.deserializer.bind(null, object));
	      } else {
	        formatted = _this.deserializer(object, objects);
	      }

	      _this.store.listenables.setCollection(formatted);
	      _this.trigger('populate', objects);
	    }).fail(function (err) {
	      _this._logError('populate', err);
	      console.error(err);
	    });
	  },

	  /**
	  * @public Fetch Object from remote
	   */
	  reload: function reload(object) {
	    var _this2 = this;

	    this.client.get(object.id).then(function (responseObject) {
	      _this2._updateSuccess(object, responseObject);
	    }).fail(function (err) {
	      _this2._logError('reload', err);
	      console.error(err);
	    });
	  },

	  /**
	   * @public Push store updates to remote
	   */
	  update: function update(object) {
	    var _this3 = this;

	    this.client.update(object, this.serializer).then(function (responseObject) {
	      _this3._updateSuccess(object, responseObject);
	      _this3.store.flushChanges();
	    }).fail(function (err) {
	      _this3._logError('update', err);
	      console.error(err);
	    });
	  },

	  _updateSuccess: function _updateSuccess(stale, updated) {
	    var object = _.extend({}, stale, updated);
	    this.store.listenables.setObject(object);
	    this.trigger('update', object);
	  },

	  /**
	  * @public Push store deletions to remote
	   */
	  destroy: function destroy(id) {
	    var _this4 = this;

	    this.client.destroy(id).then(function (result) {
	      _this4.trigger('destroy', result);
	      _this4.store.flushChanges();
	    }).fail(function (err) {
	      _this4._logError('destroy', err);
	      console.error(err);
	    });
	  },

	  /**
	  * @public Push store additions to remote
	   */
	  add: function add(addedObject) {
	    var _this5 = this;

	    var object = _.clone(addedObject);
	    delete object.id;

	    this.client.add(object, this.serializer).then(function (responseObject) {
	      _this5.store.listenables.setObject(_.extend({}, object, responseObject));
	      _this5.store.flushChanges();
	      responseObject.oldId = addedObject.id;
	      _this5.trigger('add', responseObject);
	    }).fail(function (err) {
	      _this5._logError('add', err);
	      console.error(err);
	    });
	  } };

	module.exports = function (options, store, client) {
	  var nsync = Reflux.createStore(Nsynchronizer);
	  nsync.registerStore(options, store, client);
	  return nsync;
	};

/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ('value' in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }

	var q = __webpack_require__(21);
	var _ = __webpack_require__(20);
	var reqwest = __webpack_require__(22);

	/**
	 * @class Client
	 * @description REST Client for Dataloader
	 */

	var Client = (function () {
	  /**
	   * @constructor
	   * @param  {object} urlBuilder functions for building URLs
	   * @param  {object} options client config options
	   * @param  {string} options.basePath API basepath
	   * @param  {string} options.endpoint resource API endpoint
	   * @param  {string} options.resource resource name
	   * @param  {object} options.headers Headers for requests
	   */

	  function Client(urlBuilder, options) {
	    var _this = this;

	    _classCallCheck(this, Client);

	    this.basePath = options.basePath;
	    this.endpoint = options.endpoint;
	    this.resource = options.resource;
	    this.headers = options.headers;
	    this.name = options.name;

	    Object.keys(urlBuilder).forEach(function (key) {
	      _this[key] = urlBuilder[key].bind(_this);
	    });
	  }

	  _createClass(Client, [{
	    key: 'defaultSerializer',
	    value: function defaultSerializer(object) {
	      var formatted = _.clone(object);
	      var payload = {};
	      delete formatted.$loki;
	      delete formatted.meta;

	      if (this.resource) {
	        payload[this.resource] = formatted;
	      } else {
	        payload = formatted;
	      }
	      return JSON.stringify(payload);
	    }
	  }, {
	    key: '_success',

	    /**
	     * Generic success handler
	     * @param  {object} deferred Promise to resolve on success
	     * @return {string} resource API url
	     */
	    value: function _success(deferred, res) {
	      return deferred.resolve(res);
	    }
	  }, {
	    key: '_error',

	    /**
	     * Generic failure handler
	     * @param  {object} deferred Promise to resolve on success
	     * @return {string} resource API url
	     */
	    value: function _error(deferred, err) {
	      return deferred.reject(err);
	    }
	  }, {
	    key: 'serialize',
	    value: function serialize(object) {
	      return this._serialize ? this._serialize(object) : object;
	    }
	  }, {
	    key: 'add',

	    /**
	     * Creates object on remote server
	     * @param {object} object Object to create
	     */
	    value: function add(object) {
	      var serializer = arguments[1] === undefined ? this.defaultSerializer : arguments[1];

	      var deferred = q.defer();
	      var params = {
	        url: this._getResourceUrl(object),
	        method: 'post',
	        data: serializer.call(this, object),
	        headers: this.headers(),
	        error: this._error.bind(null, deferred),
	        success: this._success.bind(null, deferred)
	      };
	      if (params.url) {
	        reqwest(params);
	      }

	      return deferred.promise;
	    }
	  }, {
	    key: 'destroy',

	    /**
	     * Destroys object on remote server
	     * @param  {number} id ID of object to destroy on server
	     * @return {promise}    promise
	     */
	    value: function destroy(id) {
	      var deferred = q.defer();

	      var params = {
	        url: this._getObjectUrl(id),
	        method: 'delete',
	        headers: this.headers(),
	        error: this._error.bind(null, deferred),
	        success: this._success.bind(null, deferred)
	      };
	      if (params.url) {
	        reqwest(params);
	      }

	      return deferred.promise;
	    }
	  }, {
	    key: 'update',

	    /**
	     * Updates object on remote server
	     * @param  {object} object Object to update
	     * @return {promise}        promise
	     */
	    value: function update(object) {
	      var serializer = arguments[1] === undefined ? this.defaultSerializer : arguments[1];

	      var deferred = q.defer();

	      var params = {
	        url: this._getObjectUrl(object.id),
	        method: 'put',
	        data: serializer.call(this, object),
	        headers: this.headers(),
	        error: this._error.bind(null, deferred),
	        success: this._success.bind(null, deferred)
	      };
	      if (params.url) {
	        reqwest(params);
	      }

	      return deferred.promise;
	    }
	  }, {
	    key: 'get',

	    /**
	     * Get an object from remote server
	     * @param  {number} id ID of object to retrieve
	     * @return {promise}    promise
	     */
	    value: function get(id) {
	      var deferred = q.defer();

	      var params = {
	        url: this._getObjectUrl(id),
	        method: 'get',
	        headers: this.headers(),
	        error: this._error.bind(null, deferred),
	        success: this._success.bind(null, deferred)
	      };
	      if (params.url) {
	        reqwest(params);
	      }

	      return deferred.promise;
	    }
	  }, {
	    key: 'getAll',

	    /**
	     * Get collection from remote server
	     * @return {promise} promise
	     */
	    value: function getAll(object, queryParams) {
	      var deferred = q.defer();

	      var params = {
	        url: this._getResourceUrl(object, queryParams),
	        method: 'get',
	        headers: this.headers(),
	        data: queryParams,
	        error: this._error.bind(null, deferred),
	        success: this._success.bind(null, deferred)
	      };
	      if (params.url) {
	        reqwest(params);
	      }

	      return deferred.promise;
	    }
	  }]);

	  return Client;
	})();

	module.exports = Client;

/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	/**
	 * @module LokiStore
	 */
	var loki = __webpack_require__(24);
	var _ = __webpack_require__(20);
	var uuid = __webpack_require__(8);
	/**
	 * @class LowkeySource
	 * @description Manages Loki datasource
	 */

	var LowkeySource = (function () {
	  function LowkeySource() {
	    _classCallCheck(this, LowkeySource);

	    this.dataSource = null;
	    this.resources = {};
	  }

	  _createClass(LowkeySource, [{
	    key: "getDS",

	    /**
	     * Initializes and returns a datasource
	     * @return {loki} loki datasource
	     */
	    value: function getDS() {
	      if (this.dataSource) {
	        return this.dataSource;
	      }
	      this.dataSource = new loki();
	      return this.dataSource;
	    }
	  }, {
	    key: "getResource",

	    /**
	     * Initializes and returns a resource
	     * @param  {string} name name of resource
	     * @return {object}      Loki Collection
	     */
	    value: function getResource(name) {
	      var resources = this.resources;
	      if (resources[name]) {
	        return resources[name];
	      }

	      var resource = this.getDS().addCollection(name, { disableChangesApi: false });
	      resources[name] = resource;

	      return resource;
	    }
	  }]);

	  return LowkeySource;
	})();

	var $ds = new LowkeySource();

	/**
	 * Generate Store
	 * @param  {name} name name of resource
	 * @return {object} Loki store template
	 */
	function generateStore(options) {
	  var name = options.name;
	  var idAttr = options.idAttr;
	  var fk = options.fk;

	  var collection = $ds.getResource(name);
	  return {
	    name: name,
	    collection: collection,
	    dynamicViews: {},

	    /**
	     * Initializes store
	     */
	    init: function init() {},

	    resetChanges: function resetChanges() {
	      var _this = this;

	      var changes = this.collection.getChanges();
	      changes.forEach(function (change) {
	        var obj = change.obj;

	        _this.setObject(obj);
	      });
	    },

	    flushChanges: function flushChanges() {
	      this.collection.flushChanges();
	    },

	    /**
	     * Adds an object to the store
	     * @param {object} object Object to add
	     * @return {event} Triggers event
	     */
	    add: function add(object) {
	      var trigger = arguments[1] === undefined ? true : arguments[1];

	      var stale = this.getDatabaseEntity(object);

	      if (stale) {
	        console.warn("ProcoreReact: Trying to add an already existing element. Syncing instead");
	        this.trigger("add", object, trigger);
	      } else {

	        // ===========================
	        // TESTING TEMP IDS
	        // ===========================

	        if (!trigger && !object[idAttr]) {
	          object[idAttr] = "temp" + uuid.v4();
	        }

	        this.collection.insert(object);
	        this.trigger("add", object, trigger);
	      }
	    },

	    /**
	     * Sets collection
	     * @param {array} collection Collection to set
	     * @return {event} Triggers event
	     */
	    setCollection: function setCollection(collection) {
	      var _this2 = this;

	      if (collection.constructor !== Array) {
	        collection = [collection];
	      }

	      _.map(collection, function (object) {
	        var stale = _this2.getDatabaseEntity(object);
	        if (stale) {
	          _this2.collection.update(_.extend(stale, object));
	        } else {
	          _this2.collection.insert(object);
	        }
	      });
	      this.flushChanges();
	      this.trigger("setCollection", this.getCollection());
	    },

	    /**
	     * Set object without triggering events
	     * @param {object} object Object to insert or update
	     */
	    setObject: function setObject(object) {
	      var stale = this.getDatabaseEntity(object);
	      if (stale) {
	        this.update(object, false);
	      } else {
	        this.add(object, false);
	      }
	      this.flushChanges();
	    },

	    /**
	     * Destroys object
	     * @param  {number} id ID of object to destroy
	     * @return {event} Triggers event
	     */
	    destroy: function destroy(id) {
	      var trigger = arguments[1] === undefined ? true : arguments[1];

	      this.collection.remove(this.get(id));
	      this.trigger("destroy", id, trigger);
	    },

	    /**
	     * Destroys all objects in the store
	     * @return {event} Triggers event
	     */
	    destroyAll: function destroyAll() {
	      var trigger = arguments[0] === undefined ? true : arguments[0];

	      this.collection.removeDataOnly();
	      this.trigger("destroyAll", this.getCollection(), trigger);
	    },

	    /**
	     * Updates an object in the store
	     * @param  {object} object Object to update
	     * @return {event} Triggers an event
	     */
	    update: function update(updates) {
	      var trigger = arguments[1] === undefined ? true : arguments[1];

	      var stale = this.getDatabaseEntity(updates);
	      if (!stale) {
	        console.warn("ProcoreReact: Trying to update an inexisting element.");
	      } else {
	        var updated = _.extend({}, stale, updates);
	        this.collection.update(updated);
	        this.trigger("update", updated, trigger);
	      }
	    },

	    /**
	     * Builds a query to fetch an object
	     * @param  {number} object[idAttr] ID of requested object
	     * @param {number} object.$loki LokiID of the requested object
	     * @return {object} Requested object
	     */
	    getEntityQuery: function getEntityQuery(object) {
	      var query = {};
	      if (object.$loki) {
	        query.$loki = object.$loki;
	      } else if (object[idAttr]) {
	        query[idAttr] = object[idAttr];
	      } else {
	        query = null;
	      }
	      return query;
	    },

	    /**
	     * Gets an object's equivalent from dataSource
	     * @param  {number} id ID of requested object
	     * @return {object} Requested object
	     */
	    getDatabaseEntity: function getDatabaseEntity(object) {
	      var query = this.getEntityQuery(object);
	      return query ? this.collection.findOne(query) : null;
	    },

	    /**
	     * Gets an object by ID
	     * @param  {number} id ID of object to get
	     * @return {object} Requested object
	     */
	    get: function get(id) {
	      var query = {};
	      query[idAttr] = id;
	      return this.getDatabaseEntity(query);
	    },

	    /**
	     * Queries store
	     * @param  {object} query mongo-style query
	     * @return {array} Array of reuslts
	     */
	    find: function find(query) {
	      return this.collection.find(query);
	    },

	    /**
	     * Gets collection of objects
	     * @param  {number} parentId ParentID of objects, for relational data (optional)
	     * @return {array} Collection of objects
	     */
	    getCollection: function getCollection(tag) {
	      var collection = [];
	      if (tag) {
	        var view = this.collection.getDynamicView(tag);
	        collection = view ? view.data() : [];
	        // Hack to get around stale dynamic view data
	        collection = _.uniq(collection, function (obj) {
	          return obj[idAttr];
	        });
	      } else {
	        collection = this.find();
	      }
	      return collection;
	    },

	    getViewFilters: function getViewFilters(tag) {
	      if (!tag || !this.dynamicViews[tag]) {
	        return {};
	      }
	      return this.dynamicViews[tag].filters;
	    },

	    /**
	     * Creates a filter
	     * @param {string} tag Tag of Collection to be filtered
	     * @param {object} filterQuery filter query
	     * @return {event} Triggers event
	     */
	    filter: function filter(tag, filterQuery) {
	      if (!this.dynamicViews[tag]) {
	        this.dynamicViews[tag] = { filters: {}, sortBy: {}, search: "" };
	      }
	      this.collection.removeDynamicView(tag);

	      var viewParams = this.dynamicViews[tag];
	      _.extend(viewParams.filters, filterQuery);
	      this.registerView(tag, viewParams);
	    },

	    /**
	     * Creates a search
	     * @param {string} tag Tag of Collection to be searched
	     * @param {object} searchQuery search query
	     * @return {event} Triggers event
	     */
	    search: function search(tag, searchQuery) {
	      if (!this.dynamicViews[tag]) {
	        this.dynamicViews[tag] = { filters: {}, sortBy: {}, search: "" };
	      }
	      this.collection.removeDynamicView(tag);

	      var viewParams = this.dynamicViews[tag];
	      viewParams.search = searchQuery;

	      this.registerView(tag, viewParams);
	    },

	    /**
	     * Adds a sort parameter
	     * @param {string} tag Tag of Collection to be filtered
	     * @param {object} sortParam sort parameter
	     */
	    sort: function sort(tag, sortBy) {
	      if (!this.dynamicViews[tag]) {
	        this.dynamicViews[tag] = { filters: {}, sortBy: {}, search: "" };
	      }
	      this.collection.removeDynamicView(tag);

	      var viewParams = this.dynamicViews[tag];
	      viewParams.sortBy = sortBy;
	      this.registerView(tag, viewParams);
	    },

	    /**
	     * Removes filter and sort parameters from view
	     * @param {string} tag Tag of Collection to be reset
	     */
	    resetView: function resetView(tag, reregister) {
	      this.collection.removeDynamicView(tag);
	      if (reregister !== false) {
	        this.registerView(tag);
	      }
	    },

	    /**
	     * Generates new dynamic view
	     * @param {string} tag Tag of Collection to be filtered
	     * @param {object} sort and filter parameters
	     * @return {event} Triggers event
	     */
	    registerView: function registerView(tag, viewParams) {
	      this.collection.removeDynamicView(tag);
	      var view = this.collection.addDynamicView(tag);
	      if (!viewParams) {
	        return this.trigger("viewRegistered", tag);
	      }

	      var filters = viewParams.filters;
	      var sortBy = viewParams.sortBy;
	      var search = viewParams.search;

	      sortBy && view.applySimpleSort(sortBy.attribute, sortBy.isDescending);
	      sortBy && view.applySort(caseInsensitiveSort(sortBy));
	      filters && _applyViewFilters(view, filters);
	      search && view.applyWhere(_buildSearch(search));

	      this.trigger("viewRegistered", tag);
	    }
	  };
	}

	function caseInsensitiveSort(sortBy) {
	  return function (a, b) {
	    var aVal = a[sortBy.attribute] || "~";
	    var bVal = b[sortBy.attribute] || "~";
	    aVal = typeof aVal === "string" ? aVal.toLowerCase() : aVal;
	    bVal = typeof bVal === "string" ? bVal.toLowerCase() : bVal;
	    if (sortBy.isDescending) {
	      return aVal < bVal ? 1 : -1;
	    } else {
	      return aVal > bVal ? 1 : -1;
	    }
	  };
	}

	function _buildSearch(query) {
	  return function (object) {
	    var match = false;
	    Object.keys(object).forEach(function (key) {
	      if (!match) {
	        match = JSON.stringify(object[key]).toLowerCase().indexOf(query.toLowerCase()) !== -1;
	      }
	    });
	    return match;
	  };
	}

	function _buildFilter(key, value) {
	  var formattedValue = String(value).toLowerCase();
	  return function (object) {
	    if (value === undefined) {
	      return !object[key];
	    }
	    return String(object[key]).toLowerCase().indexOf(formattedValue) !== -1;
	  };
	}

	function _applyViewFilters(view, filters) {
	  Object.keys(filters).forEach(function (key) {
	    var query = null;
	    switch (filters[key]) {
	      case null:
	        break;
	      default:
	        query = _buildFilter(key, filters[key]);
	        break;
	    }
	    query && view.applyWhere(query);
	  });
	}

	module.exports = generateStore;

/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * @module ImmutableStore
	 */
	"use strict";

	var _require = __webpack_require__(25);

	var List = _require.List;

	/**
	 * Generates Store
	 * @param  {string} name name of resource
	 * @return {object}      Immutable Store Template
	 */
	function generateStore(options) {
	  var name = options.name;
	  var idAttr = options.idAttr;

	  return {
	    name: name,

	    dynamicViews: {},

	    /**
	     * Initializes store
	     */
	    init: function init() {
	      this.collection = List([]);
	    },

	    /**
	     * Adds an object to the store
	     * @param {object} object Object to add
	     * @return {event} Triggers event
	     */
	    add: function add(object) {
	      this.collection = this.collection.push(object);
	      this.trigger("add", this.get());
	    },

	    /**
	     * Sets collection
	     * @param {array} collection Collection to set
	     * @return {event} Triggers event
	     */
	    setCollection: function setCollection(collection) {
	      this.collection = List(collection);
	      this.trigger("setCollection", this.get());
	    },

	    /**
	     * Destroys object
	     * @param  {number} id ID of object to destroy
	     * @return {event} Triggers event
	     */
	    destroy: function destroy(id) {
	      this.collection = this.collection.filter(function (object) {
	        return id !== object[idAttr];
	      });
	      this.trigger("destroy", id);
	    },

	    /**
	     * Destroys all objects in the store
	     * @return {event} Triggers event
	     */
	    destroyAll: function destroyAll() {
	      this.collection = List();
	      this.trigger("destroyAll", this.get());
	    },

	    /**
	     * Updates an object in the store
	     * @param  {object} object Object to update
	     * @return {event} Triggers an event
	     */
	    update: function update(updated) {
	      this.collection = this.collection.filter(function (object) {
	        return updated[idAttr] !== object[idAttr];
	      });
	      this.collection = this.collection.push(updated);
	      this.trigger("update", updated);
	    },

	    /**
	     * Gets an object by ID
	     * @param  {number} id ID of object to get
	     * @return {object} Requested object
	     */
	    get: function get(id) {
	      if (!id) return this.collection.toArray();

	      return this.collection.find(function (object) {
	        return object[idAttr] === id;
	      }) || {};
	    },

	    /**
	     * Gets collection of objects
	     * @param  {number} parentId ParentID of objects, for relational data (optional)
	     * @return {array} Collection of objects
	     */
	    getCollection: function getCollection(tag) {
	      // TODO: Add dynamic view support
	      return this.collection.toArray();
	    }
	  };
	}

	module.exports = generateStore;

/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function defaultUrlBuilder(options) {
	  return {
	    /**
	     * Generate resource URL
	     * @return {string} resource API endpoint url
	     */
	    _getResourceUrl: function _getResourceUrl(object) {
	      return "" + this.basePath + "/" + this.endpoint;
	    },

	    /**
	     * Generate single resource URL
	     * @param  {number} id ID of resource
	     * @return {string} resource API url
	     */
	    _getObjectUrl: function _getObjectUrl(id) {
	      return "" + this.basePath + "/" + this.endpoint + "/" + id;
	    }
	  };
	}

	module.exports = defaultUrlBuilder;

/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";

	function dependentUrlBuilder(options) {
	  var fkAttr = options.fkAttr;

	  return {
	    /**
	     * Generate resource URL
	     * @param { object } object Object being operated upon
	     * @return {string} resource API endpoint url
	     */
	    _getResourceUrl: function _getResourceUrl(object) {
	      return "" + this.basePath + "/" + object[fkAttr] + "/" + this.endpoint;
	    },

	    /**
	     * Generate single resource URL
	     * @param  {number} id ID of resource
	     * @return {string} resource API url
	     */
	    _getObjectUrl: function _getObjectUrl(id) {
	      return "" + this.basePath + "/" + this.endpoint + "/" + id;
	    }
	  };
	}

	module.exports = dependentUrlBuilder;

/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(23);


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.8.3
	//     http://underscorejs.org
	//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	//     Underscore may be freely distributed under the MIT license.

	(function() {

	  // Baseline setup
	  // --------------

	  // Establish the root object, `window` in the browser, or `exports` on the server.
	  var root = this;

	  // Save the previous value of the `_` variable.
	  var previousUnderscore = root._;

	  // Save bytes in the minified (but not gzipped) version:
	  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

	  // Create quick reference variables for speed access to core prototypes.
	  var
	    push             = ArrayProto.push,
	    slice            = ArrayProto.slice,
	    toString         = ObjProto.toString,
	    hasOwnProperty   = ObjProto.hasOwnProperty;

	  // All **ECMAScript 5** native function implementations that we hope to use
	  // are declared here.
	  var
	    nativeIsArray      = Array.isArray,
	    nativeKeys         = Object.keys,
	    nativeBind         = FuncProto.bind,
	    nativeCreate       = Object.create;

	  // Naked function reference for surrogate-prototype-swapping.
	  var Ctor = function(){};

	  // Create a safe reference to the Underscore object for use below.
	  var _ = function(obj) {
	    if (obj instanceof _) return obj;
	    if (!(this instanceof _)) return new _(obj);
	    this._wrapped = obj;
	  };

	  // Export the Underscore object for **Node.js**, with
	  // backwards-compatibility for the old `require()` API. If we're in
	  // the browser, add `_` as a global object.
	  if (true) {
	    if (typeof module !== 'undefined' && module.exports) {
	      exports = module.exports = _;
	    }
	    exports._ = _;
	  } else {
	    root._ = _;
	  }

	  // Current version.
	  _.VERSION = '1.8.3';

	  // Internal function that returns an efficient (for current engines) version
	  // of the passed-in callback, to be repeatedly applied in other Underscore
	  // functions.
	  var optimizeCb = function(func, context, argCount) {
	    if (context === void 0) return func;
	    switch (argCount == null ? 3 : argCount) {
	      case 1: return function(value) {
	        return func.call(context, value);
	      };
	      case 2: return function(value, other) {
	        return func.call(context, value, other);
	      };
	      case 3: return function(value, index, collection) {
	        return func.call(context, value, index, collection);
	      };
	      case 4: return function(accumulator, value, index, collection) {
	        return func.call(context, accumulator, value, index, collection);
	      };
	    }
	    return function() {
	      return func.apply(context, arguments);
	    };
	  };

	  // A mostly-internal function to generate callbacks that can be applied
	  // to each element in a collection, returning the desired result  either
	  // identity, an arbitrary callback, a property matcher, or a property accessor.
	  var cb = function(value, context, argCount) {
	    if (value == null) return _.identity;
	    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
	    if (_.isObject(value)) return _.matcher(value);
	    return _.property(value);
	  };
	  _.iteratee = function(value, context) {
	    return cb(value, context, Infinity);
	  };

	  // An internal function for creating assigner functions.
	  var createAssigner = function(keysFunc, undefinedOnly) {
	    return function(obj) {
	      var length = arguments.length;
	      if (length < 2 || obj == null) return obj;
	      for (var index = 1; index < length; index++) {
	        var source = arguments[index],
	            keys = keysFunc(source),
	            l = keys.length;
	        for (var i = 0; i < l; i++) {
	          var key = keys[i];
	          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
	        }
	      }
	      return obj;
	    };
	  };

	  // An internal function for creating a new object that inherits from another.
	  var baseCreate = function(prototype) {
	    if (!_.isObject(prototype)) return {};
	    if (nativeCreate) return nativeCreate(prototype);
	    Ctor.prototype = prototype;
	    var result = new Ctor;
	    Ctor.prototype = null;
	    return result;
	  };

	  var property = function(key) {
	    return function(obj) {
	      return obj == null ? void 0 : obj[key];
	    };
	  };

	  // Helper for collection methods to determine whether a collection
	  // should be iterated as an array or as an object
	  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
	  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
	  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
	  var getLength = property('length');
	  var isArrayLike = function(collection) {
	    var length = getLength(collection);
	    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
	  };

	  // Collection Functions
	  // --------------------

	  // The cornerstone, an `each` implementation, aka `forEach`.
	  // Handles raw objects in addition to array-likes. Treats all
	  // sparse array-likes as if they were dense.
	  _.each = _.forEach = function(obj, iteratee, context) {
	    iteratee = optimizeCb(iteratee, context);
	    var i, length;
	    if (isArrayLike(obj)) {
	      for (i = 0, length = obj.length; i < length; i++) {
	        iteratee(obj[i], i, obj);
	      }
	    } else {
	      var keys = _.keys(obj);
	      for (i = 0, length = keys.length; i < length; i++) {
	        iteratee(obj[keys[i]], keys[i], obj);
	      }
	    }
	    return obj;
	  };

	  // Return the results of applying the iteratee to each element.
	  _.map = _.collect = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length,
	        results = Array(length);
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      results[index] = iteratee(obj[currentKey], currentKey, obj);
	    }
	    return results;
	  };

	  // Create a reducing function iterating left or right.
	  function createReduce(dir) {
	    // Optimized iterator function as using arguments.length
	    // in the main function will deoptimize the, see #1991.
	    function iterator(obj, iteratee, memo, keys, index, length) {
	      for (; index >= 0 && index < length; index += dir) {
	        var currentKey = keys ? keys[index] : index;
	        memo = iteratee(memo, obj[currentKey], currentKey, obj);
	      }
	      return memo;
	    }

	    return function(obj, iteratee, memo, context) {
	      iteratee = optimizeCb(iteratee, context, 4);
	      var keys = !isArrayLike(obj) && _.keys(obj),
	          length = (keys || obj).length,
	          index = dir > 0 ? 0 : length - 1;
	      // Determine the initial value if none is provided.
	      if (arguments.length < 3) {
	        memo = obj[keys ? keys[index] : index];
	        index += dir;
	      }
	      return iterator(obj, iteratee, memo, keys, index, length);
	    };
	  }

	  // **Reduce** builds up a single result from a list of values, aka `inject`,
	  // or `foldl`.
	  _.reduce = _.foldl = _.inject = createReduce(1);

	  // The right-associative version of reduce, also known as `foldr`.
	  _.reduceRight = _.foldr = createReduce(-1);

	  // Return the first value which passes a truth test. Aliased as `detect`.
	  _.find = _.detect = function(obj, predicate, context) {
	    var key;
	    if (isArrayLike(obj)) {
	      key = _.findIndex(obj, predicate, context);
	    } else {
	      key = _.findKey(obj, predicate, context);
	    }
	    if (key !== void 0 && key !== -1) return obj[key];
	  };

	  // Return all the elements that pass a truth test.
	  // Aliased as `select`.
	  _.filter = _.select = function(obj, predicate, context) {
	    var results = [];
	    predicate = cb(predicate, context);
	    _.each(obj, function(value, index, list) {
	      if (predicate(value, index, list)) results.push(value);
	    });
	    return results;
	  };

	  // Return all the elements for which a truth test fails.
	  _.reject = function(obj, predicate, context) {
	    return _.filter(obj, _.negate(cb(predicate)), context);
	  };

	  // Determine whether all of the elements match a truth test.
	  // Aliased as `all`.
	  _.every = _.all = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (!predicate(obj[currentKey], currentKey, obj)) return false;
	    }
	    return true;
	  };

	  // Determine if at least one element in the object matches a truth test.
	  // Aliased as `any`.
	  _.some = _.any = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = !isArrayLike(obj) && _.keys(obj),
	        length = (keys || obj).length;
	    for (var index = 0; index < length; index++) {
	      var currentKey = keys ? keys[index] : index;
	      if (predicate(obj[currentKey], currentKey, obj)) return true;
	    }
	    return false;
	  };

	  // Determine if the array or object contains a given item (using `===`).
	  // Aliased as `includes` and `include`.
	  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
	    if (!isArrayLike(obj)) obj = _.values(obj);
	    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
	    return _.indexOf(obj, item, fromIndex) >= 0;
	  };

	  // Invoke a method (with arguments) on every item in a collection.
	  _.invoke = function(obj, method) {
	    var args = slice.call(arguments, 2);
	    var isFunc = _.isFunction(method);
	    return _.map(obj, function(value) {
	      var func = isFunc ? method : value[method];
	      return func == null ? func : func.apply(value, args);
	    });
	  };

	  // Convenience version of a common use case of `map`: fetching a property.
	  _.pluck = function(obj, key) {
	    return _.map(obj, _.property(key));
	  };

	  // Convenience version of a common use case of `filter`: selecting only objects
	  // containing specific `key:value` pairs.
	  _.where = function(obj, attrs) {
	    return _.filter(obj, _.matcher(attrs));
	  };

	  // Convenience version of a common use case of `find`: getting the first object
	  // containing specific `key:value` pairs.
	  _.findWhere = function(obj, attrs) {
	    return _.find(obj, _.matcher(attrs));
	  };

	  // Return the maximum element (or element-based computation).
	  _.max = function(obj, iteratee, context) {
	    var result = -Infinity, lastComputed = -Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value > result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Return the minimum element (or element-based computation).
	  _.min = function(obj, iteratee, context) {
	    var result = Infinity, lastComputed = Infinity,
	        value, computed;
	    if (iteratee == null && obj != null) {
	      obj = isArrayLike(obj) ? obj : _.values(obj);
	      for (var i = 0, length = obj.length; i < length; i++) {
	        value = obj[i];
	        if (value < result) {
	          result = value;
	        }
	      }
	    } else {
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index, list) {
	        computed = iteratee(value, index, list);
	        if (computed < lastComputed || computed === Infinity && result === Infinity) {
	          result = value;
	          lastComputed = computed;
	        }
	      });
	    }
	    return result;
	  };

	  // Shuffle a collection, using the modern version of the
	  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
	  _.shuffle = function(obj) {
	    var set = isArrayLike(obj) ? obj : _.values(obj);
	    var length = set.length;
	    var shuffled = Array(length);
	    for (var index = 0, rand; index < length; index++) {
	      rand = _.random(0, index);
	      if (rand !== index) shuffled[index] = shuffled[rand];
	      shuffled[rand] = set[index];
	    }
	    return shuffled;
	  };

	  // Sample **n** random values from a collection.
	  // If **n** is not specified, returns a single random element.
	  // The internal `guard` argument allows it to work with `map`.
	  _.sample = function(obj, n, guard) {
	    if (n == null || guard) {
	      if (!isArrayLike(obj)) obj = _.values(obj);
	      return obj[_.random(obj.length - 1)];
	    }
	    return _.shuffle(obj).slice(0, Math.max(0, n));
	  };

	  // Sort the object's values by a criterion produced by an iteratee.
	  _.sortBy = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    return _.pluck(_.map(obj, function(value, index, list) {
	      return {
	        value: value,
	        index: index,
	        criteria: iteratee(value, index, list)
	      };
	    }).sort(function(left, right) {
	      var a = left.criteria;
	      var b = right.criteria;
	      if (a !== b) {
	        if (a > b || a === void 0) return 1;
	        if (a < b || b === void 0) return -1;
	      }
	      return left.index - right.index;
	    }), 'value');
	  };

	  // An internal function used for aggregate "group by" operations.
	  var group = function(behavior) {
	    return function(obj, iteratee, context) {
	      var result = {};
	      iteratee = cb(iteratee, context);
	      _.each(obj, function(value, index) {
	        var key = iteratee(value, index, obj);
	        behavior(result, value, key);
	      });
	      return result;
	    };
	  };

	  // Groups the object's values by a criterion. Pass either a string attribute
	  // to group by, or a function that returns the criterion.
	  _.groupBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
	  });

	  // Indexes the object's values by a criterion, similar to `groupBy`, but for
	  // when you know that your index values will be unique.
	  _.indexBy = group(function(result, value, key) {
	    result[key] = value;
	  });

	  // Counts instances of an object that group by a certain criterion. Pass
	  // either a string attribute to count by, or a function that returns the
	  // criterion.
	  _.countBy = group(function(result, value, key) {
	    if (_.has(result, key)) result[key]++; else result[key] = 1;
	  });

	  // Safely create a real, live array from anything iterable.
	  _.toArray = function(obj) {
	    if (!obj) return [];
	    if (_.isArray(obj)) return slice.call(obj);
	    if (isArrayLike(obj)) return _.map(obj, _.identity);
	    return _.values(obj);
	  };

	  // Return the number of elements in an object.
	  _.size = function(obj) {
	    if (obj == null) return 0;
	    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
	  };

	  // Split a collection into two arrays: one whose elements all satisfy the given
	  // predicate, and one whose elements all do not satisfy the predicate.
	  _.partition = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var pass = [], fail = [];
	    _.each(obj, function(value, key, obj) {
	      (predicate(value, key, obj) ? pass : fail).push(value);
	    });
	    return [pass, fail];
	  };

	  // Array Functions
	  // ---------------

	  // Get the first element of an array. Passing **n** will return the first N
	  // values in the array. Aliased as `head` and `take`. The **guard** check
	  // allows it to work with `_.map`.
	  _.first = _.head = _.take = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[0];
	    return _.initial(array, array.length - n);
	  };

	  // Returns everything but the last entry of the array. Especially useful on
	  // the arguments object. Passing **n** will return all the values in
	  // the array, excluding the last N.
	  _.initial = function(array, n, guard) {
	    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
	  };

	  // Get the last element of an array. Passing **n** will return the last N
	  // values in the array.
	  _.last = function(array, n, guard) {
	    if (array == null) return void 0;
	    if (n == null || guard) return array[array.length - 1];
	    return _.rest(array, Math.max(0, array.length - n));
	  };

	  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
	  // Especially useful on the arguments object. Passing an **n** will return
	  // the rest N values in the array.
	  _.rest = _.tail = _.drop = function(array, n, guard) {
	    return slice.call(array, n == null || guard ? 1 : n);
	  };

	  // Trim out all falsy values from an array.
	  _.compact = function(array) {
	    return _.filter(array, _.identity);
	  };

	  // Internal implementation of a recursive `flatten` function.
	  var flatten = function(input, shallow, strict, startIndex) {
	    var output = [], idx = 0;
	    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
	      var value = input[i];
	      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
	        //flatten current level of array or arguments object
	        if (!shallow) value = flatten(value, shallow, strict);
	        var j = 0, len = value.length;
	        output.length += len;
	        while (j < len) {
	          output[idx++] = value[j++];
	        }
	      } else if (!strict) {
	        output[idx++] = value;
	      }
	    }
	    return output;
	  };

	  // Flatten out an array, either recursively (by default), or just one level.
	  _.flatten = function(array, shallow) {
	    return flatten(array, shallow, false);
	  };

	  // Return a version of the array that does not contain the specified value(s).
	  _.without = function(array) {
	    return _.difference(array, slice.call(arguments, 1));
	  };

	  // Produce a duplicate-free version of the array. If the array has already
	  // been sorted, you have the option of using a faster algorithm.
	  // Aliased as `unique`.
	  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
	    if (!_.isBoolean(isSorted)) {
	      context = iteratee;
	      iteratee = isSorted;
	      isSorted = false;
	    }
	    if (iteratee != null) iteratee = cb(iteratee, context);
	    var result = [];
	    var seen = [];
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var value = array[i],
	          computed = iteratee ? iteratee(value, i, array) : value;
	      if (isSorted) {
	        if (!i || seen !== computed) result.push(value);
	        seen = computed;
	      } else if (iteratee) {
	        if (!_.contains(seen, computed)) {
	          seen.push(computed);
	          result.push(value);
	        }
	      } else if (!_.contains(result, value)) {
	        result.push(value);
	      }
	    }
	    return result;
	  };

	  // Produce an array that contains the union: each distinct element from all of
	  // the passed-in arrays.
	  _.union = function() {
	    return _.uniq(flatten(arguments, true, true));
	  };

	  // Produce an array that contains every item shared between all the
	  // passed-in arrays.
	  _.intersection = function(array) {
	    var result = [];
	    var argsLength = arguments.length;
	    for (var i = 0, length = getLength(array); i < length; i++) {
	      var item = array[i];
	      if (_.contains(result, item)) continue;
	      for (var j = 1; j < argsLength; j++) {
	        if (!_.contains(arguments[j], item)) break;
	      }
	      if (j === argsLength) result.push(item);
	    }
	    return result;
	  };

	  // Take the difference between one array and a number of other arrays.
	  // Only the elements present in just the first array will remain.
	  _.difference = function(array) {
	    var rest = flatten(arguments, true, true, 1);
	    return _.filter(array, function(value){
	      return !_.contains(rest, value);
	    });
	  };

	  // Zip together multiple lists into a single array -- elements that share
	  // an index go together.
	  _.zip = function() {
	    return _.unzip(arguments);
	  };

	  // Complement of _.zip. Unzip accepts an array of arrays and groups
	  // each array's elements on shared indices
	  _.unzip = function(array) {
	    var length = array && _.max(array, getLength).length || 0;
	    var result = Array(length);

	    for (var index = 0; index < length; index++) {
	      result[index] = _.pluck(array, index);
	    }
	    return result;
	  };

	  // Converts lists into objects. Pass either a single array of `[key, value]`
	  // pairs, or two parallel arrays of the same length -- one of keys, and one of
	  // the corresponding values.
	  _.object = function(list, values) {
	    var result = {};
	    for (var i = 0, length = getLength(list); i < length; i++) {
	      if (values) {
	        result[list[i]] = values[i];
	      } else {
	        result[list[i][0]] = list[i][1];
	      }
	    }
	    return result;
	  };

	  // Generator function to create the findIndex and findLastIndex functions
	  function createPredicateIndexFinder(dir) {
	    return function(array, predicate, context) {
	      predicate = cb(predicate, context);
	      var length = getLength(array);
	      var index = dir > 0 ? 0 : length - 1;
	      for (; index >= 0 && index < length; index += dir) {
	        if (predicate(array[index], index, array)) return index;
	      }
	      return -1;
	    };
	  }

	  // Returns the first index on an array-like that passes a predicate test
	  _.findIndex = createPredicateIndexFinder(1);
	  _.findLastIndex = createPredicateIndexFinder(-1);

	  // Use a comparator function to figure out the smallest index at which
	  // an object should be inserted so as to maintain order. Uses binary search.
	  _.sortedIndex = function(array, obj, iteratee, context) {
	    iteratee = cb(iteratee, context, 1);
	    var value = iteratee(obj);
	    var low = 0, high = getLength(array);
	    while (low < high) {
	      var mid = Math.floor((low + high) / 2);
	      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
	    }
	    return low;
	  };

	  // Generator function to create the indexOf and lastIndexOf functions
	  function createIndexFinder(dir, predicateFind, sortedIndex) {
	    return function(array, item, idx) {
	      var i = 0, length = getLength(array);
	      if (typeof idx == 'number') {
	        if (dir > 0) {
	            i = idx >= 0 ? idx : Math.max(idx + length, i);
	        } else {
	            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
	        }
	      } else if (sortedIndex && idx && length) {
	        idx = sortedIndex(array, item);
	        return array[idx] === item ? idx : -1;
	      }
	      if (item !== item) {
	        idx = predicateFind(slice.call(array, i, length), _.isNaN);
	        return idx >= 0 ? idx + i : -1;
	      }
	      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
	        if (array[idx] === item) return idx;
	      }
	      return -1;
	    };
	  }

	  // Return the position of the first occurrence of an item in an array,
	  // or -1 if the item is not included in the array.
	  // If the array is large and already in sort order, pass `true`
	  // for **isSorted** to use binary search.
	  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
	  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

	  // Generate an integer Array containing an arithmetic progression. A port of
	  // the native Python `range()` function. See
	  // [the Python documentation](http://docs.python.org/library/functions.html#range).
	  _.range = function(start, stop, step) {
	    if (stop == null) {
	      stop = start || 0;
	      start = 0;
	    }
	    step = step || 1;

	    var length = Math.max(Math.ceil((stop - start) / step), 0);
	    var range = Array(length);

	    for (var idx = 0; idx < length; idx++, start += step) {
	      range[idx] = start;
	    }

	    return range;
	  };

	  // Function (ahem) Functions
	  // ------------------

	  // Determines whether to execute a function as a constructor
	  // or a normal function with the provided arguments
	  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
	    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
	    var self = baseCreate(sourceFunc.prototype);
	    var result = sourceFunc.apply(self, args);
	    if (_.isObject(result)) return result;
	    return self;
	  };

	  // Create a function bound to a given object (assigning `this`, and arguments,
	  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
	  // available.
	  _.bind = function(func, context) {
	    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
	    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
	    var args = slice.call(arguments, 2);
	    var bound = function() {
	      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
	    };
	    return bound;
	  };

	  // Partially apply a function by creating a version that has had some of its
	  // arguments pre-filled, without changing its dynamic `this` context. _ acts
	  // as a placeholder, allowing any combination of arguments to be pre-filled.
	  _.partial = function(func) {
	    var boundArgs = slice.call(arguments, 1);
	    var bound = function() {
	      var position = 0, length = boundArgs.length;
	      var args = Array(length);
	      for (var i = 0; i < length; i++) {
	        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
	      }
	      while (position < arguments.length) args.push(arguments[position++]);
	      return executeBound(func, bound, this, this, args);
	    };
	    return bound;
	  };

	  // Bind a number of an object's methods to that object. Remaining arguments
	  // are the method names to be bound. Useful for ensuring that all callbacks
	  // defined on an object belong to it.
	  _.bindAll = function(obj) {
	    var i, length = arguments.length, key;
	    if (length <= 1) throw new Error('bindAll must be passed function names');
	    for (i = 1; i < length; i++) {
	      key = arguments[i];
	      obj[key] = _.bind(obj[key], obj);
	    }
	    return obj;
	  };

	  // Memoize an expensive function by storing its results.
	  _.memoize = function(func, hasher) {
	    var memoize = function(key) {
	      var cache = memoize.cache;
	      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
	      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
	      return cache[address];
	    };
	    memoize.cache = {};
	    return memoize;
	  };

	  // Delays a function for the given number of milliseconds, and then calls
	  // it with the arguments supplied.
	  _.delay = function(func, wait) {
	    var args = slice.call(arguments, 2);
	    return setTimeout(function(){
	      return func.apply(null, args);
	    }, wait);
	  };

	  // Defers a function, scheduling it to run after the current call stack has
	  // cleared.
	  _.defer = _.partial(_.delay, _, 1);

	  // Returns a function, that, when invoked, will only be triggered at most once
	  // during a given window of time. Normally, the throttled function will run
	  // as much as it can, without ever going more than once per `wait` duration;
	  // but if you'd like to disable the execution on the leading edge, pass
	  // `{leading: false}`. To disable execution on the trailing edge, ditto.
	  _.throttle = function(func, wait, options) {
	    var context, args, result;
	    var timeout = null;
	    var previous = 0;
	    if (!options) options = {};
	    var later = function() {
	      previous = options.leading === false ? 0 : _.now();
	      timeout = null;
	      result = func.apply(context, args);
	      if (!timeout) context = args = null;
	    };
	    return function() {
	      var now = _.now();
	      if (!previous && options.leading === false) previous = now;
	      var remaining = wait - (now - previous);
	      context = this;
	      args = arguments;
	      if (remaining <= 0 || remaining > wait) {
	        if (timeout) {
	          clearTimeout(timeout);
	          timeout = null;
	        }
	        previous = now;
	        result = func.apply(context, args);
	        if (!timeout) context = args = null;
	      } else if (!timeout && options.trailing !== false) {
	        timeout = setTimeout(later, remaining);
	      }
	      return result;
	    };
	  };

	  // Returns a function, that, as long as it continues to be invoked, will not
	  // be triggered. The function will be called after it stops being called for
	  // N milliseconds. If `immediate` is passed, trigger the function on the
	  // leading edge, instead of the trailing.
	  _.debounce = function(func, wait, immediate) {
	    var timeout, args, context, timestamp, result;

	    var later = function() {
	      var last = _.now() - timestamp;

	      if (last < wait && last >= 0) {
	        timeout = setTimeout(later, wait - last);
	      } else {
	        timeout = null;
	        if (!immediate) {
	          result = func.apply(context, args);
	          if (!timeout) context = args = null;
	        }
	      }
	    };

	    return function() {
	      context = this;
	      args = arguments;
	      timestamp = _.now();
	      var callNow = immediate && !timeout;
	      if (!timeout) timeout = setTimeout(later, wait);
	      if (callNow) {
	        result = func.apply(context, args);
	        context = args = null;
	      }

	      return result;
	    };
	  };

	  // Returns the first function passed as an argument to the second,
	  // allowing you to adjust arguments, run code before and after, and
	  // conditionally execute the original function.
	  _.wrap = function(func, wrapper) {
	    return _.partial(wrapper, func);
	  };

	  // Returns a negated version of the passed-in predicate.
	  _.negate = function(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    };
	  };

	  // Returns a function that is the composition of a list of functions, each
	  // consuming the return value of the function that follows.
	  _.compose = function() {
	    var args = arguments;
	    var start = args.length - 1;
	    return function() {
	      var i = start;
	      var result = args[start].apply(this, arguments);
	      while (i--) result = args[i].call(this, result);
	      return result;
	    };
	  };

	  // Returns a function that will only be executed on and after the Nth call.
	  _.after = function(times, func) {
	    return function() {
	      if (--times < 1) {
	        return func.apply(this, arguments);
	      }
	    };
	  };

	  // Returns a function that will only be executed up to (but not including) the Nth call.
	  _.before = function(times, func) {
	    var memo;
	    return function() {
	      if (--times > 0) {
	        memo = func.apply(this, arguments);
	      }
	      if (times <= 1) func = null;
	      return memo;
	    };
	  };

	  // Returns a function that will be executed at most one time, no matter how
	  // often you call it. Useful for lazy initialization.
	  _.once = _.partial(_.before, 2);

	  // Object Functions
	  // ----------------

	  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
	  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
	  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
	                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

	  function collectNonEnumProps(obj, keys) {
	    var nonEnumIdx = nonEnumerableProps.length;
	    var constructor = obj.constructor;
	    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

	    // Constructor is a special case.
	    var prop = 'constructor';
	    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

	    while (nonEnumIdx--) {
	      prop = nonEnumerableProps[nonEnumIdx];
	      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
	        keys.push(prop);
	      }
	    }
	  }

	  // Retrieve the names of an object's own properties.
	  // Delegates to **ECMAScript 5**'s native `Object.keys`
	  _.keys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    if (nativeKeys) return nativeKeys(obj);
	    var keys = [];
	    for (var key in obj) if (_.has(obj, key)) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve all the property names of an object.
	  _.allKeys = function(obj) {
	    if (!_.isObject(obj)) return [];
	    var keys = [];
	    for (var key in obj) keys.push(key);
	    // Ahem, IE < 9.
	    if (hasEnumBug) collectNonEnumProps(obj, keys);
	    return keys;
	  };

	  // Retrieve the values of an object's properties.
	  _.values = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var values = Array(length);
	    for (var i = 0; i < length; i++) {
	      values[i] = obj[keys[i]];
	    }
	    return values;
	  };

	  // Returns the results of applying the iteratee to each element of the object
	  // In contrast to _.map it returns an object
	  _.mapObject = function(obj, iteratee, context) {
	    iteratee = cb(iteratee, context);
	    var keys =  _.keys(obj),
	          length = keys.length,
	          results = {},
	          currentKey;
	      for (var index = 0; index < length; index++) {
	        currentKey = keys[index];
	        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
	      }
	      return results;
	  };

	  // Convert an object into a list of `[key, value]` pairs.
	  _.pairs = function(obj) {
	    var keys = _.keys(obj);
	    var length = keys.length;
	    var pairs = Array(length);
	    for (var i = 0; i < length; i++) {
	      pairs[i] = [keys[i], obj[keys[i]]];
	    }
	    return pairs;
	  };

	  // Invert the keys and values of an object. The values must be serializable.
	  _.invert = function(obj) {
	    var result = {};
	    var keys = _.keys(obj);
	    for (var i = 0, length = keys.length; i < length; i++) {
	      result[obj[keys[i]]] = keys[i];
	    }
	    return result;
	  };

	  // Return a sorted list of the function names available on the object.
	  // Aliased as `methods`
	  _.functions = _.methods = function(obj) {
	    var names = [];
	    for (var key in obj) {
	      if (_.isFunction(obj[key])) names.push(key);
	    }
	    return names.sort();
	  };

	  // Extend a given object with all the properties in passed-in object(s).
	  _.extend = createAssigner(_.allKeys);

	  // Assigns a given object with all the own properties in the passed-in object(s)
	  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
	  _.extendOwn = _.assign = createAssigner(_.keys);

	  // Returns the first key on an object that passes a predicate test
	  _.findKey = function(obj, predicate, context) {
	    predicate = cb(predicate, context);
	    var keys = _.keys(obj), key;
	    for (var i = 0, length = keys.length; i < length; i++) {
	      key = keys[i];
	      if (predicate(obj[key], key, obj)) return key;
	    }
	  };

	  // Return a copy of the object only containing the whitelisted properties.
	  _.pick = function(object, oiteratee, context) {
	    var result = {}, obj = object, iteratee, keys;
	    if (obj == null) return result;
	    if (_.isFunction(oiteratee)) {
	      keys = _.allKeys(obj);
	      iteratee = optimizeCb(oiteratee, context);
	    } else {
	      keys = flatten(arguments, false, false, 1);
	      iteratee = function(value, key, obj) { return key in obj; };
	      obj = Object(obj);
	    }
	    for (var i = 0, length = keys.length; i < length; i++) {
	      var key = keys[i];
	      var value = obj[key];
	      if (iteratee(value, key, obj)) result[key] = value;
	    }
	    return result;
	  };

	   // Return a copy of the object without the blacklisted properties.
	  _.omit = function(obj, iteratee, context) {
	    if (_.isFunction(iteratee)) {
	      iteratee = _.negate(iteratee);
	    } else {
	      var keys = _.map(flatten(arguments, false, false, 1), String);
	      iteratee = function(value, key) {
	        return !_.contains(keys, key);
	      };
	    }
	    return _.pick(obj, iteratee, context);
	  };

	  // Fill in a given object with default properties.
	  _.defaults = createAssigner(_.allKeys, true);

	  // Creates an object that inherits from the given prototype object.
	  // If additional properties are provided then they will be added to the
	  // created object.
	  _.create = function(prototype, props) {
	    var result = baseCreate(prototype);
	    if (props) _.extendOwn(result, props);
	    return result;
	  };

	  // Create a (shallow-cloned) duplicate of an object.
	  _.clone = function(obj) {
	    if (!_.isObject(obj)) return obj;
	    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
	  };

	  // Invokes interceptor with the obj, and then returns obj.
	  // The primary purpose of this method is to "tap into" a method chain, in
	  // order to perform operations on intermediate results within the chain.
	  _.tap = function(obj, interceptor) {
	    interceptor(obj);
	    return obj;
	  };

	  // Returns whether an object has a given set of `key:value` pairs.
	  _.isMatch = function(object, attrs) {
	    var keys = _.keys(attrs), length = keys.length;
	    if (object == null) return !length;
	    var obj = Object(object);
	    for (var i = 0; i < length; i++) {
	      var key = keys[i];
	      if (attrs[key] !== obj[key] || !(key in obj)) return false;
	    }
	    return true;
	  };


	  // Internal recursive comparison function for `isEqual`.
	  var eq = function(a, b, aStack, bStack) {
	    // Identical objects are equal. `0 === -0`, but they aren't identical.
	    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
	    if (a === b) return a !== 0 || 1 / a === 1 / b;
	    // A strict comparison is necessary because `null == undefined`.
	    if (a == null || b == null) return a === b;
	    // Unwrap any wrapped objects.
	    if (a instanceof _) a = a._wrapped;
	    if (b instanceof _) b = b._wrapped;
	    // Compare `[[Class]]` names.
	    var className = toString.call(a);
	    if (className !== toString.call(b)) return false;
	    switch (className) {
	      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
	      case '[object RegExp]':
	      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
	      case '[object String]':
	        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
	        // equivalent to `new String("5")`.
	        return '' + a === '' + b;
	      case '[object Number]':
	        // `NaN`s are equivalent, but non-reflexive.
	        // Object(NaN) is equivalent to NaN
	        if (+a !== +a) return +b !== +b;
	        // An `egal` comparison is performed for other numeric values.
	        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
	      case '[object Date]':
	      case '[object Boolean]':
	        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
	        // millisecond representations. Note that invalid dates with millisecond representations
	        // of `NaN` are not equivalent.
	        return +a === +b;
	    }

	    var areArrays = className === '[object Array]';
	    if (!areArrays) {
	      if (typeof a != 'object' || typeof b != 'object') return false;

	      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
	      // from different frames are.
	      var aCtor = a.constructor, bCtor = b.constructor;
	      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
	                               _.isFunction(bCtor) && bCtor instanceof bCtor)
	                          && ('constructor' in a && 'constructor' in b)) {
	        return false;
	      }
	    }
	    // Assume equality for cyclic structures. The algorithm for detecting cyclic
	    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

	    // Initializing stack of traversed objects.
	    // It's done here since we only need them for objects and arrays comparison.
	    aStack = aStack || [];
	    bStack = bStack || [];
	    var length = aStack.length;
	    while (length--) {
	      // Linear search. Performance is inversely proportional to the number of
	      // unique nested structures.
	      if (aStack[length] === a) return bStack[length] === b;
	    }

	    // Add the first object to the stack of traversed objects.
	    aStack.push(a);
	    bStack.push(b);

	    // Recursively compare objects and arrays.
	    if (areArrays) {
	      // Compare array lengths to determine if a deep comparison is necessary.
	      length = a.length;
	      if (length !== b.length) return false;
	      // Deep compare the contents, ignoring non-numeric properties.
	      while (length--) {
	        if (!eq(a[length], b[length], aStack, bStack)) return false;
	      }
	    } else {
	      // Deep compare objects.
	      var keys = _.keys(a), key;
	      length = keys.length;
	      // Ensure that both objects contain the same number of properties before comparing deep equality.
	      if (_.keys(b).length !== length) return false;
	      while (length--) {
	        // Deep compare each member
	        key = keys[length];
	        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
	      }
	    }
	    // Remove the first object from the stack of traversed objects.
	    aStack.pop();
	    bStack.pop();
	    return true;
	  };

	  // Perform a deep comparison to check if two objects are equal.
	  _.isEqual = function(a, b) {
	    return eq(a, b);
	  };

	  // Is a given array, string, or object empty?
	  // An "empty" object has no enumerable own-properties.
	  _.isEmpty = function(obj) {
	    if (obj == null) return true;
	    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
	    return _.keys(obj).length === 0;
	  };

	  // Is a given value a DOM element?
	  _.isElement = function(obj) {
	    return !!(obj && obj.nodeType === 1);
	  };

	  // Is a given value an array?
	  // Delegates to ECMA5's native Array.isArray
	  _.isArray = nativeIsArray || function(obj) {
	    return toString.call(obj) === '[object Array]';
	  };

	  // Is a given variable an object?
	  _.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	  };

	  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
	  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
	    _['is' + name] = function(obj) {
	      return toString.call(obj) === '[object ' + name + ']';
	    };
	  });

	  // Define a fallback version of the method in browsers (ahem, IE < 9), where
	  // there isn't any inspectable "Arguments" type.
	  if (!_.isArguments(arguments)) {
	    _.isArguments = function(obj) {
	      return _.has(obj, 'callee');
	    };
	  }

	  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
	  // IE 11 (#1621), and in Safari 8 (#1929).
	  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
	    _.isFunction = function(obj) {
	      return typeof obj == 'function' || false;
	    };
	  }

	  // Is a given object a finite number?
	  _.isFinite = function(obj) {
	    return isFinite(obj) && !isNaN(parseFloat(obj));
	  };

	  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
	  _.isNaN = function(obj) {
	    return _.isNumber(obj) && obj !== +obj;
	  };

	  // Is a given value a boolean?
	  _.isBoolean = function(obj) {
	    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
	  };

	  // Is a given value equal to null?
	  _.isNull = function(obj) {
	    return obj === null;
	  };

	  // Is a given variable undefined?
	  _.isUndefined = function(obj) {
	    return obj === void 0;
	  };

	  // Shortcut function for checking if an object has a given property directly
	  // on itself (in other words, not on a prototype).
	  _.has = function(obj, key) {
	    return obj != null && hasOwnProperty.call(obj, key);
	  };

	  // Utility Functions
	  // -----------------

	  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
	  // previous owner. Returns a reference to the Underscore object.
	  _.noConflict = function() {
	    root._ = previousUnderscore;
	    return this;
	  };

	  // Keep the identity function around for default iteratees.
	  _.identity = function(value) {
	    return value;
	  };

	  // Predicate-generating functions. Often useful outside of Underscore.
	  _.constant = function(value) {
	    return function() {
	      return value;
	    };
	  };

	  _.noop = function(){};

	  _.property = property;

	  // Generates a function for a given object that returns a given property.
	  _.propertyOf = function(obj) {
	    return obj == null ? function(){} : function(key) {
	      return obj[key];
	    };
	  };

	  // Returns a predicate for checking whether an object has a given set of
	  // `key:value` pairs.
	  _.matcher = _.matches = function(attrs) {
	    attrs = _.extendOwn({}, attrs);
	    return function(obj) {
	      return _.isMatch(obj, attrs);
	    };
	  };

	  // Run a function **n** times.
	  _.times = function(n, iteratee, context) {
	    var accum = Array(Math.max(0, n));
	    iteratee = optimizeCb(iteratee, context, 1);
	    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
	    return accum;
	  };

	  // Return a random integer between min and max (inclusive).
	  _.random = function(min, max) {
	    if (max == null) {
	      max = min;
	      min = 0;
	    }
	    return min + Math.floor(Math.random() * (max - min + 1));
	  };

	  // A (possibly faster) way to get the current timestamp as an integer.
	  _.now = Date.now || function() {
	    return new Date().getTime();
	  };

	   // List of HTML entities for escaping.
	  var escapeMap = {
	    '&': '&amp;',
	    '<': '&lt;',
	    '>': '&gt;',
	    '"': '&quot;',
	    "'": '&#x27;',
	    '`': '&#x60;'
	  };
	  var unescapeMap = _.invert(escapeMap);

	  // Functions for escaping and unescaping strings to/from HTML interpolation.
	  var createEscaper = function(map) {
	    var escaper = function(match) {
	      return map[match];
	    };
	    // Regexes for identifying a key that needs to be escaped
	    var source = '(?:' + _.keys(map).join('|') + ')';
	    var testRegexp = RegExp(source);
	    var replaceRegexp = RegExp(source, 'g');
	    return function(string) {
	      string = string == null ? '' : '' + string;
	      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
	    };
	  };
	  _.escape = createEscaper(escapeMap);
	  _.unescape = createEscaper(unescapeMap);

	  // If the value of the named `property` is a function then invoke it with the
	  // `object` as context; otherwise, return it.
	  _.result = function(object, property, fallback) {
	    var value = object == null ? void 0 : object[property];
	    if (value === void 0) {
	      value = fallback;
	    }
	    return _.isFunction(value) ? value.call(object) : value;
	  };

	  // Generate a unique integer id (unique within the entire client session).
	  // Useful for temporary DOM ids.
	  var idCounter = 0;
	  _.uniqueId = function(prefix) {
	    var id = ++idCounter + '';
	    return prefix ? prefix + id : id;
	  };

	  // By default, Underscore uses ERB-style template delimiters, change the
	  // following template settings to use alternative delimiters.
	  _.templateSettings = {
	    evaluate    : /<%([\s\S]+?)%>/g,
	    interpolate : /<%=([\s\S]+?)%>/g,
	    escape      : /<%-([\s\S]+?)%>/g
	  };

	  // When customizing `templateSettings`, if you don't want to define an
	  // interpolation, evaluation or escaping regex, we need one that is
	  // guaranteed not to match.
	  var noMatch = /(.)^/;

	  // Certain characters need to be escaped so that they can be put into a
	  // string literal.
	  var escapes = {
	    "'":      "'",
	    '\\':     '\\',
	    '\r':     'r',
	    '\n':     'n',
	    '\u2028': 'u2028',
	    '\u2029': 'u2029'
	  };

	  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

	  var escapeChar = function(match) {
	    return '\\' + escapes[match];
	  };

	  // JavaScript micro-templating, similar to John Resig's implementation.
	  // Underscore templating handles arbitrary delimiters, preserves whitespace,
	  // and correctly escapes quotes within interpolated code.
	  // NB: `oldSettings` only exists for backwards compatibility.
	  _.template = function(text, settings, oldSettings) {
	    if (!settings && oldSettings) settings = oldSettings;
	    settings = _.defaults({}, settings, _.templateSettings);

	    // Combine delimiters into one regular expression via alternation.
	    var matcher = RegExp([
	      (settings.escape || noMatch).source,
	      (settings.interpolate || noMatch).source,
	      (settings.evaluate || noMatch).source
	    ].join('|') + '|$', 'g');

	    // Compile the template source, escaping string literals appropriately.
	    var index = 0;
	    var source = "__p+='";
	    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
	      source += text.slice(index, offset).replace(escaper, escapeChar);
	      index = offset + match.length;

	      if (escape) {
	        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
	      } else if (interpolate) {
	        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
	      } else if (evaluate) {
	        source += "';\n" + evaluate + "\n__p+='";
	      }

	      // Adobe VMs need the match returned to produce the correct offest.
	      return match;
	    });
	    source += "';\n";

	    // If a variable is not specified, place data values in local scope.
	    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

	    source = "var __t,__p='',__j=Array.prototype.join," +
	      "print=function(){__p+=__j.call(arguments,'');};\n" +
	      source + 'return __p;\n';

	    try {
	      var render = new Function(settings.variable || 'obj', '_', source);
	    } catch (e) {
	      e.source = source;
	      throw e;
	    }

	    var template = function(data) {
	      return render.call(this, data, _);
	    };

	    // Provide the compiled source as a convenience for precompilation.
	    var argument = settings.variable || 'obj';
	    template.source = 'function(' + argument + '){\n' + source + '}';

	    return template;
	  };

	  // Add a "chain" function. Start chaining a wrapped Underscore object.
	  _.chain = function(obj) {
	    var instance = _(obj);
	    instance._chain = true;
	    return instance;
	  };

	  // OOP
	  // ---------------
	  // If Underscore is called as a function, it returns a wrapped object that
	  // can be used OO-style. This wrapper holds altered versions of all the
	  // underscore functions. Wrapped objects may be chained.

	  // Helper function to continue chaining intermediate results.
	  var result = function(instance, obj) {
	    return instance._chain ? _(obj).chain() : obj;
	  };

	  // Add your own custom functions to the Underscore object.
	  _.mixin = function(obj) {
	    _.each(_.functions(obj), function(name) {
	      var func = _[name] = obj[name];
	      _.prototype[name] = function() {
	        var args = [this._wrapped];
	        push.apply(args, arguments);
	        return result(this, func.apply(_, args));
	      };
	    });
	  };

	  // Add all of the Underscore functions to the wrapper object.
	  _.mixin(_);

	  // Add all mutator Array functions to the wrapper.
	  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      var obj = this._wrapped;
	      method.apply(obj, arguments);
	      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
	      return result(this, obj);
	    };
	  });

	  // Add all accessor Array functions to the wrapper.
	  _.each(['concat', 'join', 'slice'], function(name) {
	    var method = ArrayProto[name];
	    _.prototype[name] = function() {
	      return result(this, method.apply(this._wrapped, arguments));
	    };
	  });

	  // Extracts the result from a wrapped and chained object.
	  _.prototype.value = function() {
	    return this._wrapped;
	  };

	  // Provide unwrapping proxy for some methods used in engine operations
	  // such as arithmetic and JSON stringification.
	  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

	  _.prototype.toString = function() {
	    return '' + this._wrapped;
	  };

	  // AMD registration happens at the end for compatibility with AMD loaders
	  // that may not enforce next-turn semantics on modules. Even though general
	  // practice for AMD registration is to be anonymous, underscore registers
	  // as a named module because, like jQuery, it is a base library that is
	  // popular enough to be bundled in a third party lib, but not be part of
	  // an AMD load request. Those cases could generate an error when an
	  // anonymous define() is called outside of a loader request.
	  if (true) {
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
	      return _;
	    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  }
	}.call(this));


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(process, setImmediate) {// vim:ts=4:sts=4:sw=4:
	/*!
	 *
	 * Copyright 2009-2012 Kris Kowal under the terms of the MIT
	 * license found at http://github.com/kriskowal/q/raw/master/LICENSE
	 *
	 * With parts by Tyler Close
	 * Copyright 2007-2009 Tyler Close under the terms of the MIT X license found
	 * at http://www.opensource.org/licenses/mit-license.html
	 * Forked at ref_send.js version: 2009-05-11
	 *
	 * With parts by Mark Miller
	 * Copyright (C) 2011 Google Inc.
	 *
	 * Licensed under the Apache License, Version 2.0 (the "License");
	 * you may not use this file except in compliance with the License.
	 * You may obtain a copy of the License at
	 *
	 * http://www.apache.org/licenses/LICENSE-2.0
	 *
	 * Unless required by applicable law or agreed to in writing, software
	 * distributed under the License is distributed on an "AS IS" BASIS,
	 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
	 * See the License for the specific language governing permissions and
	 * limitations under the License.
	 *
	 */

	(function (definition) {
	    "use strict";

	    // This file will function properly as a <script> tag, or a module
	    // using CommonJS and NodeJS or RequireJS module formats.  In
	    // Common/Node/RequireJS, the module exports the Q API and when
	    // executed as a simple <script>, it creates a Q global instead.

	    // Montage Require
	    if (typeof bootstrap === "function") {
	        bootstrap("promise", definition);

	    // CommonJS
	    } else if (true) {
	        module.exports = definition();

	    // RequireJS
	    } else if (typeof define === "function" && define.amd) {
	        define(definition);

	    // SES (Secure EcmaScript)
	    } else if (typeof ses !== "undefined") {
	        if (!ses.ok()) {
	            return;
	        } else {
	            ses.makeQ = definition;
	        }

	    // <script>
	    } else if (typeof window !== "undefined" || typeof self !== "undefined") {
	        // Prefer window over self for add-on scripts. Use self for
	        // non-windowed contexts.
	        var global = typeof window !== "undefined" ? window : self;

	        // Get the `window` object, save the previous Q global
	        // and initialize Q as a global.
	        var previousQ = global.Q;
	        global.Q = definition();

	        // Add a noConflict function so Q can be removed from the
	        // global namespace.
	        global.Q.noConflict = function () {
	            global.Q = previousQ;
	            return this;
	        };

	    } else {
	        throw new Error("This environment was not anticipated by Q. Please file a bug.");
	    }

	})(function () {
	"use strict";

	var hasStacks = false;
	try {
	    throw new Error();
	} catch (e) {
	    hasStacks = !!e.stack;
	}

	// All code after this point will be filtered from stack traces reported
	// by Q.
	var qStartingLine = captureLine();
	var qFileName;

	// shims

	// used for fallback in "allResolved"
	var noop = function () {};

	// Use the fastest possible means to execute a task in a future turn
	// of the event loop.
	var nextTick =(function () {
	    // linked list of tasks (single, with head node)
	    var head = {task: void 0, next: null};
	    var tail = head;
	    var flushing = false;
	    var requestTick = void 0;
	    var isNodeJS = false;
	    // queue for late tasks, used by unhandled rejection tracking
	    var laterQueue = [];

	    function flush() {
	        /* jshint loopfunc: true */
	        var task, domain;

	        while (head.next) {
	            head = head.next;
	            task = head.task;
	            head.task = void 0;
	            domain = head.domain;

	            if (domain) {
	                head.domain = void 0;
	                domain.enter();
	            }
	            runSingle(task, domain);

	        }
	        while (laterQueue.length) {
	            task = laterQueue.pop();
	            runSingle(task);
	        }
	        flushing = false;
	    }
	    // runs a single function in the async queue
	    function runSingle(task, domain) {
	        try {
	            task();

	        } catch (e) {
	            if (isNodeJS) {
	                // In node, uncaught exceptions are considered fatal errors.
	                // Re-throw them synchronously to interrupt flushing!

	                // Ensure continuation if the uncaught exception is suppressed
	                // listening "uncaughtException" events (as domains does).
	                // Continue in next event to avoid tick recursion.
	                if (domain) {
	                    domain.exit();
	                }
	                setTimeout(flush, 0);
	                if (domain) {
	                    domain.enter();
	                }

	                throw e;

	            } else {
	                // In browsers, uncaught exceptions are not fatal.
	                // Re-throw them asynchronously to avoid slow-downs.
	                setTimeout(function () {
	                    throw e;
	                }, 0);
	            }
	        }

	        if (domain) {
	            domain.exit();
	        }
	    }

	    nextTick = function (task) {
	        tail = tail.next = {
	            task: task,
	            domain: isNodeJS && process.domain,
	            next: null
	        };

	        if (!flushing) {
	            flushing = true;
	            requestTick();
	        }
	    };

	    if (typeof process === "object" &&
	        process.toString() === "[object process]" && process.nextTick) {
	        // Ensure Q is in a real Node environment, with a `process.nextTick`.
	        // To see through fake Node environments:
	        // * Mocha test runner - exposes a `process` global without a `nextTick`
	        // * Browserify - exposes a `process.nexTick` function that uses
	        //   `setTimeout`. In this case `setImmediate` is preferred because
	        //    it is faster. Browserify's `process.toString()` yields
	        //   "[object Object]", while in a real Node environment
	        //   `process.nextTick()` yields "[object process]".
	        isNodeJS = true;

	        requestTick = function () {
	            process.nextTick(flush);
	        };

	    } else if (typeof setImmediate === "function") {
	        // In IE10, Node.js 0.9+, or https://github.com/NobleJS/setImmediate
	        if (typeof window !== "undefined") {
	            requestTick = setImmediate.bind(window, flush);
	        } else {
	            requestTick = function () {
	                setImmediate(flush);
	            };
	        }

	    } else if (typeof MessageChannel !== "undefined") {
	        // modern browsers
	        // http://www.nonblocking.io/2011/06/windownexttick.html
	        var channel = new MessageChannel();
	        // At least Safari Version 6.0.5 (8536.30.1) intermittently cannot create
	        // working message ports the first time a page loads.
	        channel.port1.onmessage = function () {
	            requestTick = requestPortTick;
	            channel.port1.onmessage = flush;
	            flush();
	        };
	        var requestPortTick = function () {
	            // Opera requires us to provide a message payload, regardless of
	            // whether we use it.
	            channel.port2.postMessage(0);
	        };
	        requestTick = function () {
	            setTimeout(flush, 0);
	            requestPortTick();
	        };

	    } else {
	        // old browsers
	        requestTick = function () {
	            setTimeout(flush, 0);
	        };
	    }
	    // runs a task after all other tasks have been run
	    // this is useful for unhandled rejection tracking that needs to happen
	    // after all `then`d tasks have been run.
	    nextTick.runAfter = function (task) {
	        laterQueue.push(task);
	        if (!flushing) {
	            flushing = true;
	            requestTick();
	        }
	    };
	    return nextTick;
	})();

	// Attempt to make generics safe in the face of downstream
	// modifications.
	// There is no situation where this is necessary.
	// If you need a security guarantee, these primordials need to be
	// deeply frozen anyway, and if you dont need a security guarantee,
	// this is just plain paranoid.
	// However, this **might** have the nice side-effect of reducing the size of
	// the minified code by reducing x.call() to merely x()
	// See Mark Millers explanation of what this does.
	// http://wiki.ecmascript.org/doku.php?id=conventions:safe_meta_programming
	var call = Function.call;
	function uncurryThis(f) {
	    return function () {
	        return call.apply(f, arguments);
	    };
	}
	// This is equivalent, but slower:
	// uncurryThis = Function_bind.bind(Function_bind.call);
	// http://jsperf.com/uncurrythis

	var array_slice = uncurryThis(Array.prototype.slice);

	var array_reduce = uncurryThis(
	    Array.prototype.reduce || function (callback, basis) {
	        var index = 0,
	            length = this.length;
	        // concerning the initial value, if one is not provided
	        if (arguments.length === 1) {
	            // seek to the first value in the array, accounting
	            // for the possibility that is is a sparse array
	            do {
	                if (index in this) {
	                    basis = this[index++];
	                    break;
	                }
	                if (++index >= length) {
	                    throw new TypeError();
	                }
	            } while (1);
	        }
	        // reduce
	        for (; index < length; index++) {
	            // account for the possibility that the array is sparse
	            if (index in this) {
	                basis = callback(basis, this[index], index);
	            }
	        }
	        return basis;
	    }
	);

	var array_indexOf = uncurryThis(
	    Array.prototype.indexOf || function (value) {
	        // not a very good shim, but good enough for our one use of it
	        for (var i = 0; i < this.length; i++) {
	            if (this[i] === value) {
	                return i;
	            }
	        }
	        return -1;
	    }
	);

	var array_map = uncurryThis(
	    Array.prototype.map || function (callback, thisp) {
	        var self = this;
	        var collect = [];
	        array_reduce(self, function (undefined, value, index) {
	            collect.push(callback.call(thisp, value, index, self));
	        }, void 0);
	        return collect;
	    }
	);

	var object_create = Object.create || function (prototype) {
	    function Type() { }
	    Type.prototype = prototype;
	    return new Type();
	};

	var object_hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);

	var object_keys = Object.keys || function (object) {
	    var keys = [];
	    for (var key in object) {
	        if (object_hasOwnProperty(object, key)) {
	            keys.push(key);
	        }
	    }
	    return keys;
	};

	var object_toString = uncurryThis(Object.prototype.toString);

	function isObject(value) {
	    return value === Object(value);
	}

	// generator related shims

	// FIXME: Remove this function once ES6 generators are in SpiderMonkey.
	function isStopIteration(exception) {
	    return (
	        object_toString(exception) === "[object StopIteration]" ||
	        exception instanceof QReturnValue
	    );
	}

	// FIXME: Remove this helper and Q.return once ES6 generators are in
	// SpiderMonkey.
	var QReturnValue;
	if (typeof ReturnValue !== "undefined") {
	    QReturnValue = ReturnValue;
	} else {
	    QReturnValue = function (value) {
	        this.value = value;
	    };
	}

	// long stack traces

	var STACK_JUMP_SEPARATOR = "From previous event:";

	function makeStackTraceLong(error, promise) {
	    // If possible, transform the error stack trace by removing Node and Q
	    // cruft, then concatenating with the stack trace of `promise`. See #57.
	    if (hasStacks &&
	        promise.stack &&
	        typeof error === "object" &&
	        error !== null &&
	        error.stack &&
	        error.stack.indexOf(STACK_JUMP_SEPARATOR) === -1
	    ) {
	        var stacks = [];
	        for (var p = promise; !!p; p = p.source) {
	            if (p.stack) {
	                stacks.unshift(p.stack);
	            }
	        }
	        stacks.unshift(error.stack);

	        var concatedStacks = stacks.join("\n" + STACK_JUMP_SEPARATOR + "\n");
	        error.stack = filterStackString(concatedStacks);
	    }
	}

	function filterStackString(stackString) {
	    var lines = stackString.split("\n");
	    var desiredLines = [];
	    for (var i = 0; i < lines.length; ++i) {
	        var line = lines[i];

	        if (!isInternalFrame(line) && !isNodeFrame(line) && line) {
	            desiredLines.push(line);
	        }
	    }
	    return desiredLines.join("\n");
	}

	function isNodeFrame(stackLine) {
	    return stackLine.indexOf("(module.js:") !== -1 ||
	           stackLine.indexOf("(node.js:") !== -1;
	}

	function getFileNameAndLineNumber(stackLine) {
	    // Named functions: "at functionName (filename:lineNumber:columnNumber)"
	    // In IE10 function name can have spaces ("Anonymous function") O_o
	    var attempt1 = /at .+ \((.+):(\d+):(?:\d+)\)$/.exec(stackLine);
	    if (attempt1) {
	        return [attempt1[1], Number(attempt1[2])];
	    }

	    // Anonymous functions: "at filename:lineNumber:columnNumber"
	    var attempt2 = /at ([^ ]+):(\d+):(?:\d+)$/.exec(stackLine);
	    if (attempt2) {
	        return [attempt2[1], Number(attempt2[2])];
	    }

	    // Firefox style: "function@filename:lineNumber or @filename:lineNumber"
	    var attempt3 = /.*@(.+):(\d+)$/.exec(stackLine);
	    if (attempt3) {
	        return [attempt3[1], Number(attempt3[2])];
	    }
	}

	function isInternalFrame(stackLine) {
	    var fileNameAndLineNumber = getFileNameAndLineNumber(stackLine);

	    if (!fileNameAndLineNumber) {
	        return false;
	    }

	    var fileName = fileNameAndLineNumber[0];
	    var lineNumber = fileNameAndLineNumber[1];

	    return fileName === qFileName &&
	        lineNumber >= qStartingLine &&
	        lineNumber <= qEndingLine;
	}

	// discover own file name and line number range for filtering stack
	// traces
	function captureLine() {
	    if (!hasStacks) {
	        return;
	    }

	    try {
	        throw new Error();
	    } catch (e) {
	        var lines = e.stack.split("\n");
	        var firstLine = lines[0].indexOf("@") > 0 ? lines[1] : lines[2];
	        var fileNameAndLineNumber = getFileNameAndLineNumber(firstLine);
	        if (!fileNameAndLineNumber) {
	            return;
	        }

	        qFileName = fileNameAndLineNumber[0];
	        return fileNameAndLineNumber[1];
	    }
	}

	function deprecate(callback, name, alternative) {
	    return function () {
	        if (typeof console !== "undefined" &&
	            typeof console.warn === "function") {
	            console.warn(name + " is deprecated, use " + alternative +
	                         " instead.", new Error("").stack);
	        }
	        return callback.apply(callback, arguments);
	    };
	}

	// end of shims
	// beginning of real work

	/**
	 * Constructs a promise for an immediate reference, passes promises through, or
	 * coerces promises from different systems.
	 * @param value immediate reference or promise
	 */
	function Q(value) {
	    // If the object is already a Promise, return it directly.  This enables
	    // the resolve function to both be used to created references from objects,
	    // but to tolerably coerce non-promises to promises.
	    if (value instanceof Promise) {
	        return value;
	    }

	    // assimilate thenables
	    if (isPromiseAlike(value)) {
	        return coerce(value);
	    } else {
	        return fulfill(value);
	    }
	}
	Q.resolve = Q;

	/**
	 * Performs a task in a future turn of the event loop.
	 * @param {Function} task
	 */
	Q.nextTick = nextTick;

	/**
	 * Controls whether or not long stack traces will be on
	 */
	Q.longStackSupport = false;

	// enable long stacks if Q_DEBUG is set
	if (typeof process === "object" && process && process.env && process.env.Q_DEBUG) {
	    Q.longStackSupport = true;
	}

	/**
	 * Constructs a {promise, resolve, reject} object.
	 *
	 * `resolve` is a callback to invoke with a more resolved value for the
	 * promise. To fulfill the promise, invoke `resolve` with any value that is
	 * not a thenable. To reject the promise, invoke `resolve` with a rejected
	 * thenable, or invoke `reject` with the reason directly. To resolve the
	 * promise to another thenable, thus putting it in the same state, invoke
	 * `resolve` with that other thenable.
	 */
	Q.defer = defer;
	function defer() {
	    // if "messages" is an "Array", that indicates that the promise has not yet
	    // been resolved.  If it is "undefined", it has been resolved.  Each
	    // element of the messages array is itself an array of complete arguments to
	    // forward to the resolved promise.  We coerce the resolution value to a
	    // promise using the `resolve` function because it handles both fully
	    // non-thenable values and other thenables gracefully.
	    var messages = [], progressListeners = [], resolvedPromise;

	    var deferred = object_create(defer.prototype);
	    var promise = object_create(Promise.prototype);

	    promise.promiseDispatch = function (resolve, op, operands) {
	        var args = array_slice(arguments);
	        if (messages) {
	            messages.push(args);
	            if (op === "when" && operands[1]) { // progress operand
	                progressListeners.push(operands[1]);
	            }
	        } else {
	            Q.nextTick(function () {
	                resolvedPromise.promiseDispatch.apply(resolvedPromise, args);
	            });
	        }
	    };

	    // XXX deprecated
	    promise.valueOf = function () {
	        if (messages) {
	            return promise;
	        }
	        var nearerValue = nearer(resolvedPromise);
	        if (isPromise(nearerValue)) {
	            resolvedPromise = nearerValue; // shorten chain
	        }
	        return nearerValue;
	    };

	    promise.inspect = function () {
	        if (!resolvedPromise) {
	            return { state: "pending" };
	        }
	        return resolvedPromise.inspect();
	    };

	    if (Q.longStackSupport && hasStacks) {
	        try {
	            throw new Error();
	        } catch (e) {
	            // NOTE: don't try to use `Error.captureStackTrace` or transfer the
	            // accessor around; that causes memory leaks as per GH-111. Just
	            // reify the stack trace as a string ASAP.
	            //
	            // At the same time, cut off the first line; it's always just
	            // "[object Promise]\n", as per the `toString`.
	            promise.stack = e.stack.substring(e.stack.indexOf("\n") + 1);
	        }
	    }

	    // NOTE: we do the checks for `resolvedPromise` in each method, instead of
	    // consolidating them into `become`, since otherwise we'd create new
	    // promises with the lines `become(whatever(value))`. See e.g. GH-252.

	    function become(newPromise) {
	        resolvedPromise = newPromise;
	        promise.source = newPromise;

	        array_reduce(messages, function (undefined, message) {
	            Q.nextTick(function () {
	                newPromise.promiseDispatch.apply(newPromise, message);
	            });
	        }, void 0);

	        messages = void 0;
	        progressListeners = void 0;
	    }

	    deferred.promise = promise;
	    deferred.resolve = function (value) {
	        if (resolvedPromise) {
	            return;
	        }

	        become(Q(value));
	    };

	    deferred.fulfill = function (value) {
	        if (resolvedPromise) {
	            return;
	        }

	        become(fulfill(value));
	    };
	    deferred.reject = function (reason) {
	        if (resolvedPromise) {
	            return;
	        }

	        become(reject(reason));
	    };
	    deferred.notify = function (progress) {
	        if (resolvedPromise) {
	            return;
	        }

	        array_reduce(progressListeners, function (undefined, progressListener) {
	            Q.nextTick(function () {
	                progressListener(progress);
	            });
	        }, void 0);
	    };

	    return deferred;
	}

	/**
	 * Creates a Node-style callback that will resolve or reject the deferred
	 * promise.
	 * @returns a nodeback
	 */
	defer.prototype.makeNodeResolver = function () {
	    var self = this;
	    return function (error, value) {
	        if (error) {
	            self.reject(error);
	        } else if (arguments.length > 2) {
	            self.resolve(array_slice(arguments, 1));
	        } else {
	            self.resolve(value);
	        }
	    };
	};

	/**
	 * @param resolver {Function} a function that returns nothing and accepts
	 * the resolve, reject, and notify functions for a deferred.
	 * @returns a promise that may be resolved with the given resolve and reject
	 * functions, or rejected by a thrown exception in resolver
	 */
	Q.Promise = promise; // ES6
	Q.promise = promise;
	function promise(resolver) {
	    if (typeof resolver !== "function") {
	        throw new TypeError("resolver must be a function.");
	    }
	    var deferred = defer();
	    try {
	        resolver(deferred.resolve, deferred.reject, deferred.notify);
	    } catch (reason) {
	        deferred.reject(reason);
	    }
	    return deferred.promise;
	}

	promise.race = race; // ES6
	promise.all = all; // ES6
	promise.reject = reject; // ES6
	promise.resolve = Q; // ES6

	// XXX experimental.  This method is a way to denote that a local value is
	// serializable and should be immediately dispatched to a remote upon request,
	// instead of passing a reference.
	Q.passByCopy = function (object) {
	    //freeze(object);
	    //passByCopies.set(object, true);
	    return object;
	};

	Promise.prototype.passByCopy = function () {
	    //freeze(object);
	    //passByCopies.set(object, true);
	    return this;
	};

	/**
	 * If two promises eventually fulfill to the same value, promises that value,
	 * but otherwise rejects.
	 * @param x {Any*}
	 * @param y {Any*}
	 * @returns {Any*} a promise for x and y if they are the same, but a rejection
	 * otherwise.
	 *
	 */
	Q.join = function (x, y) {
	    return Q(x).join(y);
	};

	Promise.prototype.join = function (that) {
	    return Q([this, that]).spread(function (x, y) {
	        if (x === y) {
	            // TODO: "===" should be Object.is or equiv
	            return x;
	        } else {
	            throw new Error("Can't join: not the same: " + x + " " + y);
	        }
	    });
	};

	/**
	 * Returns a promise for the first of an array of promises to become settled.
	 * @param answers {Array[Any*]} promises to race
	 * @returns {Any*} the first promise to be settled
	 */
	Q.race = race;
	function race(answerPs) {
	    return promise(function (resolve, reject) {
	        // Switch to this once we can assume at least ES5
	        // answerPs.forEach(function (answerP) {
	        //     Q(answerP).then(resolve, reject);
	        // });
	        // Use this in the meantime
	        for (var i = 0, len = answerPs.length; i < len; i++) {
	            Q(answerPs[i]).then(resolve, reject);
	        }
	    });
	}

	Promise.prototype.race = function () {
	    return this.then(Q.race);
	};

	/**
	 * Constructs a Promise with a promise descriptor object and optional fallback
	 * function.  The descriptor contains methods like when(rejected), get(name),
	 * set(name, value), post(name, args), and delete(name), which all
	 * return either a value, a promise for a value, or a rejection.  The fallback
	 * accepts the operation name, a resolver, and any further arguments that would
	 * have been forwarded to the appropriate method above had a method been
	 * provided with the proper name.  The API makes no guarantees about the nature
	 * of the returned object, apart from that it is usable whereever promises are
	 * bought and sold.
	 */
	Q.makePromise = Promise;
	function Promise(descriptor, fallback, inspect) {
	    if (fallback === void 0) {
	        fallback = function (op) {
	            return reject(new Error(
	                "Promise does not support operation: " + op
	            ));
	        };
	    }
	    if (inspect === void 0) {
	        inspect = function () {
	            return {state: "unknown"};
	        };
	    }

	    var promise = object_create(Promise.prototype);

	    promise.promiseDispatch = function (resolve, op, args) {
	        var result;
	        try {
	            if (descriptor[op]) {
	                result = descriptor[op].apply(promise, args);
	            } else {
	                result = fallback.call(promise, op, args);
	            }
	        } catch (exception) {
	            result = reject(exception);
	        }
	        if (resolve) {
	            resolve(result);
	        }
	    };

	    promise.inspect = inspect;

	    // XXX deprecated `valueOf` and `exception` support
	    if (inspect) {
	        var inspected = inspect();
	        if (inspected.state === "rejected") {
	            promise.exception = inspected.reason;
	        }

	        promise.valueOf = function () {
	            var inspected = inspect();
	            if (inspected.state === "pending" ||
	                inspected.state === "rejected") {
	                return promise;
	            }
	            return inspected.value;
	        };
	    }

	    return promise;
	}

	Promise.prototype.toString = function () {
	    return "[object Promise]";
	};

	Promise.prototype.then = function (fulfilled, rejected, progressed) {
	    var self = this;
	    var deferred = defer();
	    var done = false;   // ensure the untrusted promise makes at most a
	                        // single call to one of the callbacks

	    function _fulfilled(value) {
	        try {
	            return typeof fulfilled === "function" ? fulfilled(value) : value;
	        } catch (exception) {
	            return reject(exception);
	        }
	    }

	    function _rejected(exception) {
	        if (typeof rejected === "function") {
	            makeStackTraceLong(exception, self);
	            try {
	                return rejected(exception);
	            } catch (newException) {
	                return reject(newException);
	            }
	        }
	        return reject(exception);
	    }

	    function _progressed(value) {
	        return typeof progressed === "function" ? progressed(value) : value;
	    }

	    Q.nextTick(function () {
	        self.promiseDispatch(function (value) {
	            if (done) {
	                return;
	            }
	            done = true;

	            deferred.resolve(_fulfilled(value));
	        }, "when", [function (exception) {
	            if (done) {
	                return;
	            }
	            done = true;

	            deferred.resolve(_rejected(exception));
	        }]);
	    });

	    // Progress propagator need to be attached in the current tick.
	    self.promiseDispatch(void 0, "when", [void 0, function (value) {
	        var newValue;
	        var threw = false;
	        try {
	            newValue = _progressed(value);
	        } catch (e) {
	            threw = true;
	            if (Q.onerror) {
	                Q.onerror(e);
	            } else {
	                throw e;
	            }
	        }

	        if (!threw) {
	            deferred.notify(newValue);
	        }
	    }]);

	    return deferred.promise;
	};

	Q.tap = function (promise, callback) {
	    return Q(promise).tap(callback);
	};

	/**
	 * Works almost like "finally", but not called for rejections.
	 * Original resolution value is passed through callback unaffected.
	 * Callback may return a promise that will be awaited for.
	 * @param {Function} callback
	 * @returns {Q.Promise}
	 * @example
	 * doSomething()
	 *   .then(...)
	 *   .tap(console.log)
	 *   .then(...);
	 */
	Promise.prototype.tap = function (callback) {
	    callback = Q(callback);

	    return this.then(function (value) {
	        return callback.fcall(value).thenResolve(value);
	    });
	};

	/**
	 * Registers an observer on a promise.
	 *
	 * Guarantees:
	 *
	 * 1. that fulfilled and rejected will be called only once.
	 * 2. that either the fulfilled callback or the rejected callback will be
	 *    called, but not both.
	 * 3. that fulfilled and rejected will not be called in this turn.
	 *
	 * @param value      promise or immediate reference to observe
	 * @param fulfilled  function to be called with the fulfilled value
	 * @param rejected   function to be called with the rejection exception
	 * @param progressed function to be called on any progress notifications
	 * @return promise for the return value from the invoked callback
	 */
	Q.when = when;
	function when(value, fulfilled, rejected, progressed) {
	    return Q(value).then(fulfilled, rejected, progressed);
	}

	Promise.prototype.thenResolve = function (value) {
	    return this.then(function () { return value; });
	};

	Q.thenResolve = function (promise, value) {
	    return Q(promise).thenResolve(value);
	};

	Promise.prototype.thenReject = function (reason) {
	    return this.then(function () { throw reason; });
	};

	Q.thenReject = function (promise, reason) {
	    return Q(promise).thenReject(reason);
	};

	/**
	 * If an object is not a promise, it is as "near" as possible.
	 * If a promise is rejected, it is as "near" as possible too.
	 * If its a fulfilled promise, the fulfillment value is nearer.
	 * If its a deferred promise and the deferred has been resolved, the
	 * resolution is "nearer".
	 * @param object
	 * @returns most resolved (nearest) form of the object
	 */

	// XXX should we re-do this?
	Q.nearer = nearer;
	function nearer(value) {
	    if (isPromise(value)) {
	        var inspected = value.inspect();
	        if (inspected.state === "fulfilled") {
	            return inspected.value;
	        }
	    }
	    return value;
	}

	/**
	 * @returns whether the given object is a promise.
	 * Otherwise it is a fulfilled value.
	 */
	Q.isPromise = isPromise;
	function isPromise(object) {
	    return object instanceof Promise;
	}

	Q.isPromiseAlike = isPromiseAlike;
	function isPromiseAlike(object) {
	    return isObject(object) && typeof object.then === "function";
	}

	/**
	 * @returns whether the given object is a pending promise, meaning not
	 * fulfilled or rejected.
	 */
	Q.isPending = isPending;
	function isPending(object) {
	    return isPromise(object) && object.inspect().state === "pending";
	}

	Promise.prototype.isPending = function () {
	    return this.inspect().state === "pending";
	};

	/**
	 * @returns whether the given object is a value or fulfilled
	 * promise.
	 */
	Q.isFulfilled = isFulfilled;
	function isFulfilled(object) {
	    return !isPromise(object) || object.inspect().state === "fulfilled";
	}

	Promise.prototype.isFulfilled = function () {
	    return this.inspect().state === "fulfilled";
	};

	/**
	 * @returns whether the given object is a rejected promise.
	 */
	Q.isRejected = isRejected;
	function isRejected(object) {
	    return isPromise(object) && object.inspect().state === "rejected";
	}

	Promise.prototype.isRejected = function () {
	    return this.inspect().state === "rejected";
	};

	//// BEGIN UNHANDLED REJECTION TRACKING

	// This promise library consumes exceptions thrown in handlers so they can be
	// handled by a subsequent promise.  The exceptions get added to this array when
	// they are created, and removed when they are handled.  Note that in ES6 or
	// shimmed environments, this would naturally be a `Set`.
	var unhandledReasons = [];
	var unhandledRejections = [];
	var reportedUnhandledRejections = [];
	var trackUnhandledRejections = true;

	function resetUnhandledRejections() {
	    unhandledReasons.length = 0;
	    unhandledRejections.length = 0;

	    if (!trackUnhandledRejections) {
	        trackUnhandledRejections = true;
	    }
	}

	function trackRejection(promise, reason) {
	    if (!trackUnhandledRejections) {
	        return;
	    }
	    if (typeof process === "object" && typeof process.emit === "function") {
	        Q.nextTick.runAfter(function () {
	            if (array_indexOf(unhandledRejections, promise) !== -1) {
	                process.emit("unhandledRejection", reason, promise);
	                reportedUnhandledRejections.push(promise);
	            }
	        });
	    }

	    unhandledRejections.push(promise);
	    if (reason && typeof reason.stack !== "undefined") {
	        unhandledReasons.push(reason.stack);
	    } else {
	        unhandledReasons.push("(no stack) " + reason);
	    }
	}

	function untrackRejection(promise) {
	    if (!trackUnhandledRejections) {
	        return;
	    }

	    var at = array_indexOf(unhandledRejections, promise);
	    if (at !== -1) {
	        if (typeof process === "object" && typeof process.emit === "function") {
	            Q.nextTick.runAfter(function () {
	                var atReport = array_indexOf(reportedUnhandledRejections, promise);
	                if (atReport !== -1) {
	                    process.emit("rejectionHandled", unhandledReasons[at], promise);
	                    reportedUnhandledRejections.splice(atReport, 1);
	                }
	            });
	        }
	        unhandledRejections.splice(at, 1);
	        unhandledReasons.splice(at, 1);
	    }
	}

	Q.resetUnhandledRejections = resetUnhandledRejections;

	Q.getUnhandledReasons = function () {
	    // Make a copy so that consumers can't interfere with our internal state.
	    return unhandledReasons.slice();
	};

	Q.stopUnhandledRejectionTracking = function () {
	    resetUnhandledRejections();
	    trackUnhandledRejections = false;
	};

	resetUnhandledRejections();

	//// END UNHANDLED REJECTION TRACKING

	/**
	 * Constructs a rejected promise.
	 * @param reason value describing the failure
	 */
	Q.reject = reject;
	function reject(reason) {
	    var rejection = Promise({
	        "when": function (rejected) {
	            // note that the error has been handled
	            if (rejected) {
	                untrackRejection(this);
	            }
	            return rejected ? rejected(reason) : this;
	        }
	    }, function fallback() {
	        return this;
	    }, function inspect() {
	        return { state: "rejected", reason: reason };
	    });

	    // Note that the reason has not been handled.
	    trackRejection(rejection, reason);

	    return rejection;
	}

	/**
	 * Constructs a fulfilled promise for an immediate reference.
	 * @param value immediate reference
	 */
	Q.fulfill = fulfill;
	function fulfill(value) {
	    return Promise({
	        "when": function () {
	            return value;
	        },
	        "get": function (name) {
	            return value[name];
	        },
	        "set": function (name, rhs) {
	            value[name] = rhs;
	        },
	        "delete": function (name) {
	            delete value[name];
	        },
	        "post": function (name, args) {
	            // Mark Miller proposes that post with no name should apply a
	            // promised function.
	            if (name === null || name === void 0) {
	                return value.apply(void 0, args);
	            } else {
	                return value[name].apply(value, args);
	            }
	        },
	        "apply": function (thisp, args) {
	            return value.apply(thisp, args);
	        },
	        "keys": function () {
	            return object_keys(value);
	        }
	    }, void 0, function inspect() {
	        return { state: "fulfilled", value: value };
	    });
	}

	/**
	 * Converts thenables to Q promises.
	 * @param promise thenable promise
	 * @returns a Q promise
	 */
	function coerce(promise) {
	    var deferred = defer();
	    Q.nextTick(function () {
	        try {
	            promise.then(deferred.resolve, deferred.reject, deferred.notify);
	        } catch (exception) {
	            deferred.reject(exception);
	        }
	    });
	    return deferred.promise;
	}

	/**
	 * Annotates an object such that it will never be
	 * transferred away from this process over any promise
	 * communication channel.
	 * @param object
	 * @returns promise a wrapping of that object that
	 * additionally responds to the "isDef" message
	 * without a rejection.
	 */
	Q.master = master;
	function master(object) {
	    return Promise({
	        "isDef": function () {}
	    }, function fallback(op, args) {
	        return dispatch(object, op, args);
	    }, function () {
	        return Q(object).inspect();
	    });
	}

	/**
	 * Spreads the values of a promised array of arguments into the
	 * fulfillment callback.
	 * @param fulfilled callback that receives variadic arguments from the
	 * promised array
	 * @param rejected callback that receives the exception if the promise
	 * is rejected.
	 * @returns a promise for the return value or thrown exception of
	 * either callback.
	 */
	Q.spread = spread;
	function spread(value, fulfilled, rejected) {
	    return Q(value).spread(fulfilled, rejected);
	}

	Promise.prototype.spread = function (fulfilled, rejected) {
	    return this.all().then(function (array) {
	        return fulfilled.apply(void 0, array);
	    }, rejected);
	};

	/**
	 * The async function is a decorator for generator functions, turning
	 * them into asynchronous generators.  Although generators are only part
	 * of the newest ECMAScript 6 drafts, this code does not cause syntax
	 * errors in older engines.  This code should continue to work and will
	 * in fact improve over time as the language improves.
	 *
	 * ES6 generators are currently part of V8 version 3.19 with the
	 * --harmony-generators runtime flag enabled.  SpiderMonkey has had them
	 * for longer, but under an older Python-inspired form.  This function
	 * works on both kinds of generators.
	 *
	 * Decorates a generator function such that:
	 *  - it may yield promises
	 *  - execution will continue when that promise is fulfilled
	 *  - the value of the yield expression will be the fulfilled value
	 *  - it returns a promise for the return value (when the generator
	 *    stops iterating)
	 *  - the decorated function returns a promise for the return value
	 *    of the generator or the first rejected promise among those
	 *    yielded.
	 *  - if an error is thrown in the generator, it propagates through
	 *    every following yield until it is caught, or until it escapes
	 *    the generator function altogether, and is translated into a
	 *    rejection for the promise returned by the decorated generator.
	 */
	Q.async = async;
	function async(makeGenerator) {
	    return function () {
	        // when verb is "send", arg is a value
	        // when verb is "throw", arg is an exception
	        function continuer(verb, arg) {
	            var result;

	            // Until V8 3.19 / Chromium 29 is released, SpiderMonkey is the only
	            // engine that has a deployed base of browsers that support generators.
	            // However, SM's generators use the Python-inspired semantics of
	            // outdated ES6 drafts.  We would like to support ES6, but we'd also
	            // like to make it possible to use generators in deployed browsers, so
	            // we also support Python-style generators.  At some point we can remove
	            // this block.

	            if (typeof StopIteration === "undefined") {
	                // ES6 Generators
	                try {
	                    result = generator[verb](arg);
	                } catch (exception) {
	                    return reject(exception);
	                }
	                if (result.done) {
	                    return Q(result.value);
	                } else {
	                    return when(result.value, callback, errback);
	                }
	            } else {
	                // SpiderMonkey Generators
	                // FIXME: Remove this case when SM does ES6 generators.
	                try {
	                    result = generator[verb](arg);
	                } catch (exception) {
	                    if (isStopIteration(exception)) {
	                        return Q(exception.value);
	                    } else {
	                        return reject(exception);
	                    }
	                }
	                return when(result, callback, errback);
	            }
	        }
	        var generator = makeGenerator.apply(this, arguments);
	        var callback = continuer.bind(continuer, "next");
	        var errback = continuer.bind(continuer, "throw");
	        return callback();
	    };
	}

	/**
	 * The spawn function is a small wrapper around async that immediately
	 * calls the generator and also ends the promise chain, so that any
	 * unhandled errors are thrown instead of forwarded to the error
	 * handler. This is useful because it's extremely common to run
	 * generators at the top-level to work with libraries.
	 */
	Q.spawn = spawn;
	function spawn(makeGenerator) {
	    Q.done(Q.async(makeGenerator)());
	}

	// FIXME: Remove this interface once ES6 generators are in SpiderMonkey.
	/**
	 * Throws a ReturnValue exception to stop an asynchronous generator.
	 *
	 * This interface is a stop-gap measure to support generator return
	 * values in older Firefox/SpiderMonkey.  In browsers that support ES6
	 * generators like Chromium 29, just use "return" in your generator
	 * functions.
	 *
	 * @param value the return value for the surrounding generator
	 * @throws ReturnValue exception with the value.
	 * @example
	 * // ES6 style
	 * Q.async(function* () {
	 *      var foo = yield getFooPromise();
	 *      var bar = yield getBarPromise();
	 *      return foo + bar;
	 * })
	 * // Older SpiderMonkey style
	 * Q.async(function () {
	 *      var foo = yield getFooPromise();
	 *      var bar = yield getBarPromise();
	 *      Q.return(foo + bar);
	 * })
	 */
	Q["return"] = _return;
	function _return(value) {
	    throw new QReturnValue(value);
	}

	/**
	 * The promised function decorator ensures that any promise arguments
	 * are settled and passed as values (`this` is also settled and passed
	 * as a value).  It will also ensure that the result of a function is
	 * always a promise.
	 *
	 * @example
	 * var add = Q.promised(function (a, b) {
	 *     return a + b;
	 * });
	 * add(Q(a), Q(B));
	 *
	 * @param {function} callback The function to decorate
	 * @returns {function} a function that has been decorated.
	 */
	Q.promised = promised;
	function promised(callback) {
	    return function () {
	        return spread([this, all(arguments)], function (self, args) {
	            return callback.apply(self, args);
	        });
	    };
	}

	/**
	 * sends a message to a value in a future turn
	 * @param object* the recipient
	 * @param op the name of the message operation, e.g., "when",
	 * @param args further arguments to be forwarded to the operation
	 * @returns result {Promise} a promise for the result of the operation
	 */
	Q.dispatch = dispatch;
	function dispatch(object, op, args) {
	    return Q(object).dispatch(op, args);
	}

	Promise.prototype.dispatch = function (op, args) {
	    var self = this;
	    var deferred = defer();
	    Q.nextTick(function () {
	        self.promiseDispatch(deferred.resolve, op, args);
	    });
	    return deferred.promise;
	};

	/**
	 * Gets the value of a property in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of property to get
	 * @return promise for the property value
	 */
	Q.get = function (object, key) {
	    return Q(object).dispatch("get", [key]);
	};

	Promise.prototype.get = function (key) {
	    return this.dispatch("get", [key]);
	};

	/**
	 * Sets the value of a property in a future turn.
	 * @param object    promise or immediate reference for object object
	 * @param name      name of property to set
	 * @param value     new value of property
	 * @return promise for the return value
	 */
	Q.set = function (object, key, value) {
	    return Q(object).dispatch("set", [key, value]);
	};

	Promise.prototype.set = function (key, value) {
	    return this.dispatch("set", [key, value]);
	};

	/**
	 * Deletes a property in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of property to delete
	 * @return promise for the return value
	 */
	Q.del = // XXX legacy
	Q["delete"] = function (object, key) {
	    return Q(object).dispatch("delete", [key]);
	};

	Promise.prototype.del = // XXX legacy
	Promise.prototype["delete"] = function (key) {
	    return this.dispatch("delete", [key]);
	};

	/**
	 * Invokes a method in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of method to invoke
	 * @param value     a value to post, typically an array of
	 *                  invocation arguments for promises that
	 *                  are ultimately backed with `resolve` values,
	 *                  as opposed to those backed with URLs
	 *                  wherein the posted value can be any
	 *                  JSON serializable object.
	 * @return promise for the return value
	 */
	// bound locally because it is used by other methods
	Q.mapply = // XXX As proposed by "Redsandro"
	Q.post = function (object, name, args) {
	    return Q(object).dispatch("post", [name, args]);
	};

	Promise.prototype.mapply = // XXX As proposed by "Redsandro"
	Promise.prototype.post = function (name, args) {
	    return this.dispatch("post", [name, args]);
	};

	/**
	 * Invokes a method in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @param name      name of method to invoke
	 * @param ...args   array of invocation arguments
	 * @return promise for the return value
	 */
	Q.send = // XXX Mark Miller's proposed parlance
	Q.mcall = // XXX As proposed by "Redsandro"
	Q.invoke = function (object, name /*...args*/) {
	    return Q(object).dispatch("post", [name, array_slice(arguments, 2)]);
	};

	Promise.prototype.send = // XXX Mark Miller's proposed parlance
	Promise.prototype.mcall = // XXX As proposed by "Redsandro"
	Promise.prototype.invoke = function (name /*...args*/) {
	    return this.dispatch("post", [name, array_slice(arguments, 1)]);
	};

	/**
	 * Applies the promised function in a future turn.
	 * @param object    promise or immediate reference for target function
	 * @param args      array of application arguments
	 */
	Q.fapply = function (object, args) {
	    return Q(object).dispatch("apply", [void 0, args]);
	};

	Promise.prototype.fapply = function (args) {
	    return this.dispatch("apply", [void 0, args]);
	};

	/**
	 * Calls the promised function in a future turn.
	 * @param object    promise or immediate reference for target function
	 * @param ...args   array of application arguments
	 */
	Q["try"] =
	Q.fcall = function (object /* ...args*/) {
	    return Q(object).dispatch("apply", [void 0, array_slice(arguments, 1)]);
	};

	Promise.prototype.fcall = function (/*...args*/) {
	    return this.dispatch("apply", [void 0, array_slice(arguments)]);
	};

	/**
	 * Binds the promised function, transforming return values into a fulfilled
	 * promise and thrown errors into a rejected one.
	 * @param object    promise or immediate reference for target function
	 * @param ...args   array of application arguments
	 */
	Q.fbind = function (object /*...args*/) {
	    var promise = Q(object);
	    var args = array_slice(arguments, 1);
	    return function fbound() {
	        return promise.dispatch("apply", [
	            this,
	            args.concat(array_slice(arguments))
	        ]);
	    };
	};
	Promise.prototype.fbind = function (/*...args*/) {
	    var promise = this;
	    var args = array_slice(arguments);
	    return function fbound() {
	        return promise.dispatch("apply", [
	            this,
	            args.concat(array_slice(arguments))
	        ]);
	    };
	};

	/**
	 * Requests the names of the owned properties of a promised
	 * object in a future turn.
	 * @param object    promise or immediate reference for target object
	 * @return promise for the keys of the eventually settled object
	 */
	Q.keys = function (object) {
	    return Q(object).dispatch("keys", []);
	};

	Promise.prototype.keys = function () {
	    return this.dispatch("keys", []);
	};

	/**
	 * Turns an array of promises into a promise for an array.  If any of
	 * the promises gets rejected, the whole array is rejected immediately.
	 * @param {Array*} an array (or promise for an array) of values (or
	 * promises for values)
	 * @returns a promise for an array of the corresponding values
	 */
	// By Mark Miller
	// http://wiki.ecmascript.org/doku.php?id=strawman:concurrency&rev=1308776521#allfulfilled
	Q.all = all;
	function all(promises) {
	    return when(promises, function (promises) {
	        var pendingCount = 0;
	        var deferred = defer();
	        array_reduce(promises, function (undefined, promise, index) {
	            var snapshot;
	            if (
	                isPromise(promise) &&
	                (snapshot = promise.inspect()).state === "fulfilled"
	            ) {
	                promises[index] = snapshot.value;
	            } else {
	                ++pendingCount;
	                when(
	                    promise,
	                    function (value) {
	                        promises[index] = value;
	                        if (--pendingCount === 0) {
	                            deferred.resolve(promises);
	                        }
	                    },
	                    deferred.reject,
	                    function (progress) {
	                        deferred.notify({ index: index, value: progress });
	                    }
	                );
	            }
	        }, void 0);
	        if (pendingCount === 0) {
	            deferred.resolve(promises);
	        }
	        return deferred.promise;
	    });
	}

	Promise.prototype.all = function () {
	    return all(this);
	};

	/**
	 * Returns the first resolved promise of an array. Prior rejected promises are
	 * ignored.  Rejects only if all promises are rejected.
	 * @param {Array*} an array containing values or promises for values
	 * @returns a promise fulfilled with the value of the first resolved promise,
	 * or a rejected promise if all promises are rejected.
	 */
	Q.any = any;

	function any(promises) {
	    if (promises.length === 0) {
	        return Q.resolve();
	    }

	    var deferred = Q.defer();
	    var pendingCount = 0;
	    array_reduce(promises, function (prev, current, index) {
	        var promise = promises[index];

	        pendingCount++;

	        when(promise, onFulfilled, onRejected, onProgress);
	        function onFulfilled(result) {
	            deferred.resolve(result);
	        }
	        function onRejected() {
	            pendingCount--;
	            if (pendingCount === 0) {
	                deferred.reject(new Error(
	                    "Can't get fulfillment value from any promise, all " +
	                    "promises were rejected."
	                ));
	            }
	        }
	        function onProgress(progress) {
	            deferred.notify({
	                index: index,
	                value: progress
	            });
	        }
	    }, undefined);

	    return deferred.promise;
	}

	Promise.prototype.any = function () {
	    return any(this);
	};

	/**
	 * Waits for all promises to be settled, either fulfilled or
	 * rejected.  This is distinct from `all` since that would stop
	 * waiting at the first rejection.  The promise returned by
	 * `allResolved` will never be rejected.
	 * @param promises a promise for an array (or an array) of promises
	 * (or values)
	 * @return a promise for an array of promises
	 */
	Q.allResolved = deprecate(allResolved, "allResolved", "allSettled");
	function allResolved(promises) {
	    return when(promises, function (promises) {
	        promises = array_map(promises, Q);
	        return when(all(array_map(promises, function (promise) {
	            return when(promise, noop, noop);
	        })), function () {
	            return promises;
	        });
	    });
	}

	Promise.prototype.allResolved = function () {
	    return allResolved(this);
	};

	/**
	 * @see Promise#allSettled
	 */
	Q.allSettled = allSettled;
	function allSettled(promises) {
	    return Q(promises).allSettled();
	}

	/**
	 * Turns an array of promises into a promise for an array of their states (as
	 * returned by `inspect`) when they have all settled.
	 * @param {Array[Any*]} values an array (or promise for an array) of values (or
	 * promises for values)
	 * @returns {Array[State]} an array of states for the respective values.
	 */
	Promise.prototype.allSettled = function () {
	    return this.then(function (promises) {
	        return all(array_map(promises, function (promise) {
	            promise = Q(promise);
	            function regardless() {
	                return promise.inspect();
	            }
	            return promise.then(regardless, regardless);
	        }));
	    });
	};

	/**
	 * Captures the failure of a promise, giving an oportunity to recover
	 * with a callback.  If the given promise is fulfilled, the returned
	 * promise is fulfilled.
	 * @param {Any*} promise for something
	 * @param {Function} callback to fulfill the returned promise if the
	 * given promise is rejected
	 * @returns a promise for the return value of the callback
	 */
	Q.fail = // XXX legacy
	Q["catch"] = function (object, rejected) {
	    return Q(object).then(void 0, rejected);
	};

	Promise.prototype.fail = // XXX legacy
	Promise.prototype["catch"] = function (rejected) {
	    return this.then(void 0, rejected);
	};

	/**
	 * Attaches a listener that can respond to progress notifications from a
	 * promise's originating deferred. This listener receives the exact arguments
	 * passed to ``deferred.notify``.
	 * @param {Any*} promise for something
	 * @param {Function} callback to receive any progress notifications
	 * @returns the given promise, unchanged
	 */
	Q.progress = progress;
	function progress(object, progressed) {
	    return Q(object).then(void 0, void 0, progressed);
	}

	Promise.prototype.progress = function (progressed) {
	    return this.then(void 0, void 0, progressed);
	};

	/**
	 * Provides an opportunity to observe the settling of a promise,
	 * regardless of whether the promise is fulfilled or rejected.  Forwards
	 * the resolution to the returned promise when the callback is done.
	 * The callback can return a promise to defer completion.
	 * @param {Any*} promise
	 * @param {Function} callback to observe the resolution of the given
	 * promise, takes no arguments.
	 * @returns a promise for the resolution of the given promise when
	 * ``fin`` is done.
	 */
	Q.fin = // XXX legacy
	Q["finally"] = function (object, callback) {
	    return Q(object)["finally"](callback);
	};

	Promise.prototype.fin = // XXX legacy
	Promise.prototype["finally"] = function (callback) {
	    callback = Q(callback);
	    return this.then(function (value) {
	        return callback.fcall().then(function () {
	            return value;
	        });
	    }, function (reason) {
	        // TODO attempt to recycle the rejection with "this".
	        return callback.fcall().then(function () {
	            throw reason;
	        });
	    });
	};

	/**
	 * Terminates a chain of promises, forcing rejections to be
	 * thrown as exceptions.
	 * @param {Any*} promise at the end of a chain of promises
	 * @returns nothing
	 */
	Q.done = function (object, fulfilled, rejected, progress) {
	    return Q(object).done(fulfilled, rejected, progress);
	};

	Promise.prototype.done = function (fulfilled, rejected, progress) {
	    var onUnhandledError = function (error) {
	        // forward to a future turn so that ``when``
	        // does not catch it and turn it into a rejection.
	        Q.nextTick(function () {
	            makeStackTraceLong(error, promise);
	            if (Q.onerror) {
	                Q.onerror(error);
	            } else {
	                throw error;
	            }
	        });
	    };

	    // Avoid unnecessary `nextTick`ing via an unnecessary `when`.
	    var promise = fulfilled || rejected || progress ?
	        this.then(fulfilled, rejected, progress) :
	        this;

	    if (typeof process === "object" && process && process.domain) {
	        onUnhandledError = process.domain.bind(onUnhandledError);
	    }

	    promise.then(void 0, onUnhandledError);
	};

	/**
	 * Causes a promise to be rejected if it does not get fulfilled before
	 * some milliseconds time out.
	 * @param {Any*} promise
	 * @param {Number} milliseconds timeout
	 * @param {Any*} custom error message or Error object (optional)
	 * @returns a promise for the resolution of the given promise if it is
	 * fulfilled before the timeout, otherwise rejected.
	 */
	Q.timeout = function (object, ms, error) {
	    return Q(object).timeout(ms, error);
	};

	Promise.prototype.timeout = function (ms, error) {
	    var deferred = defer();
	    var timeoutId = setTimeout(function () {
	        if (!error || "string" === typeof error) {
	            error = new Error(error || "Timed out after " + ms + " ms");
	            error.code = "ETIMEDOUT";
	        }
	        deferred.reject(error);
	    }, ms);

	    this.then(function (value) {
	        clearTimeout(timeoutId);
	        deferred.resolve(value);
	    }, function (exception) {
	        clearTimeout(timeoutId);
	        deferred.reject(exception);
	    }, deferred.notify);

	    return deferred.promise;
	};

	/**
	 * Returns a promise for the given value (or promised value), some
	 * milliseconds after it resolved. Passes rejections immediately.
	 * @param {Any*} promise
	 * @param {Number} milliseconds
	 * @returns a promise for the resolution of the given promise after milliseconds
	 * time has elapsed since the resolution of the given promise.
	 * If the given promise rejects, that is passed immediately.
	 */
	Q.delay = function (object, timeout) {
	    if (timeout === void 0) {
	        timeout = object;
	        object = void 0;
	    }
	    return Q(object).delay(timeout);
	};

	Promise.prototype.delay = function (timeout) {
	    return this.then(function (value) {
	        var deferred = defer();
	        setTimeout(function () {
	            deferred.resolve(value);
	        }, timeout);
	        return deferred.promise;
	    });
	};

	/**
	 * Passes a continuation to a Node function, which is called with the given
	 * arguments provided as an array, and returns a promise.
	 *
	 *      Q.nfapply(FS.readFile, [__filename])
	 *      .then(function (content) {
	 *      })
	 *
	 */
	Q.nfapply = function (callback, args) {
	    return Q(callback).nfapply(args);
	};

	Promise.prototype.nfapply = function (args) {
	    var deferred = defer();
	    var nodeArgs = array_slice(args);
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.fapply(nodeArgs).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * Passes a continuation to a Node function, which is called with the given
	 * arguments provided individually, and returns a promise.
	 * @example
	 * Q.nfcall(FS.readFile, __filename)
	 * .then(function (content) {
	 * })
	 *
	 */
	Q.nfcall = function (callback /*...args*/) {
	    var args = array_slice(arguments, 1);
	    return Q(callback).nfapply(args);
	};

	Promise.prototype.nfcall = function (/*...args*/) {
	    var nodeArgs = array_slice(arguments);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.fapply(nodeArgs).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * Wraps a NodeJS continuation passing function and returns an equivalent
	 * version that returns a promise.
	 * @example
	 * Q.nfbind(FS.readFile, __filename)("utf-8")
	 * .then(console.log)
	 * .done()
	 */
	Q.nfbind =
	Q.denodeify = function (callback /*...args*/) {
	    var baseArgs = array_slice(arguments, 1);
	    return function () {
	        var nodeArgs = baseArgs.concat(array_slice(arguments));
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        Q(callback).fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	};

	Promise.prototype.nfbind =
	Promise.prototype.denodeify = function (/*...args*/) {
	    var args = array_slice(arguments);
	    args.unshift(this);
	    return Q.denodeify.apply(void 0, args);
	};

	Q.nbind = function (callback, thisp /*...args*/) {
	    var baseArgs = array_slice(arguments, 2);
	    return function () {
	        var nodeArgs = baseArgs.concat(array_slice(arguments));
	        var deferred = defer();
	        nodeArgs.push(deferred.makeNodeResolver());
	        function bound() {
	            return callback.apply(thisp, arguments);
	        }
	        Q(bound).fapply(nodeArgs).fail(deferred.reject);
	        return deferred.promise;
	    };
	};

	Promise.prototype.nbind = function (/*thisp, ...args*/) {
	    var args = array_slice(arguments, 0);
	    args.unshift(this);
	    return Q.nbind.apply(void 0, args);
	};

	/**
	 * Calls a method of a Node-style object that accepts a Node-style
	 * callback with a given array of arguments, plus a provided callback.
	 * @param object an object that has the named method
	 * @param {String} name name of the method of object
	 * @param {Array} args arguments to pass to the method; the callback
	 * will be provided by Q and appended to these arguments.
	 * @returns a promise for the value or error
	 */
	Q.nmapply = // XXX As proposed by "Redsandro"
	Q.npost = function (object, name, args) {
	    return Q(object).npost(name, args);
	};

	Promise.prototype.nmapply = // XXX As proposed by "Redsandro"
	Promise.prototype.npost = function (name, args) {
	    var nodeArgs = array_slice(args || []);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * Calls a method of a Node-style object that accepts a Node-style
	 * callback, forwarding the given variadic arguments, plus a provided
	 * callback argument.
	 * @param object an object that has the named method
	 * @param {String} name name of the method of object
	 * @param ...args arguments to pass to the method; the callback will
	 * be provided by Q and appended to these arguments.
	 * @returns a promise for the value or error
	 */
	Q.nsend = // XXX Based on Mark Miller's proposed "send"
	Q.nmcall = // XXX Based on "Redsandro's" proposal
	Q.ninvoke = function (object, name /*...args*/) {
	    var nodeArgs = array_slice(arguments, 2);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    Q(object).dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};

	Promise.prototype.nsend = // XXX Based on Mark Miller's proposed "send"
	Promise.prototype.nmcall = // XXX Based on "Redsandro's" proposal
	Promise.prototype.ninvoke = function (name /*...args*/) {
	    var nodeArgs = array_slice(arguments, 1);
	    var deferred = defer();
	    nodeArgs.push(deferred.makeNodeResolver());
	    this.dispatch("post", [name, nodeArgs]).fail(deferred.reject);
	    return deferred.promise;
	};

	/**
	 * If a function would like to support both Node continuation-passing-style and
	 * promise-returning-style, it can end its internal promise chain with
	 * `nodeify(nodeback)`, forwarding the optional nodeback argument.  If the user
	 * elects to use a nodeback, the result will be sent there.  If they do not
	 * pass a nodeback, they will receive the result promise.
	 * @param object a result (or a promise for a result)
	 * @param {Function} nodeback a Node.js-style callback
	 * @returns either the promise or nothing
	 */
	Q.nodeify = nodeify;
	function nodeify(object, nodeback) {
	    return Q(object).nodeify(nodeback);
	}

	Promise.prototype.nodeify = function (nodeback) {
	    if (nodeback) {
	        this.then(function (value) {
	            Q.nextTick(function () {
	                nodeback(null, value);
	            });
	        }, function (error) {
	            Q.nextTick(function () {
	                nodeback(error);
	            });
	        });
	    } else {
	        return this;
	    }
	};

	Q.noConflict = function() {
	    throw new Error("Q.noConflict only works when Q is used as a global");
	};

	// All code before this point will be filtered from stack traces.
	var qEndingLine = captureLine();

	return Q;

	});

	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(26), __webpack_require__(27).setImmediate))

/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
	  * Reqwest! A general purpose XHR connection manager
	  * license MIT (c) Dustin Diaz 2014
	  * https://github.com/ded/reqwest
	  */

	!function (name, context, definition) {
	  if (typeof module != 'undefined' && module.exports) module.exports = definition()
	  else if (true) !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
	  else context[name] = definition()
	}('reqwest', this, function () {

	  var win = window
	    , doc = document
	    , httpsRe = /^http/
	    , protocolRe = /(^\w+):\/\//
	    , twoHundo = /^(20\d|1223)$/ //http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
	    , byTag = 'getElementsByTagName'
	    , readyState = 'readyState'
	    , contentType = 'Content-Type'
	    , requestedWith = 'X-Requested-With'
	    , head = doc[byTag]('head')[0]
	    , uniqid = 0
	    , callbackPrefix = 'reqwest_' + (+new Date())
	    , lastValue // data stored by the most recent JSONP callback
	    , xmlHttpRequest = 'XMLHttpRequest'
	    , xDomainRequest = 'XDomainRequest'
	    , noop = function () {}

	    , isArray = typeof Array.isArray == 'function'
	        ? Array.isArray
	        : function (a) {
	            return a instanceof Array
	          }

	    , defaultHeaders = {
	          'contentType': 'application/x-www-form-urlencoded'
	        , 'requestedWith': xmlHttpRequest
	        , 'accept': {
	              '*':  'text/javascript, text/html, application/xml, text/xml, */*'
	            , 'xml':  'application/xml, text/xml'
	            , 'html': 'text/html'
	            , 'text': 'text/plain'
	            , 'json': 'application/json, text/javascript'
	            , 'js':   'application/javascript, text/javascript'
	          }
	      }

	    , xhr = function(o) {
	        // is it x-domain
	        if (o['crossOrigin'] === true) {
	          var xhr = win[xmlHttpRequest] ? new XMLHttpRequest() : null
	          if (xhr && 'withCredentials' in xhr) {
	            return xhr
	          } else if (win[xDomainRequest]) {
	            return new XDomainRequest()
	          } else {
	            throw new Error('Browser does not support cross-origin requests')
	          }
	        } else if (win[xmlHttpRequest]) {
	          return new XMLHttpRequest()
	        } else {
	          return new ActiveXObject('Microsoft.XMLHTTP')
	        }
	      }
	    , globalSetupOptions = {
	        dataFilter: function (data) {
	          return data
	        }
	      }

	  function succeed(r) {
	    var protocol = protocolRe.exec(r.url);
	    protocol = (protocol && protocol[1]) || window.location.protocol;
	    return httpsRe.test(protocol) ? twoHundo.test(r.request.status) : !!r.request.response;
	  }

	  function handleReadyState(r, success, error) {
	    return function () {
	      // use _aborted to mitigate against IE err c00c023f
	      // (can't read props on aborted request objects)
	      if (r._aborted) return error(r.request)
	      if (r._timedOut) return error(r.request, 'Request is aborted: timeout')
	      if (r.request && r.request[readyState] == 4) {
	        r.request.onreadystatechange = noop
	        if (succeed(r)) success(r.request)
	        else
	          error(r.request)
	      }
	    }
	  }

	  function setHeaders(http, o) {
	    var headers = o['headers'] || {}
	      , h

	    headers['Accept'] = headers['Accept']
	      || defaultHeaders['accept'][o['type']]
	      || defaultHeaders['accept']['*']

	    var isAFormData = typeof FormData === 'function' && (o['data'] instanceof FormData);
	    // breaks cross-origin requests with legacy browsers
	    if (!o['crossOrigin'] && !headers[requestedWith]) headers[requestedWith] = defaultHeaders['requestedWith']
	    if (!headers[contentType] && !isAFormData) headers[contentType] = o['contentType'] || defaultHeaders['contentType']
	    for (h in headers)
	      headers.hasOwnProperty(h) && 'setRequestHeader' in http && http.setRequestHeader(h, headers[h])
	  }

	  function setCredentials(http, o) {
	    if (typeof o['withCredentials'] !== 'undefined' && typeof http.withCredentials !== 'undefined') {
	      http.withCredentials = !!o['withCredentials']
	    }
	  }

	  function generalCallback(data) {
	    lastValue = data
	  }

	  function urlappend (url, s) {
	    return url + (/\?/.test(url) ? '&' : '?') + s
	  }

	  function handleJsonp(o, fn, err, url) {
	    var reqId = uniqid++
	      , cbkey = o['jsonpCallback'] || 'callback' // the 'callback' key
	      , cbval = o['jsonpCallbackName'] || reqwest.getcallbackPrefix(reqId)
	      , cbreg = new RegExp('((^|\\?|&)' + cbkey + ')=([^&]+)')
	      , match = url.match(cbreg)
	      , script = doc.createElement('script')
	      , loaded = 0
	      , isIE10 = navigator.userAgent.indexOf('MSIE 10.0') !== -1

	    if (match) {
	      if (match[3] === '?') {
	        url = url.replace(cbreg, '$1=' + cbval) // wildcard callback func name
	      } else {
	        cbval = match[3] // provided callback func name
	      }
	    } else {
	      url = urlappend(url, cbkey + '=' + cbval) // no callback details, add 'em
	    }

	    win[cbval] = generalCallback

	    script.type = 'text/javascript'
	    script.src = url
	    script.async = true
	    if (typeof script.onreadystatechange !== 'undefined' && !isIE10) {
	      // need this for IE due to out-of-order onreadystatechange(), binding script
	      // execution to an event listener gives us control over when the script
	      // is executed. See http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
	      script.htmlFor = script.id = '_reqwest_' + reqId
	    }

	    script.onload = script.onreadystatechange = function () {
	      if ((script[readyState] && script[readyState] !== 'complete' && script[readyState] !== 'loaded') || loaded) {
	        return false
	      }
	      script.onload = script.onreadystatechange = null
	      script.onclick && script.onclick()
	      // Call the user callback with the last value stored and clean up values and scripts.
	      fn(lastValue)
	      lastValue = undefined
	      head.removeChild(script)
	      loaded = 1
	    }

	    // Add the script to the DOM head
	    head.appendChild(script)

	    // Enable JSONP timeout
	    return {
	      abort: function () {
	        script.onload = script.onreadystatechange = null
	        err({}, 'Request is aborted: timeout', {})
	        lastValue = undefined
	        head.removeChild(script)
	        loaded = 1
	      }
	    }
	  }

	  function getRequest(fn, err) {
	    var o = this.o
	      , method = (o['method'] || 'GET').toUpperCase()
	      , url = typeof o === 'string' ? o : o['url']
	      // convert non-string objects to query-string form unless o['processData'] is false
	      , data = (o['processData'] !== false && o['data'] && typeof o['data'] !== 'string')
	        ? reqwest.toQueryString(o['data'])
	        : (o['data'] || null)
	      , http
	      , sendWait = false

	    // if we're working on a GET request and we have data then we should append
	    // query string to end of URL and not post data
	    if ((o['type'] == 'jsonp' || method == 'GET') && data) {
	      url = urlappend(url, data)
	      data = null
	    }

	    if (o['type'] == 'jsonp') return handleJsonp(o, fn, err, url)

	    // get the xhr from the factory if passed
	    // if the factory returns null, fall-back to ours
	    http = (o.xhr && o.xhr(o)) || xhr(o)

	    http.open(method, url, o['async'] === false ? false : true)
	    setHeaders(http, o)
	    setCredentials(http, o)
	    if (win[xDomainRequest] && http instanceof win[xDomainRequest]) {
	        http.onload = fn
	        http.onerror = err
	        // NOTE: see
	        // http://social.msdn.microsoft.com/Forums/en-US/iewebdevelopment/thread/30ef3add-767c-4436-b8a9-f1ca19b4812e
	        http.onprogress = function() {}
	        sendWait = true
	    } else {
	      http.onreadystatechange = handleReadyState(this, fn, err)
	    }
	    o['before'] && o['before'](http)
	    if (sendWait) {
	      setTimeout(function () {
	        http.send(data)
	      }, 200)
	    } else {
	      http.send(data)
	    }
	    return http
	  }

	  function Reqwest(o, fn) {
	    this.o = o
	    this.fn = fn

	    init.apply(this, arguments)
	  }

	  function setType(header) {
	    // json, javascript, text/plain, text/html, xml
	    if (header.match('json')) return 'json'
	    if (header.match('javascript')) return 'js'
	    if (header.match('text')) return 'html'
	    if (header.match('xml')) return 'xml'
	  }

	  function init(o, fn) {

	    this.url = typeof o == 'string' ? o : o['url']
	    this.timeout = null

	    // whether request has been fulfilled for purpose
	    // of tracking the Promises
	    this._fulfilled = false
	    // success handlers
	    this._successHandler = function(){}
	    this._fulfillmentHandlers = []
	    // error handlers
	    this._errorHandlers = []
	    // complete (both success and fail) handlers
	    this._completeHandlers = []
	    this._erred = false
	    this._responseArgs = {}

	    var self = this

	    fn = fn || function () {}

	    if (o['timeout']) {
	      this.timeout = setTimeout(function () {
	        timedOut()
	      }, o['timeout'])
	    }

	    if (o['success']) {
	      this._successHandler = function () {
	        o['success'].apply(o, arguments)
	      }
	    }

	    if (o['error']) {
	      this._errorHandlers.push(function () {
	        o['error'].apply(o, arguments)
	      })
	    }

	    if (o['complete']) {
	      this._completeHandlers.push(function () {
	        o['complete'].apply(o, arguments)
	      })
	    }

	    function complete (resp) {
	      o['timeout'] && clearTimeout(self.timeout)
	      self.timeout = null
	      while (self._completeHandlers.length > 0) {
	        self._completeHandlers.shift()(resp)
	      }
	    }

	    function success (resp) {
	      var type = o['type'] || resp && setType(resp.getResponseHeader('Content-Type')) // resp can be undefined in IE
	      resp = (type !== 'jsonp') ? self.request : resp
	      // use global data filter on response text
	      var filteredResponse = globalSetupOptions.dataFilter(resp.responseText, type)
	        , r = filteredResponse
	      try {
	        resp.responseText = r
	      } catch (e) {
	        // can't assign this in IE<=8, just ignore
	      }
	      if (r) {
	        switch (type) {
	        case 'json':
	          try {
	            resp = win.JSON ? win.JSON.parse(r) : eval('(' + r + ')')
	          } catch (err) {
	            return error(resp, 'Could not parse JSON in response', err)
	          }
	          break
	        case 'js':
	          resp = eval(r)
	          break
	        case 'html':
	          resp = r
	          break
	        case 'xml':
	          resp = resp.responseXML
	              && resp.responseXML.parseError // IE trololo
	              && resp.responseXML.parseError.errorCode
	              && resp.responseXML.parseError.reason
	            ? null
	            : resp.responseXML
	          break
	        }
	      }

	      self._responseArgs.resp = resp
	      self._fulfilled = true
	      fn(resp)
	      self._successHandler(resp)
	      while (self._fulfillmentHandlers.length > 0) {
	        resp = self._fulfillmentHandlers.shift()(resp)
	      }

	      complete(resp)
	    }

	    function timedOut() {
	      self._timedOut = true
	      self.request.abort()      
	    }

	    function error(resp, msg, t) {
	      resp = self.request
	      self._responseArgs.resp = resp
	      self._responseArgs.msg = msg
	      self._responseArgs.t = t
	      self._erred = true
	      while (self._errorHandlers.length > 0) {
	        self._errorHandlers.shift()(resp, msg, t)
	      }
	      complete(resp)
	    }

	    this.request = getRequest.call(this, success, error)
	  }

	  Reqwest.prototype = {
	    abort: function () {
	      this._aborted = true
	      this.request.abort()
	    }

	  , retry: function () {
	      init.call(this, this.o, this.fn)
	    }

	    /**
	     * Small deviation from the Promises A CommonJs specification
	     * http://wiki.commonjs.org/wiki/Promises/A
	     */

	    /**
	     * `then` will execute upon successful requests
	     */
	  , then: function (success, fail) {
	      success = success || function () {}
	      fail = fail || function () {}
	      if (this._fulfilled) {
	        this._responseArgs.resp = success(this._responseArgs.resp)
	      } else if (this._erred) {
	        fail(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
	      } else {
	        this._fulfillmentHandlers.push(success)
	        this._errorHandlers.push(fail)
	      }
	      return this
	    }

	    /**
	     * `always` will execute whether the request succeeds or fails
	     */
	  , always: function (fn) {
	      if (this._fulfilled || this._erred) {
	        fn(this._responseArgs.resp)
	      } else {
	        this._completeHandlers.push(fn)
	      }
	      return this
	    }

	    /**
	     * `fail` will execute when the request fails
	     */
	  , fail: function (fn) {
	      if (this._erred) {
	        fn(this._responseArgs.resp, this._responseArgs.msg, this._responseArgs.t)
	      } else {
	        this._errorHandlers.push(fn)
	      }
	      return this
	    }
	  , 'catch': function (fn) {
	      return this.fail(fn)
	    }
	  }

	  function reqwest(o, fn) {
	    return new Reqwest(o, fn)
	  }

	  // normalize newline variants according to spec -> CRLF
	  function normalize(s) {
	    return s ? s.replace(/\r?\n/g, '\r\n') : ''
	  }

	  function serial(el, cb) {
	    var n = el.name
	      , t = el.tagName.toLowerCase()
	      , optCb = function (o) {
	          // IE gives value="" even where there is no value attribute
	          // 'specified' ref: http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-862529273
	          if (o && !o['disabled'])
	            cb(n, normalize(o['attributes']['value'] && o['attributes']['value']['specified'] ? o['value'] : o['text']))
	        }
	      , ch, ra, val, i

	    // don't serialize elements that are disabled or without a name
	    if (el.disabled || !n) return

	    switch (t) {
	    case 'input':
	      if (!/reset|button|image|file/i.test(el.type)) {
	        ch = /checkbox/i.test(el.type)
	        ra = /radio/i.test(el.type)
	        val = el.value
	        // WebKit gives us "" instead of "on" if a checkbox has no value, so correct it here
	        ;(!(ch || ra) || el.checked) && cb(n, normalize(ch && val === '' ? 'on' : val))
	      }
	      break
	    case 'textarea':
	      cb(n, normalize(el.value))
	      break
	    case 'select':
	      if (el.type.toLowerCase() === 'select-one') {
	        optCb(el.selectedIndex >= 0 ? el.options[el.selectedIndex] : null)
	      } else {
	        for (i = 0; el.length && i < el.length; i++) {
	          el.options[i].selected && optCb(el.options[i])
	        }
	      }
	      break
	    }
	  }

	  // collect up all form elements found from the passed argument elements all
	  // the way down to child elements; pass a '<form>' or form fields.
	  // called with 'this'=callback to use for serial() on each element
	  function eachFormElement() {
	    var cb = this
	      , e, i
	      , serializeSubtags = function (e, tags) {
	          var i, j, fa
	          for (i = 0; i < tags.length; i++) {
	            fa = e[byTag](tags[i])
	            for (j = 0; j < fa.length; j++) serial(fa[j], cb)
	          }
	        }

	    for (i = 0; i < arguments.length; i++) {
	      e = arguments[i]
	      if (/input|select|textarea/i.test(e.tagName)) serial(e, cb)
	      serializeSubtags(e, [ 'input', 'select', 'textarea' ])
	    }
	  }

	  // standard query string style serialization
	  function serializeQueryString() {
	    return reqwest.toQueryString(reqwest.serializeArray.apply(null, arguments))
	  }

	  // { 'name': 'value', ... } style serialization
	  function serializeHash() {
	    var hash = {}
	    eachFormElement.apply(function (name, value) {
	      if (name in hash) {
	        hash[name] && !isArray(hash[name]) && (hash[name] = [hash[name]])
	        hash[name].push(value)
	      } else hash[name] = value
	    }, arguments)
	    return hash
	  }

	  // [ { name: 'name', value: 'value' }, ... ] style serialization
	  reqwest.serializeArray = function () {
	    var arr = []
	    eachFormElement.apply(function (name, value) {
	      arr.push({name: name, value: value})
	    }, arguments)
	    return arr
	  }

	  reqwest.serialize = function () {
	    if (arguments.length === 0) return ''
	    var opt, fn
	      , args = Array.prototype.slice.call(arguments, 0)

	    opt = args.pop()
	    opt && opt.nodeType && args.push(opt) && (opt = null)
	    opt && (opt = opt.type)

	    if (opt == 'map') fn = serializeHash
	    else if (opt == 'array') fn = reqwest.serializeArray
	    else fn = serializeQueryString

	    return fn.apply(null, args)
	  }

	  reqwest.toQueryString = function (o, trad) {
	    var prefix, i
	      , traditional = trad || false
	      , s = []
	      , enc = encodeURIComponent
	      , add = function (key, value) {
	          // If value is a function, invoke it and return its value
	          value = ('function' === typeof value) ? value() : (value == null ? '' : value)
	          s[s.length] = enc(key) + '=' + enc(value)
	        }
	    // If an array was passed in, assume that it is an array of form elements.
	    if (isArray(o)) {
	      for (i = 0; o && i < o.length; i++) add(o[i]['name'], o[i]['value'])
	    } else {
	      // If traditional, encode the "old" way (the way 1.3.2 or older
	      // did it), otherwise encode params recursively.
	      for (prefix in o) {
	        if (o.hasOwnProperty(prefix)) buildParams(prefix, o[prefix], traditional, add)
	      }
	    }

	    // spaces should be + according to spec
	    return s.join('&').replace(/%20/g, '+')
	  }

	  function buildParams(prefix, obj, traditional, add) {
	    var name, i, v
	      , rbracket = /\[\]$/

	    if (isArray(obj)) {
	      // Serialize array item.
	      for (i = 0; obj && i < obj.length; i++) {
	        v = obj[i]
	        if (traditional || rbracket.test(prefix)) {
	          // Treat each array item as a scalar.
	          add(prefix, v)
	        } else {
	          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add)
	        }
	      }
	    } else if (obj && obj.toString() === '[object Object]') {
	      // Serialize object item.
	      for (name in obj) {
	        buildParams(prefix + '[' + name + ']', obj[name], traditional, add)
	      }

	    } else {
	      // Serialize scalar item.
	      add(prefix, obj)
	    }
	  }

	  reqwest.getcallbackPrefix = function () {
	    return callbackPrefix
	  }

	  // jQuery and Zepto compatibility, differences can be remapped here so you can call
	  // .ajax.compat(options, callback)
	  reqwest.compat = function (o, fn) {
	    if (o) {
	      o['type'] && (o['method'] = o['type']) && delete o['type']
	      o['dataType'] && (o['type'] = o['dataType'])
	      o['jsonpCallback'] && (o['jsonpCallbackName'] = o['jsonpCallback']) && delete o['jsonpCallback']
	      o['jsonp'] && (o['jsonpCallback'] = o['jsonp'])
	    }
	    return new Reqwest(o, fn)
	  }

	  reqwest.ajaxSetup = function (options) {
	    options = options || {}
	    for (var k in options) {
	      globalSetupOptions[k] = options[k]
	    }
	  }

	  return reqwest
	});


/***/ },
/* 23 */
/***/ function(module, exports, __webpack_require__) {

	exports.ActionMethods = __webpack_require__(28);

	exports.ListenerMethods = __webpack_require__(29);

	exports.PublisherMethods = __webpack_require__(30);

	exports.StoreMethods = __webpack_require__(31);

	exports.createAction = __webpack_require__(32);

	exports.createStore = __webpack_require__(33);

	exports.connect = __webpack_require__(34);

	exports.connectFilter = __webpack_require__(35);

	exports.ListenerMixin = __webpack_require__(36);

	exports.listenTo = __webpack_require__(37);

	exports.listenToMany = __webpack_require__(38);


	var maker = __webpack_require__(39).staticJoinCreator;

	exports.joinTrailing = exports.all = maker("last"); // Reflux.all alias for backward compatibility

	exports.joinLeading = maker("first");

	exports.joinStrict = maker("strict");

	exports.joinConcat = maker("all");

	var _ = __webpack_require__(40);

	exports.EventEmitter = _.EventEmitter;

	exports.Promise = _.Promise;

	/**
	 * Convenience function for creating a set of actions
	 *
	 * @param definitions the definitions for the actions to be created
	 * @returns an object with actions of corresponding action names
	 */
	exports.createActions = function(definitions) {
	    var actions = {};
	    for (var k in definitions){
	        if (definitions.hasOwnProperty(k)) {
	            var val = definitions[k],
	                actionName = _.isObject(val) ? k : val;

	            actions[actionName] = exports.createAction(val);
	        }
	    }
	    return actions;
	};

	/**
	 * Sets the eventmitter that Reflux uses
	 */
	exports.setEventEmitter = function(ctx) {
	    var _ = __webpack_require__(40);
	    exports.EventEmitter = _.EventEmitter = ctx;
	};


	/**
	 * Sets the Promise library that Reflux uses
	 */
	exports.setPromise = function(ctx) {
	    var _ = __webpack_require__(40);
	    exports.Promise = _.Promise = ctx;
	};


	/**
	 * Sets the Promise factory that creates new promises
	 * @param {Function} factory has the signature `function(resolver) { return [new Promise]; }`
	 */
	exports.setPromiseFactory = function(factory) {
	    var _ = __webpack_require__(40);
	    _.createPromise = factory;
	};


	/**
	 * Sets the method used for deferring actions and stores
	 */
	exports.nextTick = function(nextTick) {
	    var _ = __webpack_require__(40);
	    _.nextTick = nextTick;
	};

	/**
	 * Provides the set of created actions and stores for introspection
	 */
	exports.__keep = __webpack_require__(41);

	/**
	 * Warn if Function.prototype.bind not available
	 */
	if (!Function.prototype.bind) {
	  console.error(
	    'Function.prototype.bind not available. ' +
	    'ES5 shim required. ' +
	    'https://github.com/spoike/refluxjs#es5'
	  );
	}


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global) {/**
	 * LokiJS
	 * @author Joe Minichino <joe.minichino@gmail.com>
	 *
	 * A lightweight document oriented javascript database
	 */
	(function (root, factory) {
	  if (true) {
	    // AMD
	    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	  } else if (typeof exports === 'object') {
	    // CommonJS
	    module.exports = factory();
	  } else {
	    // Browser globals
	    root.loki = factory();
	  }
	}(this, function () {

	  return (function () {
	    'use strict';

	    var Utils = {
	      copyProperties: function (src, dest) {
	        var prop;
	        for (prop in src) {
	          dest[prop] = src[prop];
	        }
	      }
	    };

	    // Sort helper that support null and undefined
	    function ltHelper(prop1, prop2, equal) {
	      if (prop1 === prop2) {
	        if (equal) {
	          return true;
	        } else {
	          return false;
	        }
	      }

	      if (prop1 === undefined) {
	        return true;
	      }
	      if (prop2 === undefined) {
	        return false;
	      }
	      if (prop1 === null) {
	        return true;
	      }
	      if (prop2 === null) {
	        return false;
	      }
	      return prop1 < prop2;
	    }

	    function gtHelper(prop1, prop2, equal) {
	      if (prop1 === prop2) {
	        if (equal) {
	          return true;
	        } else {
	          return false;
	        }
	      }

	      if (prop1 === undefined) {
	        return false;
	      }
	      if (prop2 === undefined) {
	        return true;
	      }
	      if (prop1 === null) {
	        return false;
	      }
	      if (prop2 === null) {
	        return true;
	      }
	      return prop1 > prop2;
	    }

	    function sortHelper(prop1, prop2, desc) {
	      if (prop1 === prop2) {
	        return 0;
	      }
	      if (desc) {
	        if (ltHelper(prop1, prop2)) {
	          return 1;
	        } else {
	          return -1;
	        }
	      } else {
	        if (gtHelper(prop1, prop2)) {
	          return 1;
	        } else {
	          return -1;
	        }
	      }
	    }

	    function containsCheckFn(a, b) {
	      if (Array.isArray(a)) {
	        return function (curr) {
	          return a.indexOf(curr) !== -1;
	        };
	      } else if (typeof a === 'string') {
	        return function (curr) {
	          return a.indexOf(curr) !== -1;
	        };
	      } else if (a && typeof a === 'object') {
	        return function (curr) {
	          return a.hasOwnProperty(curr);
	        };
	      }
	    }

	    var LokiOps = {
	      // comparison operators
	      $eq: function (a, b) {
	        return a === b;
	      },

	      $gt: function (a, b) {
	        return gtHelper(a, b);
	      },

	      $gte: function (a, b) {
	        return gtHelper(a, b, true);
	      },

	      $lt: function (a, b) {
	        return ltHelper(a, b);
	      },

	      $lte: function (a, b) {
	        return ltHelper(a, b, true);
	      },

	      $ne: function (a, b) {
	        return a !== b;
	      },

	      $regex: function (a, b) {
	        return b.test(a);
	      },

	      $in: function (a, b) {
	        return b.indexOf(a) > -1;
	      },

	      $containsAny: function (a, b) {
	        var checkFn;

	        if (!Array.isArray(b)) {
	          b = [b];
	        }

	        checkFn = containsCheckFn(a, b) || function () {
	          return false;
	        };

	        return b.reduce(function (prev, curr) {
	          if (prev) {
	            return prev;
	          }

	          return checkFn(curr);
	        }, false);
	      },

	      $contains: function (a, b) {
	        var checkFn;

	        if (!Array.isArray(b)) {
	          b = [b];
	        }

	        checkFn = containsCheckFn(a, b) || function () {
	          return true;
	        };

	        return b.reduce(function (prev, curr) {
	          if (!prev) {
	            return prev;
	          }

	          return checkFn(curr);
	        }, true);
	      }
	    };

	    var operators = {
	      '$eq': LokiOps.$eq,
	      '$gt': LokiOps.$gt,
	      '$gte': LokiOps.$gte,
	      '$lt': LokiOps.$lt,
	      '$lte': LokiOps.$lte,
	      '$ne': LokiOps.$ne,
	      '$regex': LokiOps.$regex,
	      '$in': LokiOps.$in,
	      '$contains': LokiOps.$contains,
	      '$containsAny': LokiOps.$containsAny
	    };

	    function clone(data, method) {
	      var cloneMethod = method || 'parse-stringify',
	        cloned;
	      if (cloneMethod === 'parse-stringify') {
	        cloned = JSON.parse(JSON.stringify(data));
	      }
	      return cloned;
	    }

	    function localStorageAvailable() {
	      try {
	        return ('localStorage' in window && window.localStorage !== null);
	      } catch (e) {
	        return false;
	      }
	    }


	    /**
	     * LokiEventEmitter is a minimalist version of EventEmitter. It enables any
	     * constructor that inherits EventEmitter to emit events and trigger
	     * listeners that have been added to the event through the on(event, callback) method
	     *
	     * @constructor
	     */
	    function LokiEventEmitter() {}

	    /**
	     * @prop Events property is a hashmap, with each property being an array of callbacks
	     */
	    LokiEventEmitter.prototype.events = {};

	    /**
	     * @prop asyncListeners - boolean determines whether or not the callbacks associated with each event
	     * should happen in an async fashion or not
	     * Default is false, which means events are synchronous
	     */
	    LokiEventEmitter.prototype.asyncListeners = false;

	    /**
	     * @prop on(eventName, listener) - adds a listener to the queue of callbacks associated to an event
	     * @returns {int} the index of the callback in the array of listeners for a particular event
	     */
	    LokiEventEmitter.prototype.on = function (eventName, listener) {
	      var event = this.events[eventName];
	      if (!event) {
	        event = this.events[eventName] = [];
	      }
	      event.push(listener);
	      return listener;
	    };

	    /**
	     * @propt emit(eventName, data) - emits a particular event
	     * with the option of passing optional parameters which are going to be processed by the callback
	     * provided signatures match (i.e. if passing emit(event, arg0, arg1) the listener should take two parameters)
	     * @param {string} eventName - the name of the event
	     * @param {object} data - optional object passed with the event
	     */
	    LokiEventEmitter.prototype.emit = function (eventName, data) {
	      var self = this;
	      if (eventName && this.events[eventName]) {
	        this.events[eventName].forEach(function (listener) {
	          if (self.asyncListeners) {
	            setTimeout(function () {
	              listener(data);
	            }, 1);
	          } else {
	            listener(data);
	          }

	        });
	      } else {
	        throw new Error('No event ' + eventName + ' defined');
	      }
	    };

	    /**
	     * @prop remove() - removes the listener at position 'index' from the event 'eventName'
	     */
	    LokiEventEmitter.prototype.removeListener = function (eventName, listener) {
	      if (this.events[eventName]) {
	        var listeners = this.events[eventName];
	        listeners.splice(listeners.indexOf(listener), 1);
	      }
	    };

	    /**
	     * Loki: The main database class
	     * @constructor
	     * @param {string} filename - name of the file to be saved to
	     * @param {object} options - config object
	     */
	    function Loki(filename, options) {
	      this.filename = filename || 'loki.db';
	      this.collections = [];

	      // persist version of code which created the database to the database.
	      // could use for upgrade scenarios
	      this.databaseVersion = 1.1;
	      this.engineVersion = 1.1;

	      // autosave support (disabled by default)
	      // pass autosave: true, autosaveInterval: 6000 in options to set 6 second autosave
	      this.autosave = false;
	      this.autosaveInterval = 5000;
	      this.autosaveHandle = null;

	      this.options = {};

	      // currently keeping persistenceMethod and persistenceAdapter as loki level properties that
	      // will not or cannot be deserialized.  You are required to configure persistence every time
	      // you instantiate a loki object (or use default environment detection) in order to load the database anyways.

	      // persistenceMethod could be 'fs', 'localStorage', or 'adapter'
	      // this is optional option param, otherwise environment detection will be used
	      // if user passes their own adapter we will force this method to 'adapter' later, so no need to pass method option.
	      this.persistenceMethod = null;

	      // retain reference to optional (non-serializable) persistenceAdapter 'instance'
	      this.persistenceAdapter = null;



	      this.events = {
	        'init': [],
	        'flushChanges': [],
	        'close': [],
	        'changes': [],
	        'warning': []
	      };

	      var getENV = function () {
	        if (typeof window === 'undefined') {
	          return 'NODEJS';
	        }

	        if (typeof global !== 'undefined' && global.window) {
	          return 'NODEJS'; //node-webkit
	        }

	        if (typeof document !== 'undefined') {
	          if (document.URL.indexOf('http://') === -1 && document.URL.indexOf('https://') === -1) {
	            return 'CORDOVA';
	          }
	          return 'BROWSER';
	        }
	        return 'CORDOVA';
	      };

	      // refactored environment detection due to invalid detection for browser environments.
	      // if they do not specify an options.env we want to detect env rather than default to nodejs.
	      // currently keeping two properties for similar thing (options.env and options.persistenceMethod)
	      //   might want to review whether we can consolidate.
	      if (options && options.hasOwnProperty('env')) {
	        this.ENV = options.env;
	      } else {
	        this.ENV = getENV();
	      }

	      // not sure if this is necessary now that i have refactored the line above
	      if (this.ENV === 'undefined') {
	        this.ENV = 'NODEJS';
	      }

	      //if (typeof (options) !== 'undefined') {
	      this.configureOptions(options, true);
	      //}

	      this.on('init', this.clearChanges);

	    }

	    // db class is an EventEmitter
	    Loki.prototype = new LokiEventEmitter();

	    /**
	     * configureOptions - allows reconfiguring database options
	     *
	     * @param {object} options - configuration options to apply to loki db object
	     * @param {boolean} initialConfig - (optional) if this is a reconfig, don't pass this
	     */
	    Loki.prototype.configureOptions = function (options, initialConfig) {
	      var defaultPersistence = {
	          'NODEJS': 'fs',
	          'BROWSER': 'localStorage',
	          'CORDOVA': 'localStorage'
	        },
	        persistenceMethods = {
	          'fs': LokiFsAdapter,
	          'localStorage': LokiLocalStorageAdapter
	        };

	      this.options = {};

	      this.persistenceMethod = null;
	      // retain reference to optional persistence adapter 'instance'
	      // currently keeping outside options because it can't be serialized
	      this.persistenceAdapter = null;

	      // process the options
	      if (typeof (options) !== 'undefined') {
	        this.options = options;


	        if (this.options.hasOwnProperty('persistenceMethod')) {
	          // check if the specified persistence method is known
	          if (typeof (persistenceMethods[options.persistenceMethod]) == 'function') {
	            this.persistenceMethod = options.persistenceMethod;
	            this.persistenceAdapter = new persistenceMethods[options.persistenceMethod]();
	          }
	          // should be throw an error here, or just fall back to defaults ??
	        }

	        // if user passes adapter, set persistence mode to adapter and retain persistence adapter instance
	        if (this.options.hasOwnProperty('adapter')) {
	          this.persistenceMethod = 'adapter';
	          this.persistenceAdapter = options.adapter;
	        }


	        // if they want to load database on loki instantiation, now is a good time to load... after adapter set and before possible autosave initiation
	        if (options.hasOwnProperty('autoload') && typeof (initialConfig) !== 'undefined' && initialConfig) {
	          // for autoload, let the constructor complete before firing callback
	          var self = this;
	          setTimeout(function () {
	            self.loadDatabase(options, options.autoloadCallback);
	          }, 1);
	        }

	        if (this.options.hasOwnProperty('autosaveInterval')) {
	          this.autosaveDisable();
	          this.autosaveInterval = parseInt(this.options.autosaveInterval, 10);
	        }

	        if (this.options.hasOwnProperty('autosave') && this.options.autosave) {
	          this.autosaveDisable();
	          this.autosave = true;
	          this.autosaveEnable();
	        }
	      } // end of options processing

	      // if by now there is no adapter specified by user nor derived from persistenceMethod: use sensible defaults
	      if (this.persistenceAdapter === null) {
	        this.persistenceMethod = defaultPersistence[this.ENV];
	        if (this.persistenceMethod) {
	          this.persistenceAdapter = new persistenceMethods[this.persistenceMethod]();
	        }
	      }

	    };

	    /**
	     * anonym() - shorthand method for quickly creating and populating an anonymous collection.
	     *    This collection is not referenced internally so upon losing scope it will be garbage collected.
	     *
	     *    Example : var results = new loki().anonym(myDocArray).find({'age': {'$gt': 30} });
	     *
	     * @param {Array} docs - document array to initialize the anonymous collection with
	     * @param {Array} indexesArray - (Optional) array of property names to index
	     * @returns {Collection} New collection which you can query or chain
	     */
	    Loki.prototype.anonym = function (docs, indexesArray) {
	      var collection = new Collection('anonym', indexesArray);
	      collection.insert(docs);
	      return collection;
	    };

	    Loki.prototype.addCollection = function (name, options) {
	      var collection = new Collection(name, options);
	      this.collections.push(collection);

	      return collection;
	    };

	    Loki.prototype.loadCollection = function (collection) {
	      if (!collection.name) {
	        throw new Error('Collection must be have a name property to be loaded');
	      }
	      this.collections.push(collection);
	    };

	    Loki.prototype.getCollection = function (collectionName) {
	      var i,
	        len = this.collections.length;

	      for (i = 0; i < len; i += 1) {
	        if (this.collections[i].name === collectionName) {
	          return this.collections[i];
	        }
	      }

	      // no such collection
	      this.emit('warning', 'collection ' + collectionName + ' not found');
	      return null;
	    };

	    Loki.prototype.listCollections = function () {

	      var i = this.collections.length,
	        colls = [];

	      while (i--) {
	        colls.push({
	          name: this.collections[i].name,
	          type: this.collections[i].objType,
	          count: this.collections[i].data.length
	        });
	      }
	      return colls;
	    };

	    Loki.prototype.removeCollection = function (collectionName) {
	      var i,
	        len = this.collections.length;

	      for (i = 0; i < len; i += 1) {
	        if (this.collections[i].name === collectionName) {
	          this.collections.splice(i, 1);
	          return;
	        }
	      }
	    };

	    Loki.prototype.getName = function () {
	      return this.name;
	    };

	    /**
	     * serializeReplacer - used to prevent certain properties from being serialized
	     *
	     */
	    Loki.prototype.serializeReplacer = function (key, value) {
	      switch (key) {
	      case 'autosaveHandle':
	        return null;
	      case 'persistenceAdapter':
	        return null;
	      default:
	        return value;
	      }
	    };

	    // toJson
	    Loki.prototype.serialize = function () {
	      return JSON.stringify(this, this.serializeReplacer);
	    };
	    // alias of serialize
	    Loki.prototype.toJson = Loki.prototype.serialize;

	    /**
	     * loadJSON - inflates a loki database from a serialized JSON string
	     *
	     * @param {string} serializedDb - a serialized loki database string
	     * @param {object} options - apply or override collection level settings
	     */
	    Loki.prototype.loadJSON = function (serializedDb, options) {

	      var obj = JSON.parse(serializedDb),
	        i = 0,
	        len = obj.collections.length,
	        coll,
	        copyColl,
	        clen,
	        j;

	      this.name = obj.name;

	      // restore database version
	      this.databaseVersion = 1.0;
	      if (obj.hasOwnProperty('databaseVersion')) {
	        this.databaseVersion = obj.databaseVersion;
	      }

	      this.collections = [];

	      for (i; i < len; i += 1) {
	        coll = obj.collections[i];
	        copyColl = this.addCollection(coll.name);

	        // load each element individually
	        clen = coll.data.length;
	        j = 0;
	        if (options && options.hasOwnProperty(coll.name)) {

	          var loader = options[coll.name].inflate ? options[coll.name].inflate : Utils.copyProperties;

	          for (j; j < clen; j++) {
	            var collObj = new(options[coll.name].proto)();
	            loader(coll.data[j], collObj);
	            copyColl.data[j] = collObj;

	          }
	        } else {

	          for (j; j < clen; j++) {
	            copyColl.data[j] = coll.data[j];
	          }
	        }

	        copyColl.transactional = coll.transactional;
	        copyColl.asyncListeners = coll.asyncListeners;
	        copyColl.disableChangesApi = coll.disableChangesApi;
	        copyColl.cloneObjects = coll.cloneObjects;

	        copyColl.maxId = (coll.data.length === 0) ? 0 : coll.maxId;
	        copyColl.idIndex = coll.idIndex;
	        // if saved in previous format recover id index out of it
	        if (typeof (coll.indices) !== 'undefined') {
	          copyColl.idIndex = coll.indices.id;
	        }
	        if (typeof (coll.binaryIndices) !== 'undefined') {
	          copyColl.binaryIndices = coll.binaryIndices;
	        }


	        copyColl.ensureId();

	        // in case they are loading a database created before we added dynamic views, handle undefined
	        if (typeof (coll.DynamicViews) === 'undefined') continue;

	        // reinflate DynamicViews and attached Resultsets
	        for (var idx = 0; idx < coll.DynamicViews.length; idx++) {
	          var colldv = coll.DynamicViews[idx];

	          var dv = copyColl.addDynamicView(colldv.name, colldv.persistent);
	          dv.resultdata = colldv.resultdata;
	          dv.resultsdirty = colldv.resultsdirty;
	          dv.filterPipeline = colldv.filterPipeline;

	          dv.sortCriteria = colldv.sortCriteria;
	          dv.sortFunction = null;

	          dv.sortDirty = colldv.sortDirty;
	          dv.resultset.filteredrows = colldv.resultset.filteredrows;
	          dv.resultset.searchIsChained = colldv.resultset.searchIsChained;
	          dv.resultset.filterInitialized = colldv.resultset.filterInitialized;

	          dv.rematerialize({
	            removeWhereFilters: true
	          });
	        }
	      }
	    };

	    /**
	     * close(callback) - emits the close event with an optional callback. Does not actually destroy the db
	     * but useful from an API perspective
	     */
	    Loki.prototype.close = function (callback) {
	      // for autosave scenarios, we will let close perform final save (if dirty)
	      // For web use, you might call from window.onbeforeunload to shutdown database, saving pending changes
	      if (this.autosave) {
	        this.autosaveDisable();
	        if (this.autosaveDirty()) {
	          this.saveDatabase();
	        }
	      }

	      if (callback) {
	        this.on('close', callback);
	      }
	      this.emit('close');
	    };

	    /**-------------------------+
	    | Changes API               |
	    +--------------------------*/

	    /**
	     * The Changes API enables the tracking the changes occurred in the collections since the beginning of the session,
	     * so it's possible to create a differential dataset for synchronization purposes (possibly to a remote db)
	     */

	    /**
	     * generateChangesNotification() - takes all the changes stored in each
	     * collection and creates a single array for the entire database. If an array of names
	     * of collections is passed then only the included collections will be tracked.
	     *
	     * @param {array} optional array of collection names. No arg means all collections are processed.
	     * @returns {array} array of changes
	     * @see private method createChange() in Collection
	     */
	    Loki.prototype.generateChangesNotification = function (arrayOfCollectionNames) {
	      function getCollName(coll) {
	        return coll.name;
	      }
	      var changes = [],
	        selectedCollections = arrayOfCollectionNames || this.collections.map(getCollName);

	      this.collections.forEach(function (coll) {
	        if (selectedCollections.indexOf(getCollName(coll)) !== -1) {
	          changes = changes.concat(coll.getChanges());
	        }
	      });
	      return changes;
	    };

	    /**
	     * serializeChanges() - stringify changes for network transmission
	     * @returns {string} string representation of the changes
	     */
	    Loki.prototype.serializeChanges = function (collectionNamesArray) {
	      return JSON.stringify(this.generateChangesNotification(collectionNamesArray));
	    };

	    /**
	     * clearChanges() - clears all the changes in all collections.
	     */
	    Loki.prototype.clearChanges = function () {
	      this.collections.forEach(function (coll) {
	        if (coll.flushChanges) {
	          coll.flushChanges();
	        }
	      });
	    };

	    /*------------------+
	    | PERSISTENCE       |
	    -------------------*/


	    /** there are two build in persistence adapters for internal use
	     * fs             for use in Nodejs type environments
	     * localStorage   for use in browser environment
	     * defined as helper classes here so its easy and clean to use
	     */

	    /**
	     * constructor for fs
	     */
	    function LokiFsAdapter() {
	      this.fs = __webpack_require__(42);
	    }

	    /**
	     * loadDatabase() - Load data from file, will throw an error if the file does not exist
	     * @param {string} dbname - the filename of the database to load
	     * @param {function} callback - the callback to handle the result
	     */
	    LokiFsAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
	      this.fs.readFile(dbname, {
	        encoding: 'utf8'
	      }, function readFileCallback(err, data) {
	        if (err) {
	          callback(new Error(err));
	        } else {
	          callback(data);
	        }
	      });
	    };

	    /**
	     * saveDatabase() - save data to file, will throw an error if the file can't be saved
	     * might want to expand this to avoid dataloss on partial save
	     * @param {string} dbname - the filename of the database to load
	     * @param {function} callback - the callback to handle the result
	     */
	    LokiFsAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
	      this.fs.writeFile(dbname, dbstring, callback);
	    };


	    /**
	     * constructor for local storage
	     */
	    function LokiLocalStorageAdapter() {}

	    /**
	     * loadDatabase() - Load data from localstorage
	     * @param {string} dbname - the name of the database to load
	     * @param {function} callback - the callback to handle the result
	     */
	    LokiLocalStorageAdapter.prototype.loadDatabase = function loadDatabase(dbname, callback) {
	      if (localStorageAvailable()) {
	        callback(localStorage.getItem(dbname));
	      } else {
	        callback(new Error('localStorage is not available'));
	      }
	    };

	    /**
	     * saveDatabase() - save data to localstorage, will throw an error if the file can't be saved
	     * might want to expand this to avoid dataloss on partial save
	     * @param {string} dbname - the filename of the database to load
	     * @param {function} callback - the callback to handle the result
	     */
	    LokiLocalStorageAdapter.prototype.saveDatabase = function saveDatabase(dbname, dbstring, callback) {
	      if (localStorageAvailable()) {
	        localStorage.setItem(dbname, dbstring);
	        callback(null);
	      } else {
	        callback(new Error('localStorage is not available'));
	      }
	    };

	    /**
	     * loadDatabase - Handles loading from file system, local storage, or adapter (indexeddb)
	     *    This method utilizes loki configuration options (if provided) to determine which
	     *    persistence method to use, or environment detection (if configuration was not provided).
	     *
	     * @param {object} options - not currently used (remove or allow overrides?)
	     * @param {function} callback - (Optional) user supplied async callback / error handler
	     */
	    Loki.prototype.loadDatabase = function (options, callback) {
	      var cFun = callback || function (err, data) {
	          if (err) {
	            throw err;
	          }
	          return;
	        },
	        self = this;

	      // the persistenceAdapter should be present if all is ok, but check to be sure.
	      if (this.persistenceAdapter !== null) {

	        this.persistenceAdapter.loadDatabase(this.filename, function loadDatabaseCallback(dbString) {
	          if (typeof (dbString) === 'string') {
	            self.loadJSON(dbString, options || {});
	            cFun(null);
	          } else {
	            console.warn('lokijs loadDatabase : Database not found');
	            if (typeof (dbString) === "object") {
	              cFun(dbString);
	            } else {
	              cFun('Database not found');
	            }
	          }
	        });

	      } else {
	        cFun(new Error('persistenceAdapter not configured'));
	      }
	    };

	    /**
	     * saveDatabase - Handles saving to file system, local storage, or adapter (indexeddb)
	     *    This method utilizes loki configuration options (if provided) to determine which
	     *    persistence method to use, or environment detection (if configuration was not provided).
	     *
	     * @param {object} options - not currently used (remove or allow overrides?)
	     * @param {function} callback - (Optional) user supplied async callback / error handler
	     */
	    Loki.prototype.saveDatabase = function (callback) {
	      var cFun = callback || function (err) {
	          if (err) {
	            throw err;
	          }
	          return;
	        },
	        self = this;

	      // the persistenceAdapter should be present if all is ok, but check to be sure.
	      if (this.persistenceAdapter !== null) {
	        this.persistenceAdapter.saveDatabase(this.filename, self.serialize(), function saveDatabasecallback() {
	          // for now assume that save went ok and reset dirty flags
	          // in future we may move this into each if block if no exceptions occur.
	          self.autosaveClearFlags();
	          cFun(null);
	        });
	      } else {
	        cFun(new Error('persistenceAdapter not configured'));
	      }

	    };

	    // alias
	    Loki.prototype.save = Loki.prototype.saveDatabase;

	    /**
	     * autosaveDirty - check whether any collections are 'dirty' meaning we need to save (entire) database
	     *
	     * @returns {boolean} - true if database has changed since last autosave, false if not.
	     */
	    Loki.prototype.autosaveDirty = function () {
	      for (var idx = 0; idx < this.collections.length; idx++) {
	        if (this.collections[idx].dirty) {
	          return true;
	        }
	      }

	      return false;
	    };

	    /**
	     * autosaveClearFlags - resets dirty flags on all collections.
	     *    Called from saveDatabase() after db is saved.
	     *
	     */
	    Loki.prototype.autosaveClearFlags = function () {
	      for (var idx = 0; idx < this.collections.length; idx++) {
	        this.collections[idx].dirty = false;
	      }
	    };

	    /**
	     * autosaveEnable - begin a javascript interval to periodically save the database.
	     *
	     */
	    Loki.prototype.autosaveEnable = function () {
	      this.autosave = true;

	      var delay = 5000,
	        self = this;

	      if (typeof (this.autosaveInterval) !== 'undefined' && this.autosaveInterval !== null) {
	        delay = this.autosaveInterval;
	      }

	      this.autosaveHandle = setInterval(function autosaveHandleInterval() {
	        // use of dirty flag will need to be hierarchical since mods are done at collection level with no visibility of 'db'
	        // so next step will be to implement collection level dirty flags set on insert/update/remove
	        // along with loki level isdirty() function which iterates all collections to see if any are dirty

	        if (self.autosaveDirty()) {
	          self.saveDatabase();
	        }
	      }, delay);
	    };

	    /**
	     * autosaveDisable - stop the autosave interval timer.
	     *
	     */
	    Loki.prototype.autosaveDisable = function () {
	      if (typeof (this.autosaveHandle) !== 'undefined' && this.autosaveHandle !== null) {
	        clearInterval(this.autosaveHandle);
	        this.autosaveHandle = null;
	      }
	    };


	    /**
	     * Resultset class allowing chainable queries.  Intended to be instanced internally.
	     *    Collection.find(), Collection.where(), and Collection.chain() instantiate this.
	     *
	     *    Example:
	     *    mycollection.chain()
	     *      .find({ 'doors' : 4 })
	     *      .where(function(obj) { return obj.name === 'Toyota' })
	     *      .data();
	     *
	     * @constructor
	     * @param {Collection} collection - The collection which this Resultset will query against.
	     * @param {string} queryObj - Optional mongo-style query object to initialize resultset with.
	     * @param {function} queryFunc - Optional javascript filter function to initialize resultset with.
	     * @param {bool} firstOnly - Optional boolean used by collection.findOne().
	     */
	    function Resultset(collection, queryObj, queryFunc, firstOnly) {
	      // retain reference to collection we are querying against
	      this.collection = collection;

	      // if chain() instantiates with null queryObj and queryFunc, so we will keep flag for later
	      this.searchIsChained = (!queryObj && !queryFunc);
	      this.filteredrows = [];
	      this.filterInitialized = false;

	      // if user supplied initial queryObj or queryFunc, apply it
	      if (typeof (queryObj) !== "undefined" && queryObj !== null) {
	        return this.find(queryObj, firstOnly);
	      }
	      if (typeof (queryFunc) !== "undefined" && queryFunc !== null) {
	        return this.where(queryFunc);
	      }

	      // otherwise return unfiltered Resultset for future filtering
	      return this;
	    }

	    /**
	     * toJSON() - Override of toJSON to avoid circular references
	     *
	     */
	    Resultset.prototype.toJSON = function () {
	      var copy = this.copy();
	      copy.collection = null;
	      return copy;
	    };

	    /**
	     * limit() - Allows you to limit the number of documents passed to next chain operation.
	     *    A resultset copy() is made to avoid altering original resultset.
	     *
	     * @param {int} qty - The number of documents to return.
	     * @returns {Resultset} Returns a copy of the resultset, limited by qty, for subsequent chain ops.
	     */
	    Resultset.prototype.limit = function (qty) {
	      // if this is chained resultset with no filters applied, we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      var rscopy = this.copy();

	      rscopy.filteredrows = rscopy.filteredrows.slice(0, qty);

	      return rscopy;
	    };

	    /**
	     * offset() - Used for skipping 'pos' number of documents in the resultset.
	     *
	     * @param {int} pos - Number of documents to skip; all preceding documents are filtered out.
	     * @returns {Resultset} Returns a copy of the resultset, containing docs starting at 'pos' for subsequent chain ops.
	     */
	    Resultset.prototype.offset = function (pos) {
	      // if this is chained resultset with no filters applied, we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      var rscopy = this.copy();

	      rscopy.filteredrows = rscopy.filteredrows.splice(pos, rscopy.filteredrows.length);

	      return rscopy;
	    };

	    /**
	     * copy() - To support reuse of resultset in branched query situations.
	     *
	     * @returns {Resultset} Returns a copy of the resultset (set) but the underlying document references will be the same.
	     */
	    Resultset.prototype.copy = function () {
	      var result = new Resultset(this.collection, null, null);

	      result.filteredrows = this.filteredrows.slice();
	      result.filterInitialized = this.filterInitialized;

	      return result;
	    };

	    // add branch() as alias of copy()
	    Resultset.prototype.branch = Resultset.prototype.copy;

	    /**
	     * sort() - User supplied compare function is provided two documents to compare. (chainable)
	     *    Example:
	     *    rslt.sort(function(obj1, obj2) {
	     *      if (obj1.name === obj2.name) return 0;
	     *      if (obj1.name > obj2.name) return 1;
	     *      if (obj1.name < obj2.name) return -1;
	     *    });
	     *
	     * @param {function} comparefun - A javascript compare function used for sorting.
	     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
	     */
	    Resultset.prototype.sort = function (comparefun) {
	      // if this is chained resultset with no filters applied, just we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      var wrappedComparer =
	        (function (userComparer, rslt) {
	          return function (a, b) {
	            var obj1 = rslt.collection.data[a];
	            var obj2 = rslt.collection.data[b];

	            return userComparer(obj1, obj2);
	          };
	        })(comparefun, this);

	      this.filteredrows.sort(wrappedComparer);

	      return this;
	    };

	    /**
	     * simplesort() - Simpler, loose evaluation for user to sort based on a property name. (chainable)
	     *
	     * @param {string} propname - name of property to sort by.
	     * @param {bool} isdesc - (Optional) If true, the property will be sorted in descending order
	     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
	     */
	    Resultset.prototype.simplesort = function (propname, isdesc) {
	      // if this is chained resultset with no filters applied, just we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      if (typeof (isdesc) === 'undefined') {
	        isdesc = false;
	      }

	      var wrappedComparer =
	        (function (prop, desc, rslt) {
	          return function (a, b) {
	            var obj1 = rslt.collection.data[a];
	            var obj2 = rslt.collection.data[b];

	            return sortHelper(obj1[prop], obj2[prop], desc);

	          };
	        })(propname, isdesc, this);

	      this.filteredrows.sort(wrappedComparer);

	      return this;
	    };

	    /**
	     * compoundeval() - helper method for compoundsort(), performing individual object comparisons
	     *
	     * @param {array} properties - array of property names, in order, by which to evaluate sort order
	     * @param {object} obj1 - first object to compare
	     * @param {object} obj2 - second object to compare
	     * @returns {integer} 0, -1, or 1 to designate if identical (sortwise) or which should be first
	     */
	    Resultset.prototype.compoundeval = function (properties, obj1, obj2) {
	      var propertyCount = properties.length;

	      if (propertyCount === 0) {
	        throw new Error("Invalid call to compoundeval, need at least one property");
	      }

	      // decode property, whether just a string property name or subarray [propname, isdesc]
	      var isdesc = false;
	      var firstProp = properties[0];
	      if (typeof (firstProp) !== 'string') {
	        if (Array.isArray(firstProp)) {
	          isdesc = firstProp[1];
	          firstProp = firstProp[0];
	        }
	      }

	      if (obj1[firstProp] === obj2[firstProp]) {
	        if (propertyCount === 1) {
	          return 0;
	        } else {
	          return this.compoundeval(properties.slice(1), obj1, obj2, isdesc);
	        }
	      }

	      return sortHelper(obj1[firstProp], obj2[firstProp], isdesc);
	    };

	    /**
	     * compoundsort() - Allows sorting a resultset based on multiple columns.
	     *    Example : rs.compoundsort(['age', 'name']); to sort by age and then name (both ascending)
	     *    Example : rs.compoundsort(['age', ['name', true]); to sort by age (ascending) and then by name (descending)
	     *
	     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
	     * @returns {Resultset} Reference to this resultset, sorted, for future chain operations.
	     */
	    Resultset.prototype.compoundsort = function (properties) {

	      // if this is chained resultset with no filters applied, just we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      var wrappedComparer =
	        (function (props, rslt) {
	          return function (a, b) {
	            var obj1 = rslt.collection.data[a];
	            var obj2 = rslt.collection.data[b];

	            return rslt.compoundeval(props, obj1, obj2);
	          };
	        })(properties, this);

	      this.filteredrows.sort(wrappedComparer);

	      return this;
	    };

	    /**
	     * calculateRange() - Binary Search utility method to find range/segment of values matching criteria.
	     *    this is used for collection.find() and first find filter of resultset/dynview
	     *    slightly different than get() binary search in that get() hones in on 1 value,
	     *    but we have to hone in on many (range)
	     * @param {string} op - operation, such as $eq
	     * @param {string} prop - name of property to calculate range for
	     * @param {object} val - value to use for range calculation.
	     * @returns {array} [start, end] index array positions
	     */
	    Resultset.prototype.calculateRange = function (op, prop, val) {
	      var rcd = this.collection.data;
	      var index = this.collection.binaryIndices[prop].values;
	      var min = 0;
	      var max = index.length - 1;
	      var mid = null;
	      var lbound = 0;
	      var ubound = index.length - 1;

	      // when no documents are in collection, return empty range condition
	      if (rcd.length === 0) {
	        return [0, -1];
	      }

	      var minVal = rcd[index[min]][prop];
	      var maxVal = rcd[index[max]][prop];

	      // if value falls outside of our range return [0, -1] to designate no results
	      switch (op) {
	      case '$eq':
	        if (ltHelper(val, minVal) || gtHelper(val, maxVal)) {
	          return [0, -1];
	        }
	        break;
	      case '$gt':
	        if (gtHelper(val, maxVal, true)) {
	          return [0, -1];
	        }
	        break;
	      case '$gte':
	        if (gtHelper(val, maxVal)) {
	          return [0, -1];
	        }
	        break;
	      case '$lt':
	        if (ltHelper(val, minVal, true)) {
	          return [0, -1];
	        }
	        break;
	      case '$lte':
	        if (ltHelper(val, minVal)) {
	          return [0, -1];
	        }
	        break;
	      }

	      // hone in on start position of value
	      while (min < max) {
	        mid = Math.floor((min + max) / 2);

	        if (ltHelper(rcd[index[mid]][prop], val)) {
	          min = mid + 1;
	        } else {
	          max = mid;
	        }
	      }

	      lbound = min;

	      min = 0;
	      max = index.length - 1;

	      // hone in on end position of value
	      while (min < max) {
	        mid = Math.floor((min + max) / 2);

	        if (ltHelper(val, rcd[index[mid]][prop])) {
	          max = mid;
	        } else {
	          min = mid + 1;
	        }
	      }

	      ubound = max;

	      var lval = rcd[index[lbound]][prop];
	      var uval = rcd[index[ubound]][prop];

	      switch (op) {
	      case '$eq':
	        if (lval !== val) {
	          return [0, -1];
	        }
	        if (uval !== val) {
	          ubound--;
	        }

	        return [lbound, ubound];

	      case '$gt':
	        if (ltHelper(uval, val, true)) {
	          return [0, -1];
	        }

	        return [ubound, rcd.length - 1];

	      case '$gte':
	        if (ltHelper(lval, val)) {
	          return [0, -1];
	        }

	        return [lbound, rcd.length - 1];

	      case '$lt':
	        if (lbound === 0 && ltHelper(lval, val)) {
	          return [0, 0];
	        }
	        return [0, lbound - 1];

	      case '$lte':
	        if (uval !== val) {
	          ubound--;
	        }

	        if (ubound === 0 && ltHelper(uval, val)) {
	          return [0, 0];
	        }
	        return [0, ubound];

	      default:
	        return [0, rcd.length - 1];
	      }
	    };

	    /**
	     * findOr() - oversee the operation of OR'ed query expressions.
	     *    OR'ed expression evaluation runs each expression individually against the full collection,
	     *    and finally does a set OR on each expression's results.
	     *    Each evaluation can utilize a binary index to prevent multiple linear array scans.
	     *
	     * @param {array} expressionArray - array of expressions
	     * @returns {Resultset} this resultset for further chain ops.
	     */
	    Resultset.prototype.findOr = function (expressionArray) {
	      var fri = 0,
	        ei = 0,
	        fr = null,
	        docset = [],
	        expResultset = null;

	      // if filter is already initialized we need to query against only those items already in filter.
	      // This means no index utilization for fields, so hopefully its filtered to a smallish filteredrows.
	      if (this.filterInitialized) {
	        docset = [];

	        for (ei = 0; ei < expressionArray.length; ei++) {
	          // we need to branch existing query to run each filter separately and combine results
	          expResultset = this.branch();
	          expResultset.find(expressionArray[ei]);
	          expResultset.data();

	          // add any document 'hits'
	          fr = expResultset.filteredrows;
	          for (fri = 0; fri < fr.length; fri++) {
	            if (docset.indexOf(fr[fri]) === -1) {
	              docset.push(fr[fri]);
	            }
	          }
	        }

	        this.filteredrows = docset;
	      } else {
	        for (ei = 0; ei < expressionArray.length; ei++) {
	          // we will let each filter run independently against full collection and mashup document hits later
	          expResultset = this.collection.chain();
	          expResultset.find(expressionArray[ei]);
	          expResultset.data();

	          // add any document 'hits'
	          fr = expResultset.filteredrows;
	          for (fri = 0; fri < fr.length; fri++) {
	            if (this.filteredrows.indexOf(fr[fri]) === -1) {
	              this.filteredrows.push(fr[fri]);
	            }
	          }
	        }
	      }

	      this.filterInitialized = true;

	      // possibly sort indexes
	      return this;
	    };

	    /**
	     * findAnd() - oversee the operation of AND'ed query expressions.
	     *    AND'ed expression evaluation runs each expression progressively against the full collection,
	     *    internally utilizing existing chained resultset functionality.
	     *    Only the first filter can utilize a binary index.
	     *
	     * @param {array} expressionArray - array of expressions
	     * @returns {Resultset} this resultset for further chain ops.
	     */
	    Resultset.prototype.findAnd = function (expressionArray) {
	      // we have already implementing method chaining in this (our Resultset class)
	      // so lets just progressively apply user supplied and filters
	      for (var i = 0; i < expressionArray.length; i++) {
	        this.find(expressionArray[i]);
	      }

	      return this;
	    };

	    /**
	     * dotSubScan - helper function used for dot notation queries.
	     */
	    Resultset.prototype.dotSubScan = function (root, property, fun, value) {
	      var arrayRef = null;
	      var pathIndex, subIndex;
	      var paths = property.split('.');
	      var path;

	      for (pathIndex = 0; pathIndex < paths.length; pathIndex++) {
	        path = paths[pathIndex];

	        // foreach already detected parent was array so this must be where we iterate
	        if (arrayRef) {
	          // iterate all sub-array items to see if any yield hits
	          for (subIndex = 0; subIndex < arrayRef.length; subIndex++) {
	            if (fun(arrayRef[subIndex][path], value)) {
	              return true;
	            }
	          }
	        }
	        // else not yet determined if subarray scan is involved
	        else {
	          root = root[path];
	          if (Array.isArray(root)) {
	            arrayRef = root;
	          }
	        }
	      }

	      // made it this far so must be dot notation on non-array property
	      return fun(root, value);
	    };

	    /**
	     * find() - Used for querying via a mongo-style query object.
	     *
	     * @param {object} query - A mongo-style query object used for filtering current results.
	     * @param {boolean} firstOnly - (Optional) Used by collection.findOne()
	     * @returns {Resultset} this resultset for further chain ops.
	     */
	    Resultset.prototype.find = function (query, firstOnly) {
	      if (this.collection.data.length === 0) {
	        if (this.searchIsChained) {
	          this.filteredrows = [];
	          this.filterInitialized = true;
	          return this;
	        }
	        return [];
	      }


	      var queryObject = query || 'getAll',
	        property,
	        value,
	        operator,
	        p,
	        key,
	        searchByIndex = false,
	        result = [],
	        index = null,
	        // comparison function
	        fun,
	        // collection data
	        t,
	        // collection data length
	        i,
	        emptyQO = true;

	      // if this was note invoked via findOne()
	      firstOnly = firstOnly || false;

	      // if passed in empty object {}, interpret as 'getAll'
	      // more performant than object.keys
	      for (p in queryObject) {
	        emptyQO = false;
	        break;
	      }
	      if (emptyQO) {
	        queryObject = 'getAll';
	      }

	      // apply no filters if they want all
	      if (queryObject === 'getAll') {
	        // chained queries can just do coll.chain().data() but let's
	        // be versatile and allow this also coll.chain().find().data()
	        if (this.searchIsChained) {
	          this.filteredrows = Object.keys(this.collection.data);
	          return this;
	        }
	        // not chained, so return collection data array
	        else {
	          return this.collection.data;
	        }
	      }

	      // if user is deep querying the object such as find('name.first': 'odin')
	      var usingDotNotation = false;

	      for (p in queryObject) {
	        if (queryObject.hasOwnProperty(p)) {
	          property = p;

	          // injecting $and and $or expression tree evaluation here.
	          if (p === '$and') {
	            if (this.searchIsChained) {
	              this.findAnd(queryObject[p]);

	              // for chained find with firstonly,
	              if (firstOnly && this.filteredrows.length > 1) {
	                this.filteredrows = this.filteredrows.slice(0, 1);
	              }

	              return this;
	            } else {
	              // our $and operation internally chains filters
	              result = this.collection.chain().findAnd(queryObject[p]).data();

	              // if this was coll.findOne() return first object or empty array if null
	              // since this is invoked from a constructor we can't return null, so we will
	              // make null in coll.findOne();
	              if (firstOnly) {
	                if (result.length === 0) return [];

	                return result[0];
	              }

	              // not first only return all results
	              return result;
	            }
	          }

	          if (p === '$or') {
	            if (this.searchIsChained) {
	              this.findOr(queryObject[p]);

	              if (firstOnly && this.filteredrows.length > 1) {
	                this.filteredrows = this.filteredrows.slice(0, 1);
	              }

	              return this;
	            } else {
	              // call out to helper function to determine $or results
	              result = this.collection.chain().findOr(queryObject[p]).data();

	              if (firstOnly) {
	                if (result.length === 0) return [];

	                return result[0];
	              }

	              // not first only return all results
	              return result;
	            }
	          }

	          if (p.indexOf('.') != -1) {
	            usingDotNotation = true;
	          }
	          if (typeof queryObject[p] !== 'object') {
	            operator = '$eq';
	            value = queryObject[p];
	          } else if (typeof queryObject[p] === 'object') {
	            for (key in queryObject[p]) {
	              if (queryObject[p].hasOwnProperty(key)) {
	                operator = key;
	                value = queryObject[p][key];
	              }
	            }
	          } else {
	            throw 'Do not know what you want to do.';
	          }
	          break;
	        }
	      }

	      // for regex ops, precompile
	      if (operator === '$regex') value = new RegExp(value);

	      if (this.collection.data === null) {
	        throw new TypeError();
	      }

	      // if an index exists for the property being queried against, use it
	      // for now only enabling for non-chained query (who's set of docs matches index)
	      // or chained queries where it is the first filter applied and prop is indexed
	      if ((!this.searchIsChained || (this.searchIsChained && !this.filterInitialized)) &&
	        operator !== '$ne' && operator !== '$regex' && operator !== '$contains' && operator !== '$containsAny' && operator !== '$in' && this.collection.binaryIndices.hasOwnProperty(property)) {
	        // this is where our lazy index rebuilding will take place
	        // basically we will leave all indexes dirty until we need them
	        // so here we will rebuild only the index tied to this property
	        // ensureIndex() will only rebuild if flagged as dirty since we are not passing force=true param
	        this.collection.ensureIndex(property);

	        searchByIndex = true;
	        index = this.collection.binaryIndices[property];
	      }

	      // the comparison function
	      fun = operators[operator];

	      // Query executed differently depending on :
	      //    - whether it is chained or not
	      //    - whether the property being queried has an index defined
	      //    - if chained, we handle first pass differently for initial filteredrows[] population
	      //
	      // For performance reasons, each case has its own if block to minimize in-loop calculations

	      // If not a chained query, bypass filteredrows and work directly against data
	      if (!this.searchIsChained) {
	        if (!searchByIndex) {
	          t = this.collection.data;
	          i = t.length;

	          if (firstOnly) {
	            while (i--) {
	              if (fun(t[i][property], value)) {
	                return (t[i]);
	              }
	            }

	            return [];
	          } else {
	            // if using dot notation then treat property as keypath such as 'name.first'.
	            // currently supporting dot notation for non-indexed conditions only
	            if (usingDotNotation) {
	              while (i--) {
	                if (this.dotSubScan(t[i], property, fun, value)) {
	                  result.push(t[i]);
	                }
	              }
	            } else {
	              while (i--) {
	                if (fun(t[i][property], value)) {
	                  result.push(t[i]);
	                }
	              }
	            }
	          }
	        } else {
	          // searching by binary index via calculateRange() utility method
	          t = this.collection.data;

	          var seg = this.calculateRange(operator, property, value, this);

	          // not chained so this 'find' was designated in Resultset constructor
	          // so return object itself
	          if (firstOnly) {
	            if (seg[1] !== -1) {
	              return t[index.values[seg[0]]];
	            }

	            return [];
	          }

	          for (i = seg[0]; i <= seg[1]; i++) {
	            result.push(t[index.values[i]]);
	          }

	          this.filteredrows = result;
	        }

	        // not a chained query so return result as data[]
	        return result;
	      }
	      // Otherwise this is a chained query
	      else {
	        // If the filteredrows[] is already initialized, use it
	        if (this.filterInitialized) {
	          // not searching by index
	          if (!searchByIndex) {
	            t = this.collection.data;
	            i = this.filteredrows.length;

	            // currently supporting dot notation for non-indexed conditions only
	            if (usingDotNotation) {
	              while (i--) {
	                if (this.dotSubScan(t[this.filteredrows[i]], property, fun, value)) {
	                  result.push(this.filteredrows[i]);
	                }
	              }
	            } else {
	              while (i--) {
	                if (fun(t[this.filteredrows[i]][property], value)) {
	                  result.push(this.filteredrows[i]);
	                }
	              }
	            }
	          } else {
	            // search by index
	            t = index;
	            i = this.filteredrows.length;
	            while (i--) {
	              if (fun(t[this.filteredrows[i]], value)) {
	                result.push(this.filteredrows[i]);
	              }
	            }
	          }

	          this.filteredrows = result;

	          return this;
	        }
	        // first chained query so work against data[] but put results in filteredrows
	        else {
	          // if not searching by index
	          if (!searchByIndex) {
	            t = this.collection.data;
	            i = t.length;

	            if (usingDotNotation) {
	              while (i--) {
	                if (this.dotSubScan(t[i], property, fun, value)) {
	                  result.push(i);
	                }
	              }
	            } else {
	              while (i--) {
	                if (fun(t[i][property], value)) {
	                  result.push(i);
	                }
	              }
	            }
	          } else {
	            // search by index
	            t = this.collection.data;
	            var seg = this.calculateRange(operator, property, value, this);

	            for (var idx = seg[0]; idx <= seg[1]; idx++) {
	              result.push(index.values[idx]);
	            }

	            this.filteredrows = result;
	          }

	          this.filteredrows = result;
	          this.filterInitialized = true; // next time work against filteredrows[]

	          return this;
	        }

	      }
	    };


	    /**
	     * where() - Used for filtering via a javascript filter function.
	     *
	     * @param {function} fun - A javascript function used for filtering current results by.
	     * @returns {Resultset} this resultset for further chain ops.
	     */
	    Resultset.prototype.where = function (fun) {

	      var viewFunction,
	        result = [];

	      if ('function' === typeof fun) {
	        viewFunction = fun;
	      } else {
	        throw 'Argument is not a stored view or a function';
	      }
	      try {
	        // if not a chained query then run directly against data[] and return object []
	        if (!this.searchIsChained) {
	          var i = this.collection.data.length;

	          while (i--) {
	            if (viewFunction(this.collection.data[i]) === true) {
	              result.push(this.collection.data[i]);
	            }
	          }

	          // not a chained query so returning result as data[]
	          return result;
	        }
	        // else chained query, so run against filteredrows
	        else {
	          // If the filteredrows[] is already initialized, use it
	          if (this.filterInitialized) {
	            var i = this.filteredrows.length;

	            while (i--) {
	              if (viewFunction(this.collection.data[this.filteredrows[i]]) === true) {
	                result.push(this.filteredrows[i]);
	              }
	            }

	            this.filteredrows = result;

	            return this;
	          }
	          // otherwise this is initial chained op, work against data, push into filteredrows[]
	          else {
	            var i = this.collection.data.length;

	            while (i--) {
	              if (viewFunction(this.collection.data[i]) === true) {
	                result.push(i);
	              }
	            }

	            this.filteredrows = result;
	            this.filterInitialized = true;

	            return this;
	          }
	        }
	      } catch (err) {
	        throw err;
	      }
	    };

	    /**
	     * data() - Terminates the chain and returns array of filtered documents
	     *
	     * @returns {array} Array of documents in the resultset
	     */
	    Resultset.prototype.data = function () {
	      var result = [];

	      // if this is chained resultset with no filters applied, just return collection.data
	      if (this.searchIsChained && !this.filterInitialized) {
	        if (this.filteredrows.length === 0) {
	          return this.collection.data;
	        } else {
	          // filteredrows must have been set manually, so use it
	          this.filterInitialized = true;
	        }
	      }

	      var data = this.collection.data,
	        fr = this.filteredrows;

	      var i,
	        len = this.filteredrows.length;

	      for (i = 0; i < len; i++) {
	        result.push(data[fr[i]]);
	      }
	      return result;
	    };

	    /**
	     * update() - used to run an update operation on all documents currently in the resultset.
	     *
	     * @param {function} updateFunction - User supplied updateFunction(obj) will be executed for each document object.
	     * @returns {Resultset} this resultset for further chain ops.
	     */
	    Resultset.prototype.update = function (updateFunction) {

	      if (typeof (updateFunction) !== "function") {
	        throw 'Argument is not a function';
	      }

	      // if this is chained resultset with no filters applied, we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      var len = this.filteredrows.length,
	        rcd = this.collection.data;

	      for (var idx = 0; idx < len; idx++) {
	        // pass in each document object currently in resultset to user supplied updateFunction
	        updateFunction(rcd[this.filteredrows[idx]]);

	        // notify collection we have changed this object so it can update meta and allow DynamicViews to re-evaluate
	        this.collection.update(rcd[this.filteredrows[idx]]);
	      }

	      return this;
	    };

	    /**
	     * remove() - removes all document objects which are currently in resultset from collection (as well as resultset)
	     *
	     * @returns {Resultset} this (empty) resultset for further chain ops.
	     */
	    Resultset.prototype.remove = function () {

	      // if this is chained resultset with no filters applied, we need to populate filteredrows first
	      if (this.searchIsChained && !this.filterInitialized && this.filteredrows.length === 0) {
	        this.filteredrows = Object.keys(this.collection.data);
	      }

	      var len = this.filteredrows.length;

	      for (var idx = 0; idx < len; idx++) {
	        this.collection.remove(this.filteredrows[idx]);
	      }

	      this.filteredrows = [];

	      return this;
	    };

	    /**
	     * mapReduce() - data transformation via user supplied functions
	     *
	     * @param {function} mapFunction - this function accepts a single document for you to transform and return
	     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
	     * @returns The output of your reduceFunction
	     */
	    Resultset.prototype.mapReduce = function (mapFunction, reduceFunction) {
	      try {
	        return reduceFunction(this.data().map(mapFunction));
	      } catch (err) {
	        throw err;
	      }
	    };

	    /**
	     * eqJoin() - Left joining two sets of data. Join keys can be defined or calculated properties
	     * eqJoin expects the right join key values to be unique.  Otherwise left data will be joined on the last joinData object with that key
	     * @param {Array} joinData - Data array to join to.
	     * @param {String,function} leftJoinKey - Property name in this result set to join on or a function to produce a value to join on
	     * @param {String,function} rightJoinKey - Property name in the joinData to join on or a function to produce a value to join on
	     * @param {function} (optional) mapFun - A function that receives each matching pair and maps them into output objects - function(left,right){return joinedObject}
	     * @returns {Resultset} A resultset with data in the format [{left: leftObj, right: rightObj}]
	     */
	    Resultset.prototype.eqJoin = function (joinData, leftJoinKey, rightJoinKey, mapFun) {

	      var leftData = [],
	        leftDataLength,
	        rightData = [],
	        rightDataLength,
	        key,
	        result = [],
	        obj,
	        leftKeyisFunction = typeof leftJoinKey === 'function',
	        rightKeyisFunction = typeof rightJoinKey === 'function',
	        joinMap = {};

	      //get the left data
	      leftData = this.data();
	      leftDataLength = leftData.length;

	      //get the right data
	      if (joinData instanceof Resultset) {
	        rightData = joinData.data();
	      } else if (Array.isArray(joinData)) {
	        rightData = joinData;
	      } else {
	        throw new TypeError('joinData needs to be an array or result set');
	      }
	      rightDataLength = rightData.length;

	      //construct a lookup table

	      for (var i = 0; i < rightDataLength; i++) {
	        key = rightKeyisFunction ? rightJoinKey(rightData[i]) : rightData[i][rightJoinKey];
	        joinMap[key] = rightData[i];
	      }

	      if (!mapFun) {
	        mapFun = function (left, right) {
	          return {
	            left: left,
	            right: right
	          };
	        };
	      }

	      //Run map function over each object in the resultset
	      for (var i = 0; i < leftDataLength; i++) {
	        key = leftKeyisFunction ? leftJoinKey(leftData[i]) : leftData[i][leftJoinKey];
	        result.push(mapFun(leftData[i], joinMap[key] || {}));
	      }

	      //return return a new resultset with no filters
	      this.collection = new Collection('joinData');
	      this.collection.insert(result);
	      this.filteredrows = [];
	      this.filterInitialized = false;

	      return this;
	    };

	    Resultset.prototype.map = function (mapFun) {
	      var data = this.data().map(mapFun);
	      //return return a new resultset with no filters
	      this.collection = new Collection('mappedData');
	      this.collection.insert(data);
	      this.filteredrows = [];
	      this.filterInitialized = false;

	      return this;
	    };

	    /**
	     * DynamicView class is a versatile 'live' view class which can have filters and sorts applied.
	     *    Collection.addDynamicView(name) instantiates this DynamicView object and notifies it
	     *    whenever documents are add/updated/removed so it can remain up-to-date. (chainable)
	     *
	     *    Examples:
	     *    var mydv = mycollection.addDynamicView('test');  // default is non-persistent
	     *    mydv.applyWhere(function(obj) { return obj.name === 'Toyota'; });
	     *    mydv.applyFind({ 'doors' : 4 });
	     *    var results = mydv.data();
	     *
	     * @constructor
	     * @param {Collection} collection - A reference to the collection to work against
	     * @param {string} name - The name of this dynamic view
	     * @param {boolean} persistent - (Optional) If true, the results will be copied into an internal array for read efficiency or binding to.
	     */
	    function DynamicView(collection, name, persistent) {
	      this.collection = collection;
	      this.name = name;

	      this.persistent = false;
	      if (typeof (persistent) !== 'undefined') this.persistent = persistent;

	      this.resultset = new Resultset(collection);
	      this.resultdata = [];
	      this.resultsdirty = false;

	      this.cachedresultset = null;

	      // keep ordered filter pipeline
	      this.filterPipeline = [];

	      // sorting member variables
	      // we only support one active search, applied using applySort() or applySimpleSort()
	      this.sortFunction = null;
	      this.sortCriteria = null;
	      this.sortDirty = false;

	      // for now just have 1 event for when we finally rebuilt lazy view
	      // once we refactor transactions, i will tie in certain transactional events

	      this.events = {
	        'rebuild': []
	      };
	    }

	    DynamicView.prototype = new LokiEventEmitter();


	    /**
	     * rematerialize() - intended for use immediately after deserialization (loading)
	     *    This will clear out and reapply filterPipeline ops, recreating the view.
	     *    Since where filters do not persist correctly, this method allows
	     *    restoring the view to state where user can re-apply those where filters.
	     *
	     * @param {Object} options - (Optional) allows specification of 'removeWhereFilters' option
	     * @returns {DynamicView} This dynamic view for further chained ops.
	     */
	    DynamicView.prototype.rematerialize = function (options) {
	      var fpl,
	        fpi,
	        idx;

	      options = options || {};

	      this.resultdata = [];
	      this.resultsdirty = true;
	      this.resultset = new Resultset(this.collection);

	      if (this.sortFunction || this.sortCriteria) {
	        this.sortDirty = true;
	      }

	      if (options.hasOwnProperty('removeWhereFilters')) {
	        // for each view see if it had any where filters applied... since they don't
	        // serialize those functions lets remove those invalid filters
	        fpl = this.filterPipeline.length;
	        fpi = fpl;
	        while (fpi--) {
	          if (this.filterPipeline[fpi].type === 'where') {
	            if (fpi !== this.filterPipeline.length - 1) {
	              this.filterPipeline[fpi] = this.filterPipeline[this.filterPipeline.length - 1];
	            }

	            this.filterPipeline.length--;
	          }
	        }
	      }

	      // back up old filter pipeline, clear filter pipeline, and reapply pipeline ops
	      var ofp = this.filterPipeline;
	      this.filterPipeline = [];

	      // now re-apply 'find' filterPipeline ops
	      fpl = ofp.length;
	      for (idx = 0; idx < fpl; idx++) {
	        this.applyFind(ofp[idx].val);
	      }

	      // during creation of unit tests, i will remove this forced refresh and leave lazy
	      this.data();

	      // emit rebuild event in case user wants to be notified
	      this.emit('rebuild', this);

	      return this;
	    };

	    /**
	     * branchResultset() - Makes a copy of the internal resultset for branched queries.
	     *    Unlike this dynamic view, the branched resultset will not be 'live' updated,
	     *    so your branched query should be immediately resolved and not held for future evaluation.
	     *
	     * @returns {Resultset} A copy of the internal resultset for branched queries.
	     */
	    DynamicView.prototype.branchResultset = function () {
	      return this.resultset.copy();
	    };

	    /**
	     * toJSON() - Override of toJSON to avoid circular references
	     *
	     */
	    DynamicView.prototype.toJSON = function () {
	      var copy = new DynamicView(this.collection, this.name, this.persistent);

	      copy.resultset = this.resultset;
	      copy.resultdata = []; // let's not save data (copy) to minimize size
	      copy.resultsdirty = true;
	      copy.filterPipeline = this.filterPipeline;
	      copy.sortFunction = this.sortFunction;
	      copy.sortCriteria = this.sortCriteria;
	      copy.sortDirty = this.sortDirty;

	      // avoid circular reference, reapply in db.loadJSON()
	      copy.collection = null;

	      return copy;
	    };

	    /**
	     * applySort() - Used to apply a sort to the dynamic view
	     *
	     * @param {function} comparefun - a javascript compare function used for sorting
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.applySort = function (comparefun) {
	      this.sortFunction = comparefun;
	      this.sortCriteria = null;

	      this.queueSortPhase();

	      return this;
	    };

	    /**
	     * applySimpleSort() - Used to specify a property used for view translation.
	     *
	     * @param {string} propname - Name of property by which to sort.
	     * @param {boolean} isdesc - (Optional) If true, the sort will be in descending order.
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.applySimpleSort = function (propname, isdesc) {

	      if (typeof (isdesc) === 'undefined') {
	        isdesc = false;
	      }

	      this.sortCriteria = [
	        [propname, isdesc]
	      ];
	      this.sortFunction = null;

	      this.queueSortPhase();

	      return this;
	    };

	    /**
	     * applySortCriteria() - Allows sorting a resultset based on multiple columns.
	     *    Example : dv.applySortCriteria(['age', 'name']); to sort by age and then name (both ascending)
	     *    Example : dv.applySortCriteria(['age', ['name', true]); to sort by age (ascending) and then by name (descending)
	     *    Example : dv.applySortCriteria(['age', true], ['name', true]); to sort by age (descending) and then by name (descending)
	     *
	     * @param {array} properties - array of property names or subarray of [propertyname, isdesc] used evaluate sort order
	     * @returns {DynamicView} Reference to this DynamicView, sorted, for future chain operations.
	     */
	    DynamicView.prototype.applySortCriteria = function (criteria) {
	      this.sortCriterial = criteria;
	      this.sortFunction = null;

	      this.queueSortPhase();

	      return this;
	    };

	    /**
	     * startTransaction() - marks the beginning of a transaction.
	     *
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.startTransaction = function () {
	      this.cachedresultset = this.resultset.copy();

	      return this;
	    };

	    /**
	     * commit() - commits a transaction.
	     *
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.commit = function () {
	      this.cachedresultset = null;

	      return this;
	    };

	    /**
	     * rollback() - rolls back a transaction.
	     *
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.rollback = function () {
	      this.resultset = this.cachedresultset;

	      if (this.persistent) {
	        // for now just rebuild the persistent dynamic view data in this worst case scenario
	        // (a persistent view utilizing transactions which get rolled back), we already know the filter so not too bad.
	        this.resultdata = this.resultset.data();

	        this.emit('rebuild', this);
	      }

	      return this;
	    };

	    /**
	     * applyFind() - Adds a mongo-style query option to the DynamicView filter pipeline
	     *
	     * @param {object} query - A mongo-style query object to apply to pipeline
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.applyFind = function (query) {
	      this.filterPipeline.push({
	        type: 'find',
	        val: query
	      });

	      // Apply immediately to Resultset; if persistent we will wait until later to build internal data
	      this.resultset.find(query);

	      if (this.sortFunction || this.sortCriteria) {
	        this.sortDirty = true;
	        this.queueSortPhase();
	      }

	      if (this.persistent) {
	        this.resultsdirty = true;
	        this.queueSortPhase();
	      }

	      return this;
	    };

	    /**
	     * applyWhere() - Adds a javascript filter function to the DynamicView filter pipeline
	     *
	     * @param {function} fun - A javascript filter function to apply to pipeline
	     * @returns {DynamicView} this DynamicView object, for further chain ops.
	     */
	    DynamicView.prototype.applyWhere = function (fun) {
	      this.filterPipeline.push({
	        type: 'where',
	        val: fun
	      });

	      // Apply immediately to Resultset; if persistent we will wait until later to build internal data
	      this.resultset.where(fun);

	      if (this.sortFunction || this.sortCriteria) {
	        this.sortDirty = true;
	        this.queueSortPhase();
	      }
	      if (this.persistent) {
	        this.resultsdirty = true;
	        this.queueSortPhase();
	      }
	      return this;
	    };

	    /**
	     * data() - resolves and pending filtering and sorting, then returns document array as result.
	     *
	     * @returns {array} An array of documents representing the current DynamicView contents.
	     */
	    DynamicView.prototype.data = function () {
	      // using final sort phase as 'catch all' for a few use cases which require full rebuild
	      if (this.sortDirty || this.resultsdirty || !this.resultset.filterInitialized) {
	        this.performSortPhase();
	      }

	      if (!this.persistent) {
	        return this.resultset.data();
	      }

	      return this.resultdata;
	    };

	    /**
	     *
	     */
	    DynamicView.prototype.queueSortPhase = function () {
	      var self = this;

	      // already queued? exit without queuing again
	      if (this.sortDirty) {
	        return;
	      }

	      this.sortDirty = true;

	      // queue async call to performSortPhase()
	      setTimeout(function () {
	        self.performSortPhase();
	      }, 1);
	    };

	    /**
	     * performSortPhase() - invoked synchronously or asynchronously to perform final sort phase (if needed)
	     *
	     */
	    DynamicView.prototype.performSortPhase = function () {
	      // async call to this may have been pre-empted by synchronous call to data before async could fire
	      if (!this.sortDirty && !this.resultsdirty && this.resultset.filterInitialized) {
	        return;
	      }

	      if (this.sortFunction) {
	        this.resultset.sort(this.sortFunction);
	      }

	      if (this.sortCriteria) {
	        this.resultset.compoundsort(this.sortCriteria);
	      }

	      if (!this.persistent) {
	        this.sortDirty = false;
	        return;
	      }

	      // persistent view, rebuild local resultdata array
	      this.resultdata = this.resultset.data();
	      this.resultsdirty = false;
	      this.sortDirty = false;

	      this.emit('rebuild', this);
	    };

	    /**
	     * evaluateDocument() - internal method for (re)evaluating document inclusion.
	     *    Called by : collection.insert() and collection.update().
	     *
	     * @param {int} objIndex - index of document to (re)run through filter pipeline.
	     */
	    DynamicView.prototype.evaluateDocument = function (objIndex) {
	      var ofr = this.resultset.filteredrows;
	      var oldPos = ofr.indexOf(objIndex);
	      var oldlen = ofr.length;

	      // creating a 1-element resultset to run filter chain ops on to see if that doc passes filters;
	      // mostly efficient algorithm, slight stack overhead price (this function is called on inserts and updates)
	      var evalResultset = new Resultset(this.collection);
	      evalResultset.filteredrows = [objIndex];
	      evalResultset.filterInitialized = true;
	      for (var idx = 0; idx < this.filterPipeline.length; idx++) {
	        switch (this.filterPipeline[idx].type) {
	        case 'find':
	          evalResultset.find(this.filterPipeline[idx].val);
	          break;
	        case 'where':
	          evalResultset.where(this.filterPipeline[idx].val);
	          break;
	        }
	      }

	      // not a true position, but -1 if not pass our filter(s), 0 if passed filter(s)
	      var newPos = (evalResultset.filteredrows.length === 0) ? -1 : 0;

	      // wasn't in old, shouldn't be now... do nothing
	      if (oldPos == -1 && newPos == -1) return;

	      // wasn't in resultset, should be now... add
	      if (oldPos === -1 && newPos !== -1) {
	        ofr.push(objIndex);

	        if (this.persistent) {
	          this.resultdata.push(this.collection.data[objIndex]);
	        }

	        // need to re-sort to sort new document
	        if (this.sortFunction || this.sortCriteria) {
	          this.queueSortPhase();
	        }

	        return;
	      }

	      // was in resultset, shouldn't be now... delete
	      if (oldPos !== -1 && newPos === -1) {
	        if (oldPos < oldlen - 1) {
	          // http://dvolvr.davidwaterston.com/2013/06/09/restating-the-obvious-the-fastest-way-to-truncate-an-array-in-javascript/comment-page-1/
	          ofr[oldPos] = ofr[oldlen - 1];
	          ofr.length = oldlen - 1;

	          if (this.persistent) {
	            this.resultdata[oldPos] = this.resultdata[oldlen - 1];
	            this.resultdata.length = oldlen - 1;
	          }
	        } else {
	          ofr.length = oldlen - 1;

	          if (this.persistent) {
	            this.resultdata.length = oldlen - 1;
	          }
	        }

	        // in case changes to data altered a sort column
	        if (this.sortFunction || this.sortCriteria) {
	          this.queueSortPhase();
	        }

	        return;
	      }

	      // was in resultset, should still be now... (update persistent only?)
	      if (oldPos !== -1 && newPos !== -1) {
	        if (this.persistent) {
	          // in case document changed, replace persistent view data with the latest collection.data document
	          this.resultdata[oldPos] = this.collection.data[objIndex];
	        }

	        // in case changes to data altered a sort column
	        if (this.sortFunction || this.sortCriteria) {
	          this.sortDirty = true;
	        }

	        return;
	      }
	    };

	    /**
	     * removeDocument() - internal function called on collection.delete()
	     */
	    DynamicView.prototype.removeDocument = function (objIndex) {
	      var ofr = this.resultset.filteredrows;
	      var oldPos = ofr.indexOf(objIndex);
	      var oldlen = ofr.length;
	      var idx;

	      if (oldPos !== -1) {
	        // if not last row in resultdata, swap last to hole and truncate last row
	        if (oldPos < oldlen - 1) {
	          ofr[oldPos] = ofr[oldlen - 1];
	          ofr.length = oldlen - 1;

	          if (this.persistent) {
	            this.resultdata[oldPos] = this.resultdata[oldlen - 1];
	            this.resultdata.length = oldlen - 1;
	          }
	        }
	        // last row, so just truncate last row
	        else {
	          ofr.length = oldlen - 1;

	          if (this.persistent) {
	            this.resultdata.length = oldlen - 1;
	          }
	        }

	        // in case changes to data altered a sort column
	        if (this.sortFunction || this.sortCriteria) {
	          this.queueSortPhase();
	        }
	      }

	      // since we are using filteredrows to store data array positions
	      // if they remove a document (whether in our view or not),
	      // we need to adjust array positions -1 for all document array references after that position
	      oldlen = ofr.length;
	      for (idx = 0; idx < oldlen; idx++) {
	        if (ofr[idx] > objIndex) {
	          ofr[idx] --;
	        }
	      }
	    };

	    /**
	     * mapReduce() - data transformation via user supplied functions
	     *
	     * @param {function} mapFunction - this function accepts a single document for you to transform and return
	     * @param {function} reduceFunction - this function accepts many (array of map outputs) and returns single value
	     * @returns The output of your reduceFunction
	     */
	    DynamicView.prototype.mapReduce = function (mapFunction, reduceFunction) {
	      try {
	        return reduceFunction(this.data().map(mapFunction));
	      } catch (err) {
	        throw err;
	      }
	    };


	    /**
	     * @constructor
	     * Collection class that handles documents of same type
	     * @param {stirng} collection name
	     * @param {array} array of property names to be indicized
	     * @param {object} configuration object
	     */
	    function Collection(name, options) {
	      // the name of the collection

	      this.name = name;
	      // the data held by the collection
	      this.data = [];
	      this.idIndex = []; // index of id
	      this.binaryIndices = {}; // user defined indexes
	      this.constraints = {
	        unique: {},
	        exact: {}
	      };

	      // the object type of the collection
	      this.objType = name;

	      // in autosave scenarios we will use collection level dirty flags to determine whether save is needed.
	      // currently, if any collection is dirty we will autosave the whole database if autosave is configured.
	      // defaulting to true since this is called from addCollection and adding a collection should trigger save
	      this.dirty = true;

	      // private holders for cached data
	      this.cachedIndex = null;
	      this.cachedBinaryIndex = null;
	      this.cachedData = null;
	      var self = this;

	      /* OPTIONS */
	      options = options || {};

	      // exact match and unique constraints
	      if (options.hasOwnProperty('unique')) {
	        options.unique.forEach(function (prop) {
	          self.constraints.unique[prop] = new UniqueIndex(prop);
	        });
	      }

	      if (options.hasOwnProperty('exact')) {
	        options.exact.forEach(function (prop) {
	          self.constraints.exact[prop] = new ExactIndex(prop);
	        });
	      }

	      // is collection transactional
	      this.transactional = options.hasOwnProperty('transactional') ? options.transactional : false;

	      // options to clone objects when inserting them
	      this.cloneObjects = options.hasOwnProperty('clone') ? options.clone : false;

	      // option to make event listeners async, default is sync
	      this.asyncListeners = options.hasOwnProperty('asyncListeners') ? options.asyncListeners : false;

	      // disable track changes
	      this.disableChangesApi = options.hasOwnProperty('disableChangesApi') ? options.disableChangesApi : true;


	      // currentMaxId - change manually at your own peril!
	      this.maxId = 0;

	      this.DynamicViews = [];

	      // events
	      this.events = {
	        'insert': [],
	        'update': [],
	        'pre-insert': [],
	        'pre-update': [],
	        'close': [],
	        'flushbuffer': [],
	        'error': [],
	        'delete': [],
	        'warning': []
	      };

	      // changes are tracked by collection and aggregated by the db
	      this.changes = [];

	      // initialize the id index
	      this.ensureId();
	      var indices = [];
	      // initialize optional user-supplied indices array ['age', 'lname', 'zip']
	      //if (typeof (indices) !== 'undefined') {
	      if (options && options.indices) {
	        if (Object.prototype.toString.call(options.indices) === '[object Array]') {
	          indices = options.indices;
	        } else if (typeof options.indices === 'string') {
	          indices = [options.indices];
	        } else {
	          throw new TypeError('Indices needs to be a string or an array of strings');
	        }
	      }

	      for (var idx = 0; idx < indices.length; idx++) {
	        this.ensureIndex(indices[idx]);
	      }

	      /**
	       * This method creates a clone of the current status of an object and associates operation and collection name,
	       * so the parent db can aggregate and generate a changes object for the entire db
	       */
	      function createChange(name, op, obj) {
	        self.changes.push({
	          name: name,
	          operation: op,
	          obj: JSON.parse(JSON.stringify(obj))
	        });
	      }

	      // clear all the changes
	      function flushChanges() {
	        self.changes = [];
	      }

	      this.getChanges = function () {
	        return self.changes;
	      };

	      this.flushChanges = flushChanges;

	      /**
	       * If the changes API is disabled make sure only metadata is added without re-evaluating everytime if the changesApi is enabled
	       */
	      function insertMeta(obj) {
	        if (!obj) {
	          return;
	        }
	        if (!obj.meta) {
	          obj.meta = {};
	        }

	        obj.meta.created = (new Date()).getTime();
	        obj.meta.revision = 0;
	      }

	      function updateMeta(obj) {
	        if (!obj) {
	          return;
	        }
	        obj.meta.updated = (new Date()).getTime();
	        obj.meta.revision += 1;
	      }

	      function createInsertChange(obj) {
	        createChange(self.name, 'I', obj);
	      }

	      function createUpdateChange(obj) {
	        createChange(self.name, 'U', obj);
	      }

	      function insertMetaWithChange(obj) {
	        insertMeta(obj);
	        createInsertChange(obj);
	      }

	      function updateMetaWithChange(obj) {
	        updateMeta(obj);
	        createUpdateChange(obj);
	      }


	      /* assign correct handler based on ChangesAPI flag */
	      var insertHandler, updateHandler;

	      function setHandlers() {
	        insertHandler = self.disableChangesApi ? insertMeta : insertMetaWithChange;
	        updateHandler = self.disableChangesApi ? updateMeta : updateMetaWithChange;
	      }

	      setHandlers();

	      this.setChangesApi = function (enabled) {
	        self.disableChangesApi = !enabled;
	        setHandlers();
	      };
	      /**
	       * built-in events
	       */
	      this.on('insert', function insertCallback(obj) {
	        insertHandler(obj);
	      });

	      this.on('update', function updateCallback(obj) {
	        updateHandler(obj);
	      });

	      this.on('delete', function deleteCallback(obj) {
	        if (!self.disableChangesApi) {
	          createChange(self.name, 'R', obj);
	        }
	      });

	      this.on('warning', console.warn);
	      // for de-serialization purposes
	      flushChanges();
	    }

	    Collection.prototype = new LokiEventEmitter();

	    /*----------------------------+
	    | INDEXING                    |
	    +----------------------------*/

	    /**
	     * Ensure binary index on a certain field
	     */
	    Collection.prototype.ensureIndex = function (property, force) {
	      // optional parameter to force rebuild whether flagged as dirty or not
	      if (typeof (force) === 'undefined') {
	        force = false;
	      }

	      if (property === null || property === undefined) {
	        throw 'Attempting to set index without an associated property';
	      }

	      if (this.binaryIndices.hasOwnProperty(property) && !force) {
	        if (!this.binaryIndices[property].dirty) return;
	      }

	      this.binaryIndices[property] = {
	        'name': property,
	        'dirty': true,
	        'values': []
	      };

	      var index, len = this.data.length,
	        i = 0;

	      index = this.binaryIndices[property];

	      // initialize index values
	      for (i; i < len; i += 1) {
	        index.values.push(i);
	      }

	      var wrappedComparer =
	        (function (prop, coll) {
	          return function (a, b) {
	            var obj1 = coll.data[a];
	            var obj2 = coll.data[b];

	            if (obj1[prop] === obj2[prop]) return 0;
	            if (gtHelper(obj1[prop], obj2[prop])) return 1;
	            if (ltHelper(obj1[prop], obj2[prop])) return -1;
	          };
	        })(property, this);

	      index.values.sort(wrappedComparer);
	      index.dirty = false;

	      this.dirty = true; // for autosave scenarios
	    };

	    /**
	     * Ensure all binary indices
	     */
	    Collection.prototype.ensureAllIndexes = function (force) {
	      var objKeys = Object.keys(this.binaryIndices);

	      var i = objKeys.length;
	      while (i--) {
	        this.ensureIndex(objKeys[i], force);
	      }
	    };

	    Collection.prototype.flagBinaryIndexesDirty = function () {
	      var objKeys = Object.keys(this.binaryIndices);

	      var i = objKeys.length;
	      while (i--) {
	        this.binaryIndices[objKeys[i]].dirty = true;
	      }
	    };

	    /**
	     * Rebuild idIndex
	     */
	    Collection.prototype.ensureId = function () {

	      var len = this.data.length,
	        i = 0;

	      this.idIndex = [];
	      for (i; i < len; i += 1) {
	        this.idIndex.push(this.data[i].$loki);
	      }
	    };

	    /**
	     * Rebuild idIndex async with callback - useful for background syncing with a remote server
	     */
	    Collection.prototype.ensureIdAsync = function (callback) {
	      this.async(function () {
	        this.ensureId();
	      }, callback);
	    };

	    /**
	     * Each collection maintains a list of DynamicViews associated with it
	     **/

	    Collection.prototype.addDynamicView = function (name, persistent) {
	      var dv = new DynamicView(this, name, persistent);
	      this.DynamicViews.push(dv);

	      return dv;
	    };

	    Collection.prototype.removeDynamicView = function (name) {
	      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	        if (this.DynamicViews[idx].name === name) {
	          this.DynamicViews.splice(idx, 1);
	        }
	      }
	    };

	    Collection.prototype.getDynamicView = function (name) {
	      for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	        if (this.DynamicViews[idx].name === name) {
	          return this.DynamicViews[idx];
	        }
	      }

	      return null;
	    };

	    /**
	     * find and update: pass a filtering function to select elements to be updated
	     * and apply the updatefunctino to those elements iteratively
	     */
	    Collection.prototype.findAndUpdate = function (filterFunction, updateFunction) {

	      var results = this.where(filterFunction),
	        i = 0,
	        obj;
	      try {
	        for (i; i < results.length; i++) {
	          obj = updateFunction(results[i]);
	          this.update(obj);
	        }

	      } catch (err) {
	        this.rollback();
	        console.error(err.message);
	      }
	    };

	    /**
	     * generate document method - ensure objects have id and objType properties
	     * @param {object} the document to be inserted (or an array of objects)
	     * @returns document or documents (if passed an array of objects)
	     */
	    Collection.prototype.insert = function (doc) {

	      if (!doc) {
	        var error = new Error('Object cannot be null');
	        this.emit('error', error);
	        throw error;
	      }

	      var self = this;
	      // holder to the clone of the object inserted if collections is set to clone objects
	      var obj;
	      var docs = Array.isArray(doc) ? doc : [doc];

	      docs.forEach(function (d) {
	        if (typeof d !== 'object') {
	          throw new TypeError('Document needs to be an object');
	        }
	        if (self.clone) {
	          obj = JSON.parse(JSON.stringify(d));
	        } else {
	          obj = d;
	        }

	        if (typeof obj.meta === 'undefined') {
	          obj.meta = {
	            revision: 0,
	            created: 0
	          };
	        }
	        self.emit('pre-insert', obj);
	        if (self.add(obj)) {
	          self.emit('insert', obj);
	        } else {
	          return undefined;
	        }


	      });
	      return obj;
	    };

	    Collection.prototype.clear = function () {
	      this.data = [];
	      this.idIndex = [];
	      this.binaryIndices = {};
	      this.cachedIndex = null;
	      this.cachedData = null;
	      this.maxId = 0;
	      this.DynamicViews = [];
	      this.dirty = true;
	    };

	    /**
	     * Update method
	     */
	    Collection.prototype.update = function (doc) {
	      if (Object.keys(this.binaryIndices).length > 0) {
	        this.flagBinaryIndexesDirty();
	      }

	      if (Array.isArray(doc)) {
	        var k = 0,
	          len = doc.length;
	        for (k; k < len; k += 1) {
	          this.update(doc[k]);
	        }
	        return;
	      }

	      // verify object is a properly formed document
	      if (!doc.hasOwnProperty('$loki')) {
	        throw 'Trying to update unsynced document. Please save the document first by using insert() or addMany()';
	      }
	      try {
	        this.startTransaction();
	        var arr = this.get(doc.$loki, true),
	          obj,
	          position,
	          self = this;

	        if (!arr) {
	          throw new Error('Trying to update a document not in collection.');
	        }
	        this.emit('pre-update', doc);

	        obj = arr[0];
	        Object.keys(this.constraints.unique).forEach(function (key) {
	          self.constraints.unique[key].update(obj);
	        });
	        // get current position in data array
	        position = arr[1];

	        // operate the update
	        this.data[position] = doc;


	        // now that we can efficiently determine the data[] position of newly added document,
	        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
	        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	          this.DynamicViews[idx].evaluateDocument(position);
	        }

	        this.idIndex[position] = obj.$loki;

	        this.commit();
	        this.dirty = true; // for autosave scenarios
	        this.emit('update', doc);

	      } catch (err) {
	        this.rollback();
	        console.error(err.message);
	        this.emit('error', err);
	        throw (err); // re-throw error so user does not think it succeeded
	      }
	    };

	    /**
	     * Add object to collection
	     */
	    Collection.prototype.add = function (obj) {
	      var i,
	        dvlen = this.DynamicViews.length;

	      // if parameter isn't object exit with throw
	      if ('object' !== typeof obj) {
	        throw 'Object being added needs to be an object';
	      }
	      /*
	       * try adding object to collection
	       */

	      if (Object.keys(this.binaryIndices).length > 0) {
	        this.flagBinaryIndexesDirty();
	      }

	      // if object you are adding already has id column it is either already in the collection
	      // or the object is carrying its own 'id' property.  If it also has a meta property,
	      // then this is already in collection so throw error, otherwise rename to originalId and continue adding.
	      if (typeof (obj.$loki) !== "undefined") {
	        throw 'Document is already in collection, please use update()';
	      }

	      try {
	        this.startTransaction();
	        this.maxId++;
	        var i;

	        if (isNaN(this.maxId)) {
	          this.maxId = (this.data[this.data.length - 1].$loki + 1);
	        }

	        obj.$loki = this.maxId;
	        obj.meta.version = 0;

	        // add the object
	        this.data.push(obj);
	        var found = false,
	          prop,
	          self = this;
	        Object.keys(this.constraints.unique).forEach(function (key) {
	          self.constraints.unique[key].set(obj);
	        });

	        // now that we can efficiently determine the data[] position of newly added document,
	        // submit it for all registered DynamicViews to evaluate for inclusion/exclusion
	        for (i = 0; i < dvlen; i++) {
	          this.DynamicViews[i].evaluateDocument(this.data.length - 1);
	        }

	        // add new obj id to idIndex
	        this.idIndex.push(obj.$loki);

	        this.commit();
	        this.dirty = true; // for autosave scenarios
	        return obj;
	      } catch (err) {
	        this.rollback();
	        console.error(err.message);
	      }
	    };


	    Collection.prototype.removeWhere = function (query) {
	      var list;
	      if (typeof query === 'function') {
	        list = this.data.filter(query);
	      } else {
	        list = new Resultset(this, query);
	      }
	      var len = list.length;
	      while (len--) {
	        this.remove(list[len]);
	      }

	    };

	    Collection.prototype.removeDataOnly = function () {
	      this.removeWhere(function (obj) {
	        return true;
	      });
	    };

	    /**
	     * delete wrapped
	     */
	    Collection.prototype.remove = function (doc) {
	      if (typeof doc === 'number') {
	        doc = this.get(doc);
	      }

	      if ('object' !== typeof doc) {
	        throw new Error('Parameter is not an object');
	      }
	      if (Array.isArray(doc)) {
	        var k = 0,
	          len = doc.length;
	        for (k; k < len; k += 1) {
	          this.remove(doc[k]);
	        }
	        return;
	      }

	      if (!doc.hasOwnProperty('$loki')) {
	        throw new Error('Object is not a document stored in the collection');
	      }

	      if (Object.keys(this.binaryIndices).length > 0) {
	        this.flagBinaryIndexesDirty();
	      }

	      try {
	        this.startTransaction();
	        var arr = this.get(doc.$loki, true),
	          // obj = arr[0],
	          position = arr[1];
	        var self = this;
	        Object.keys(this.constraints.unique).forEach(function (key) {
	          self.constraints.unique[key].remove(doc);
	        });
	        // now that we can efficiently determine the data[] position of newly added document,
	        // submit it for all registered DynamicViews to remove
	        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	          this.DynamicViews[idx].removeDocument(position);
	        }

	        this.data.splice(position, 1);

	        // remove id from idIndex
	        this.idIndex.splice(position, 1);

	        this.commit();
	        this.dirty = true; // for autosave scenarios
	        this.emit('delete', arr[0]);

	      } catch (err) {
	        this.rollback();
	        console.error(err.message);
	        this.emit('error', err);
	      }
	    };

	    /*---------------------+
	    | Finding methods     |
	    +----------------------*/

	    /**
	     * Get by Id - faster than other methods because of the searching algorithm
	     */
	    Collection.prototype.get = function (id, returnPosition) {

	      var retpos = returnPosition || false,
	        data = this.idIndex,
	        max = data.length - 1,
	        min = 0,
	        mid = Math.floor(min + (max - min) / 2);

	      id = typeof id === 'number' ? id : parseInt(id, 10);

	      if (isNaN(id)) {
	        throw 'Passed id is not an integer';
	      }

	      while (data[min] < data[max]) {

	        mid = Math.floor((min + max) / 2);

	        if (data[mid] < id) {
	          min = mid + 1;
	        } else {
	          max = mid;
	        }
	      }

	      if (max === min && data[min] === id) {

	        if (retpos) {
	          return [this.data[min], min];
	        }
	        return this.data[min];
	      }
	      return null;
	    };

	    Collection.prototype.by = function (field, value) {
	      var self;
	      if (!value) {
	        self = this;
	        return function (value) {
	          return self.by(field, value);
	        };
	      }
	      return this.constraints.unique[field].get(value);
	    };

	    /**
	     * Find one object by index property, by property equal to value
	     */
	    Collection.prototype.findOne = function (query) {
	      // Instantiate Resultset and exec find op passing firstOnly = true param
	      var result = new Resultset(this, query, null, true);
	      if (Array.isArray(result) && result.length === 0) {
	        return null;
	      } else {
	        return result;
	      }
	    };

	    /**
	     * Chain method, used for beginning a series of chained find() and/or view() operations
	     * on a collection.
	     */
	    Collection.prototype.chain = function () {
	      return new Resultset(this, null, null);
	    };

	    /**
	     * Find method, api is similar to mongodb except for now it only supports one search parameter.
	     * for more complex queries use view() and storeView()
	     */
	    Collection.prototype.find = function (query) {
	      if (typeof (query) === 'undefined') {
	        query = 'getAll';
	      }
	      // find logic moved into Resultset class
	      return new Resultset(this, query, null);
	    };

	    /**
	     * Find object by unindexed field by property equal to value,
	     * simply iterates and returns the first element matching the query
	     */
	    Collection.prototype.findOneUnindexed = function (prop, value) {

	      var i = this.data.length,
	        doc;
	      while (i--) {
	        if (this.data[i][prop] === value) {
	          doc = this.data[i];
	          return doc;
	        }
	      }
	      return null;
	    };

	    /**
	     * Transaction methods
	     */

	    /** start the transation */
	    Collection.prototype.startTransaction = function () {
	      if (this.transactional) {
	        this.cachedData = clone(this.data, 'parse-stringify');
	        this.cachedIndex = this.idIndex;
	        this.cachedBinaryIndex = this.binaryIndices;

	        // propagate startTransaction to dynamic views
	        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	          this.DynamicViews[idx].startTransaction();
	        }
	      }
	    };

	    /** commit the transation */
	    Collection.prototype.commit = function () {
	      if (this.transactional) {
	        this.cachedData = null;
	        this.cachedIndex = null;
	        this.cachedBinaryIndices = null;

	        // propagate commit to dynamic views
	        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	          this.DynamicViews[idx].commit();
	        }
	      }
	    };

	    /** roll back the transation */
	    Collection.prototype.rollback = function () {
	      if (this.transactional) {
	        if (this.cachedData !== null && this.cachedIndex !== null) {
	          this.data = this.cachedData;
	          this.idIndex = this.cachedIndex;
	          this.binaryIndices = this.cachedBinaryIndex;
	        }

	        // propagate rollback to dynamic views
	        for (var idx = 0; idx < this.DynamicViews.length; idx++) {
	          this.DynamicViews[idx].rollback();
	        }
	      }
	    };

	    // async executor. This is only to enable callbacks at the end of the execution.
	    Collection.prototype.async = function (fun, callback) {
	      setTimeout(function () {
	        if (typeof fun === 'function') {
	          fun();
	          callback();
	        } else {
	          throw 'Argument passed for async execution is not a function';
	        }
	      }, 0);
	    };

	    /**
	     * Create view function - filter
	     */
	    Collection.prototype.where = function (fun) {
	      // find logic moved into Resultset class
	      return new Resultset(this, null, fun);
	    };

	    /**
	     * Map Reduce
	     */
	    Collection.prototype.mapReduce = function (mapFunction, reduceFunction) {
	      try {
	        return reduceFunction(this.data.map(mapFunction));
	      } catch (err) {
	        throw err;
	      }
	    };

	    /**
	     * eqJoin - Join two collections on specified properties
	     */
	    Collection.prototype.eqJoin = function (joinData, leftJoinProp, rightJoinProp, mapFun) {
	      // logic in Resultset class
	      return new Resultset(this).eqJoin(joinData, leftJoinProp, rightJoinProp, mapFun);
	    };


	    Collection.prototype.no_op = function () {
	      return;
	    };

	    Collection.prototype.extract = function (field) {
	      var i = 0,
	        len = this.data.length,
	        isDotNotation = isDeepProperty(field),
	        result = [];
	      for (i; i < len; i += 1) {
	        result.push(deepProperty(this.data[i], field, isDotNotation));
	      }
	      return result;
	    };

	    Collection.prototype.max = function (field) {
	      return Math.max.apply(null, this.extract(field));
	    };

	    Collection.prototype.min = function (field) {
	      return Math.min.apply(null, this.extract(field));
	    };

	    Collection.prototype.maxRecord = function (field) {
	      var i = 0,
	        len = this.data.length,
	        deep = isDeepProperty(field),
	        result = {
	          index: 0,
	          value: undefined
	        },
	        max = undefined;

	      for (i; i < len; i += 1) {
	        if (max !== undefined) {
	          if (max < deepProperty(this.data[i], field, deep)) {
	            max = deepProperty(this.data[i], field, deep);
	            result.index = this.data[i].$loki;
	          }
	        } else {
	          max = deepProperty(this.data[i], field, deep);
	          result.index = this.data[i].$loki;
	        }
	      }
	      result.value = max;
	      return result;
	    };

	    Collection.prototype.minRecord = function (field) {
	      var i = 0,
	        len = this.data.length,
	        deep = isDeepProperty(field),
	        result = {
	          index: 0,
	          value: undefined
	        },
	        min = undefined;

	      for (i; i < len; i += 1) {
	        if (min !== undefined) {
	          if (min > deepProperty(this.data[i], field, deep)) {
	            min = deepProperty(this.data[i], field, deep);
	            result.index = this.data[i].$loki;
	          }
	        } else {
	          min = deepProperty(this.data[i], field, deep);
	          result.index = this.data[i].$loki;
	        }
	      }
	      result.value = min;
	      return result;
	    };

	    Collection.prototype.extractNumerical = function (field) {
	      return this.extract(field).map(parseBase10).filter(Number).filter(function (n) {
	        return !(isNaN(n));
	      });
	    };

	    Collection.prototype.avg = function (field) {
	      return average(this.extractNumerical(field));
	    };

	    Collection.prototype.stdDev = function (field) {
	      return standardDeviation(this.extractNumerical(field));
	    };

	    Collection.prototype.mode = function (field) {
	      var dict = {},
	        data = this.extract(field);
	      data.forEach(function (obj) {
	        if (dict[obj]) {
	          dict[obj] += 1;
	        } else {
	          dict[obj] = 1;
	        }
	      });
	      var max = undefined,
	        prop, mode;
	      for (prop in dict) {
	        if (max) {
	          if (max < dict[prop]) {
	            mode = prop;
	          }
	        } else {
	          mode = prop;
	          max = dict[prop];
	        }
	      }
	      return mode;
	    };

	    Collection.prototype.median = function (field) {
	      var values = this.extractNumerical(field);
	      values.sort(sub);

	      var half = Math.floor(values.length / 2);

	      if (values.length % 2) {
	        return values[half];
	      } else {
	        return (values[half - 1] + values[half]) / 2.0;
	      }
	    };

	    /**
	     * General utils, including statistical functions
	     */
	    function isDeepProperty(field) {
	      return field.indexOf('.') !== -1;
	    }

	    function parseBase10(num) {
	      return parseFloat(num, 10);
	    }

	    function isNotUndefined(obj) {
	      return obj !== undefined;
	    }

	    function add(a, b) {
	      return a + b;
	    }

	    function sub(a, b) {
	      return a - b;
	    }

	    function median(values) {
	      values.sort(sub);
	      var half = Math.floor(values.length / 2);
	      return (values.length % 2) ? values[half] : ((values[half - 1] + values[half]) / 2.0);
	    }

	    function average(array) {
	      return (array.reduce(add, 0)) / array.length;
	    }

	    function standardDeviation(values) {
	      var avg = average(values);
	      var squareDiffs = values.map(function (value) {
	        var diff = value - avg;
	        var sqrDiff = diff * diff;
	        return sqrDiff;
	      });

	      var avgSquareDiff = average(squareDiffs);

	      var stdDev = Math.sqrt(avgSquareDiff);
	      return stdDev;
	    }

	    function deepProperty(obj, property, isDeep) {
	      if (isDeep === false) {
	        // pass without processing
	        return obj[property];
	      }
	      var pieces = property.split('.'),
	        root = obj;
	      while (pieces.length > 0) {
	        root = root[pieces.shift()];
	      }
	      return root;
	    }

	    function binarySearch(array, item, fun) {
	      var lo = 0,
	        hi = array.length,
	        compared,
	        mid;
	      while (lo < hi) {
	        mid = ((lo + hi) / 2) | 0;
	        compared = fun.apply(null, [item, array[mid]]);
	        if (compared === 0) {
	          return {
	            found: true,
	            index: mid
	          };
	        } else if (compared < 0) {
	          hi = mid;
	        } else {
	          lo = mid + 1;
	        }
	      }
	      return {
	        found: false,
	        index: hi
	      };
	    }

	    function BSonSort(fun) {
	      return function (array, item) {
	        return binarySearch(array, item, fun);
	      };
	    }

	    function KeyValueStore() {}

	    KeyValueStore.prototype = {
	      keys: [],
	      values: [],
	      sort: function (a, b) {
	        return (a < b) ? -1 : ((a > b) ? 1 : 0);
	      },
	      setSort: function (fun) {
	        this.bs = new BSonSort(fun);
	      },
	      bs: function () {
	        return new BSonSort(this.sort);
	      },
	      set: function (key, value) {
	        var pos = this.bs(this.keys, key);
	        if (pos.found) {
	          this.values[pos.index] = value;
	        } else {
	          this.keys.splice(pos.index, 0, key);
	          this.values.splice(pos.index, 0, value);
	        }
	      },
	      get: function (key) {
	        return this.values[binarySearch(this.keys, key, this.sort).index];
	      }
	    };

	    function UniqueIndex(uniqueField) {
	      this.field = uniqueField;
	    }

	    UniqueIndex.prototype = {
	      keyMap: {},
	      lokiMap: {},
	      set: function (obj) {
	        if (this.keyMap[obj[this.field]]) {
	          throw new Error('Duplicate key for property ' + this.field);
	        } else {
	          this.keyMap[obj[this.field]] = obj;
	          this.lokiMap[obj.$loki] = obj[this.field];
	        }
	      },
	      get: function (key) {
	        return this.keyMap[key];
	      },
	      update: function (obj) {
	        if (this.lokiMap[obj.$loki] !== obj[this.field]) {
	          var old = this.lokiMap[obj.$loki];
	          this.set(obj);
	          // make the old key fail bool test, while avoiding the use of delete (mem-leak prone)
	          this.keyMap[old] = undefined;
	        } else {
	          this.keyMap[obj[this.field]] = obj;
	        }
	      },
	      remove: function (key) {
	        var obj = this.keyMap[key];
	        this.keyMap[key] = undefined;
	        this.lokiMap[obj.$loki] = undefined;
	      },
	      clear: function () {
	        this.keyMap = {};
	        this.lokiMap = {};
	      }
	    };

	    function ExactIndex(exactField) {
	      this.index = {};
	      this.field = exactField;
	    }

	    // add the value you want returned to the key in the index 
	    ExactIndex.prototype = {
	      set: function add(key, val) {
	        if (this.index[key]) {
	          this.index[key].push(val);
	        } else {
	          this.index[key] = [val];
	        }
	      },

	      // remove the value from the index, if the value was the last one, remove the key
	      remove: function remove(key, val) {
	        var idxSet = this.index[key];
	        for (var i in idxSet) {
	          if (idxSet[i] == val) {
	            idxSet.splice(i, 1);
	          }
	        }
	        if (idxSet.length < 1) {
	          this.index[key] = undefined;
	        }
	      },

	      // get the values related to the key, could be more than one
	      get: function get(key) {
	        return this.index[key];
	      },

	      // clear will zap the index
	      clear: function clear(key) {
	        this.index = {};
	      }
	    };

	    function SortedIndex(sortedField) {
	      this.field = sortedField;
	    }

	    SortedIndex.prototype = {
	      keys: [],
	      values: [],
	      // set the default sort
	      sort: function (a, b) {
	        return (a < b) ? -1 : ((a > b) ? 1 : 0);
	      },
	      bs: function () {
	        return BSonSort(this.sort);
	      },
	      // and allow override of the default sort
	      setSort: function (fun) {
	        this.bs = BSonSort(fun);
	      },
	      // add the value you want returned  to the key in the index  
	      set: function (key, value) {
	        var pos = binarySearch(this.keys, key, this.sort);
	        if (pos.found) {
	          this.values[pos.index].push(value);
	        } else {
	          this.keys.splice(pos.index, 0, key);
	          this.values.splice(pos.index, 0, [value]);
	        }
	      },
	      // get all values which have a key == the given key
	      get: function (key) {
	        var bsr = binarySearch(this.keys, key, this.sort);
	        if (bsr.found) {
	          return this.values[bsr.index];
	        } else {
	          return [];
	        }
	      },
	      // get all values which have a key < the given key
	      getLt: function (key) {
	        var bsr = binarySearch(this.keys, key, this.sort);
	        var pos = bsr.index;
	        if (bsr.found) pos--;
	        return this.getAll(key, 0, pos);
	      },
	      // get all values which have a key > the given key
	      getGt: function (key) {
	        var bsr = binarySearch(this.keys, key, this.sort);
	        var pos = bsr.index;
	        if (bsr.found) pos++;
	        return this.getAll(key, pos, this.keys.length);
	      },

	      // get all vals from start to end
	      getAll: function (key, start, end) {
	        var results = [];
	        for (var i = start; i < end; i++) {
	          results = results.concat(this.values[i]);
	        }
	        return results;
	      },
	      // just in case someone wants to do something smart with ranges
	      getPos: function (key) {
	        return binarySearch(this.keys, key, this.sort);
	      },
	      // remove the value from the index, if the value was the last one, remove the key
	      remove: function (key, value) {
	        var pos = binarySearch(this.keys, key, this.sort).index;
	        var idxSet = this.values[pos];
	        for (var i in idxSet) {
	          if (idxSet[i] == value) idxSet.splice(i, 1);
	        }
	        if (idxSet.length < 1) {
	          this.keys.splice(pos, 1);
	          this.values.splice(pos, 1);
	        }
	      },
	      // clear will zap the index
	      clear: function (key) {
	        this.keys = [];
	        this.values = [];
	      }
	    };


	    Loki.Collection = Collection;
	    Loki.KeyValueStore = KeyValueStore;
	    return Loki;
	  }());

	}));

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 *  Copyright (c) 2014-2015, Facebook, Inc.
	 *  All rights reserved.
	 *
	 *  This source code is licensed under the BSD-style license found in the
	 *  LICENSE file in the root directory of this source tree. An additional grant
	 *  of patent rights can be found in the PATENTS file in the same directory.
	 */
	(function (global, factory) {
	  true ? module.exports = factory() :
	  typeof define === 'function' && define.amd ? define(factory) :
	  global.Immutable = factory()
	}(this, function () { 'use strict';var SLICE$0 = Array.prototype.slice;

	  function createClass(ctor, superClass) {
	    if (superClass) {
	      ctor.prototype = Object.create(superClass.prototype);
	    }
	    ctor.prototype.constructor = ctor;
	  }

	  // Used for setting prototype methods that IE8 chokes on.
	  var DELETE = 'delete';

	  // Constants describing the size of trie nodes.
	  var SHIFT = 5; // Resulted in best performance after ______?
	  var SIZE = 1 << SHIFT;
	  var MASK = SIZE - 1;

	  // A consistent shared value representing "not set" which equals nothing other
	  // than itself, and nothing that could be provided externally.
	  var NOT_SET = {};

	  // Boolean references, Rough equivalent of `bool &`.
	  var CHANGE_LENGTH = { value: false };
	  var DID_ALTER = { value: false };

	  function MakeRef(ref) {
	    ref.value = false;
	    return ref;
	  }

	  function SetRef(ref) {
	    ref && (ref.value = true);
	  }

	  // A function which returns a value representing an "owner" for transient writes
	  // to tries. The return value will only ever equal itself, and will not equal
	  // the return of any subsequent call of this function.
	  function OwnerID() {}

	  // http://jsperf.com/copy-array-inline
	  function arrCopy(arr, offset) {
	    offset = offset || 0;
	    var len = Math.max(0, arr.length - offset);
	    var newArr = new Array(len);
	    for (var ii = 0; ii < len; ii++) {
	      newArr[ii] = arr[ii + offset];
	    }
	    return newArr;
	  }

	  function ensureSize(iter) {
	    if (iter.size === undefined) {
	      iter.size = iter.__iterate(returnTrue);
	    }
	    return iter.size;
	  }

	  function wrapIndex(iter, index) {
	    return index >= 0 ? (+index) : ensureSize(iter) + (+index);
	  }

	  function returnTrue() {
	    return true;
	  }

	  function wholeSlice(begin, end, size) {
	    return (begin === 0 || (size !== undefined && begin <= -size)) &&
	      (end === undefined || (size !== undefined && end >= size));
	  }

	  function resolveBegin(begin, size) {
	    return resolveIndex(begin, size, 0);
	  }

	  function resolveEnd(end, size) {
	    return resolveIndex(end, size, size);
	  }

	  function resolveIndex(index, size, defaultIndex) {
	    return index === undefined ?
	      defaultIndex :
	      index < 0 ?
	        Math.max(0, size + index) :
	        size === undefined ?
	          index :
	          Math.min(size, index);
	  }

	  function Iterable(value) {
	      return isIterable(value) ? value : Seq(value);
	    }


	  createClass(KeyedIterable, Iterable);
	    function KeyedIterable(value) {
	      return isKeyed(value) ? value : KeyedSeq(value);
	    }


	  createClass(IndexedIterable, Iterable);
	    function IndexedIterable(value) {
	      return isIndexed(value) ? value : IndexedSeq(value);
	    }


	  createClass(SetIterable, Iterable);
	    function SetIterable(value) {
	      return isIterable(value) && !isAssociative(value) ? value : SetSeq(value);
	    }



	  function isIterable(maybeIterable) {
	    return !!(maybeIterable && maybeIterable[IS_ITERABLE_SENTINEL]);
	  }

	  function isKeyed(maybeKeyed) {
	    return !!(maybeKeyed && maybeKeyed[IS_KEYED_SENTINEL]);
	  }

	  function isIndexed(maybeIndexed) {
	    return !!(maybeIndexed && maybeIndexed[IS_INDEXED_SENTINEL]);
	  }

	  function isAssociative(maybeAssociative) {
	    return isKeyed(maybeAssociative) || isIndexed(maybeAssociative);
	  }

	  function isOrdered(maybeOrdered) {
	    return !!(maybeOrdered && maybeOrdered[IS_ORDERED_SENTINEL]);
	  }

	  Iterable.isIterable = isIterable;
	  Iterable.isKeyed = isKeyed;
	  Iterable.isIndexed = isIndexed;
	  Iterable.isAssociative = isAssociative;
	  Iterable.isOrdered = isOrdered;

	  Iterable.Keyed = KeyedIterable;
	  Iterable.Indexed = IndexedIterable;
	  Iterable.Set = SetIterable;


	  var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  /* global Symbol */

	  var ITERATE_KEYS = 0;
	  var ITERATE_VALUES = 1;
	  var ITERATE_ENTRIES = 2;

	  var REAL_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
	  var FAUX_ITERATOR_SYMBOL = '@@iterator';

	  var ITERATOR_SYMBOL = REAL_ITERATOR_SYMBOL || FAUX_ITERATOR_SYMBOL;


	  function src_Iterator__Iterator(next) {
	      this.next = next;
	    }

	    src_Iterator__Iterator.prototype.toString = function() {
	      return '[Iterator]';
	    };


	  src_Iterator__Iterator.KEYS = ITERATE_KEYS;
	  src_Iterator__Iterator.VALUES = ITERATE_VALUES;
	  src_Iterator__Iterator.ENTRIES = ITERATE_ENTRIES;

	  src_Iterator__Iterator.prototype.inspect =
	  src_Iterator__Iterator.prototype.toSource = function () { return this.toString(); }
	  src_Iterator__Iterator.prototype[ITERATOR_SYMBOL] = function () {
	    return this;
	  };


	  function iteratorValue(type, k, v, iteratorResult) {
	    var value = type === 0 ? k : type === 1 ? v : [k, v];
	    iteratorResult ? (iteratorResult.value = value) : (iteratorResult = {
	      value: value, done: false
	    });
	    return iteratorResult;
	  }

	  function iteratorDone() {
	    return { value: undefined, done: true };
	  }

	  function hasIterator(maybeIterable) {
	    return !!getIteratorFn(maybeIterable);
	  }

	  function isIterator(maybeIterator) {
	    return maybeIterator && typeof maybeIterator.next === 'function';
	  }

	  function getIterator(iterable) {
	    var iteratorFn = getIteratorFn(iterable);
	    return iteratorFn && iteratorFn.call(iterable);
	  }

	  function getIteratorFn(iterable) {
	    var iteratorFn = iterable && (
	      (REAL_ITERATOR_SYMBOL && iterable[REAL_ITERATOR_SYMBOL]) ||
	      iterable[FAUX_ITERATOR_SYMBOL]
	    );
	    if (typeof iteratorFn === 'function') {
	      return iteratorFn;
	    }
	  }

	  function isArrayLike(value) {
	    return value && typeof value.length === 'number';
	  }

	  createClass(Seq, Iterable);
	    function Seq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        isIterable(value) ? value.toSeq() : seqFromValue(value);
	    }

	    Seq.of = function(/*...values*/) {
	      return Seq(arguments);
	    };

	    Seq.prototype.toSeq = function() {
	      return this;
	    };

	    Seq.prototype.toString = function() {
	      return this.__toString('Seq {', '}');
	    };

	    Seq.prototype.cacheResult = function() {
	      if (!this._cache && this.__iterateUncached) {
	        this._cache = this.entrySeq().toArray();
	        this.size = this._cache.length;
	      }
	      return this;
	    };

	    // abstract __iterateUncached(fn, reverse)

	    Seq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, true);
	    };

	    // abstract __iteratorUncached(type, reverse)

	    Seq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, true);
	    };



	  createClass(KeyedSeq, Seq);
	    function KeyedSeq(value) {
	      return value === null || value === undefined ?
	        emptySequence().toKeyedSeq() :
	        isIterable(value) ?
	          (isKeyed(value) ? value.toSeq() : value.fromEntrySeq()) :
	          keyedSeqFromValue(value);
	    }

	    KeyedSeq.prototype.toKeyedSeq = function() {
	      return this;
	    };



	  createClass(IndexedSeq, Seq);
	    function IndexedSeq(value) {
	      return value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value.toIndexedSeq();
	    }

	    IndexedSeq.of = function(/*...values*/) {
	      return IndexedSeq(arguments);
	    };

	    IndexedSeq.prototype.toIndexedSeq = function() {
	      return this;
	    };

	    IndexedSeq.prototype.toString = function() {
	      return this.__toString('Seq [', ']');
	    };

	    IndexedSeq.prototype.__iterate = function(fn, reverse) {
	      return seqIterate(this, fn, reverse, false);
	    };

	    IndexedSeq.prototype.__iterator = function(type, reverse) {
	      return seqIterator(this, type, reverse, false);
	    };



	  createClass(SetSeq, Seq);
	    function SetSeq(value) {
	      return (
	        value === null || value === undefined ? emptySequence() :
	        !isIterable(value) ? indexedSeqFromValue(value) :
	        isKeyed(value) ? value.entrySeq() : value
	      ).toSetSeq();
	    }

	    SetSeq.of = function(/*...values*/) {
	      return SetSeq(arguments);
	    };

	    SetSeq.prototype.toSetSeq = function() {
	      return this;
	    };



	  Seq.isSeq = isSeq;
	  Seq.Keyed = KeyedSeq;
	  Seq.Set = SetSeq;
	  Seq.Indexed = IndexedSeq;

	  var IS_SEQ_SENTINEL = '@@__IMMUTABLE_SEQ__@@';

	  Seq.prototype[IS_SEQ_SENTINEL] = true;



	  // #pragma Root Sequences

	  createClass(ArraySeq, IndexedSeq);
	    function ArraySeq(array) {
	      this._array = array;
	      this.size = array.length;
	    }

	    ArraySeq.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._array[wrapIndex(this, index)] : notSetValue;
	    };

	    ArraySeq.prototype.__iterate = function(fn, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(array[reverse ? maxIndex - ii : ii], ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ArraySeq.prototype.__iterator = function(type, reverse) {
	      var array = this._array;
	      var maxIndex = array.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function() 
	        {return ii > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, ii, array[reverse ? maxIndex - ii++ : ii++])}
	      );
	    };



	  createClass(ObjectSeq, KeyedSeq);
	    function ObjectSeq(object) {
	      var keys = Object.keys(object);
	      this._object = object;
	      this._keys = keys;
	      this.size = keys.length;
	    }

	    ObjectSeq.prototype.get = function(key, notSetValue) {
	      if (notSetValue !== undefined && !this.has(key)) {
	        return notSetValue;
	      }
	      return this._object[key];
	    };

	    ObjectSeq.prototype.has = function(key) {
	      return this._object.hasOwnProperty(key);
	    };

	    ObjectSeq.prototype.__iterate = function(fn, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        if (fn(object[key], key, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    ObjectSeq.prototype.__iterator = function(type, reverse) {
	      var object = this._object;
	      var keys = this._keys;
	      var maxIndex = keys.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var key = keys[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, key, object[key]);
	      });
	    };

	  ObjectSeq.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(IterableSeq, IndexedSeq);
	    function IterableSeq(iterable) {
	      this._iterable = iterable;
	      this.size = iterable.length || iterable.size;
	    }

	    IterableSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      var iterations = 0;
	      if (isIterator(iterator)) {
	        var step;
	        while (!(step = iterator.next()).done) {
	          if (fn(step.value, iterations++, this) === false) {
	            break;
	          }
	        }
	      }
	      return iterations;
	    };

	    IterableSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterable = this._iterable;
	      var iterator = getIterator(iterable);
	      if (!isIterator(iterator)) {
	        return new src_Iterator__Iterator(iteratorDone);
	      }
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step : iteratorValue(type, iterations++, step.value);
	      });
	    };



	  createClass(IteratorSeq, IndexedSeq);
	    function IteratorSeq(iterator) {
	      this._iterator = iterator;
	      this._iteratorCache = [];
	    }

	    IteratorSeq.prototype.__iterateUncached = function(fn, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      while (iterations < cache.length) {
	        if (fn(cache[iterations], iterations++, this) === false) {
	          return iterations;
	        }
	      }
	      var step;
	      while (!(step = iterator.next()).done) {
	        var val = step.value;
	        cache[iterations] = val;
	        if (fn(val, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };

	    IteratorSeq.prototype.__iteratorUncached = function(type, reverse) {
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = this._iterator;
	      var cache = this._iteratorCache;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        if (iterations >= cache.length) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          cache[iterations] = step.value;
	        }
	        return iteratorValue(type, iterations, cache[iterations++]);
	      });
	    };




	  // # pragma Helper functions

	  function isSeq(maybeSeq) {
	    return !!(maybeSeq && maybeSeq[IS_SEQ_SENTINEL]);
	  }

	  var EMPTY_SEQ;

	  function emptySequence() {
	    return EMPTY_SEQ || (EMPTY_SEQ = new ArraySeq([]));
	  }

	  function keyedSeqFromValue(value) {
	    var seq =
	      Array.isArray(value) ? new ArraySeq(value).fromEntrySeq() :
	      isIterator(value) ? new IteratorSeq(value).fromEntrySeq() :
	      hasIterator(value) ? new IterableSeq(value).fromEntrySeq() :
	      typeof value === 'object' ? new ObjectSeq(value) :
	      undefined;
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of [k, v] entries, '+
	        'or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function indexedSeqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value);
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values: ' + value
	      );
	    }
	    return seq;
	  }

	  function seqFromValue(value) {
	    var seq = maybeIndexedSeqFromValue(value) ||
	      (typeof value === 'object' && new ObjectSeq(value));
	    if (!seq) {
	      throw new TypeError(
	        'Expected Array or iterable object of values, or keyed object: ' + value
	      );
	    }
	    return seq;
	  }

	  function maybeIndexedSeqFromValue(value) {
	    return (
	      isArrayLike(value) ? new ArraySeq(value) :
	      isIterator(value) ? new IteratorSeq(value) :
	      hasIterator(value) ? new IterableSeq(value) :
	      undefined
	    );
	  }

	  function seqIterate(seq, fn, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        if (fn(entry[1], useKeys ? entry[0] : ii, seq) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    }
	    return seq.__iterateUncached(fn, reverse);
	  }

	  function seqIterator(seq, type, reverse, useKeys) {
	    var cache = seq._cache;
	    if (cache) {
	      var maxIndex = cache.length - 1;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var entry = cache[reverse ? maxIndex - ii : ii];
	        return ii++ > maxIndex ?
	          iteratorDone() :
	          iteratorValue(type, useKeys ? entry[0] : ii - 1, entry[1]);
	      });
	    }
	    return seq.__iteratorUncached(type, reverse);
	  }

	  createClass(Collection, Iterable);
	    function Collection() {
	      throw TypeError('Abstract');
	    }


	  createClass(KeyedCollection, Collection);function KeyedCollection() {}

	  createClass(IndexedCollection, Collection);function IndexedCollection() {}

	  createClass(SetCollection, Collection);function SetCollection() {}


	  Collection.Keyed = KeyedCollection;
	  Collection.Indexed = IndexedCollection;
	  Collection.Set = SetCollection;

	  /**
	   * An extension of the "same-value" algorithm as [described for use by ES6 Map
	   * and Set](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map#Key_equality)
	   *
	   * NaN is considered the same as NaN, however -0 and 0 are considered the same
	   * value, which is different from the algorithm described by
	   * [`Object.is`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is).
	   *
	   * This is extended further to allow Objects to describe the values they
	   * represent, by way of `valueOf` or `equals` (and `hashCode`).
	   *
	   * Note: because of this extension, the key equality of Immutable.Map and the
	   * value equality of Immutable.Set will differ from ES6 Map and Set.
	   *
	   * ### Defining custom values
	   *
	   * The easiest way to describe the value an object represents is by implementing
	   * `valueOf`. For example, `Date` represents a value by returning a unix
	   * timestamp for `valueOf`:
	   *
	   *     var date1 = new Date(1234567890000); // Fri Feb 13 2009 ...
	   *     var date2 = new Date(1234567890000);
	   *     date1.valueOf(); // 1234567890000
	   *     assert( date1 !== date2 );
	   *     assert( Immutable.is( date1, date2 ) );
	   *
	   * Note: overriding `valueOf` may have other implications if you use this object
	   * where JavaScript expects a primitive, such as implicit string coercion.
	   *
	   * For more complex types, especially collections, implementing `valueOf` may
	   * not be performant. An alternative is to implement `equals` and `hashCode`.
	   *
	   * `equals` takes another object, presumably of similar type, and returns true
	   * if the it is equal. Equality is symmetrical, so the same result should be
	   * returned if this and the argument are flipped.
	   *
	   *     assert( a.equals(b) === b.equals(a) );
	   *
	   * `hashCode` returns a 32bit integer number representing the object which will
	   * be used to determine how to store the value object in a Map or Set. You must
	   * provide both or neither methods, one must not exist without the other.
	   *
	   * Also, an important relationship between these methods must be upheld: if two
	   * values are equal, they *must* return the same hashCode. If the values are not
	   * equal, they might have the same hashCode; this is called a hash collision,
	   * and while undesirable for performance reasons, it is acceptable.
	   *
	   *     if (a.equals(b)) {
	   *       assert( a.hashCode() === b.hashCode() );
	   *     }
	   *
	   * All Immutable collections implement `equals` and `hashCode`.
	   *
	   */
	  function is(valueA, valueB) {
	    if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	      return true;
	    }
	    if (!valueA || !valueB) {
	      return false;
	    }
	    if (typeof valueA.valueOf === 'function' &&
	        typeof valueB.valueOf === 'function') {
	      valueA = valueA.valueOf();
	      valueB = valueB.valueOf();
	      if (valueA === valueB || (valueA !== valueA && valueB !== valueB)) {
	        return true;
	      }
	      if (!valueA || !valueB) {
	        return false;
	      }
	    }
	    if (typeof valueA.equals === 'function' &&
	        typeof valueB.equals === 'function' &&
	        valueA.equals(valueB)) {
	      return true;
	    }
	    return false;
	  }

	  function fromJS(json, converter) {
	    return converter ?
	      fromJSWith(converter, json, '', {'': json}) :
	      fromJSDefault(json);
	  }

	  function fromJSWith(converter, json, key, parentJSON) {
	    if (Array.isArray(json)) {
	      return converter.call(parentJSON, key, IndexedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    if (isPlainObj(json)) {
	      return converter.call(parentJSON, key, KeyedSeq(json).map(function(v, k)  {return fromJSWith(converter, v, k, json)}));
	    }
	    return json;
	  }

	  function fromJSDefault(json) {
	    if (Array.isArray(json)) {
	      return IndexedSeq(json).map(fromJSDefault).toList();
	    }
	    if (isPlainObj(json)) {
	      return KeyedSeq(json).map(fromJSDefault).toMap();
	    }
	    return json;
	  }

	  function isPlainObj(value) {
	    return value && (value.constructor === Object || value.constructor === undefined);
	  }

	  var src_Math__imul =
	    typeof Math.imul === 'function' && Math.imul(0xffffffff, 2) === -2 ?
	    Math.imul :
	    function imul(a, b) {
	      a = a | 0; // int
	      b = b | 0; // int
	      var c = a & 0xffff;
	      var d = b & 0xffff;
	      // Shift by 0 fixes the sign on the high part.
	      return (c * d) + ((((a >>> 16) * d + c * (b >>> 16)) << 16) >>> 0) | 0; // int
	    };

	  // v8 has an optimization for storing 31-bit signed numbers.
	  // Values which have either 00 or 11 as the high order bits qualify.
	  // This function drops the highest order bit in a signed number, maintaining
	  // the sign bit.
	  function smi(i32) {
	    return ((i32 >>> 1) & 0x40000000) | (i32 & 0xBFFFFFFF);
	  }

	  function hash(o) {
	    if (o === false || o === null || o === undefined) {
	      return 0;
	    }
	    if (typeof o.valueOf === 'function') {
	      o = o.valueOf();
	      if (o === false || o === null || o === undefined) {
	        return 0;
	      }
	    }
	    if (o === true) {
	      return 1;
	    }
	    var type = typeof o;
	    if (type === 'number') {
	      var h = o | 0;
	      if (h !== o) {
	        h ^= o * 0xFFFFFFFF;
	      }
	      while (o > 0xFFFFFFFF) {
	        o /= 0xFFFFFFFF;
	        h ^= o;
	      }
	      return smi(h);
	    }
	    if (type === 'string') {
	      return o.length > STRING_HASH_CACHE_MIN_STRLEN ? cachedHashString(o) : hashString(o);
	    }
	    if (typeof o.hashCode === 'function') {
	      return o.hashCode();
	    }
	    return hashJSObj(o);
	  }

	  function cachedHashString(string) {
	    var hash = stringHashCache[string];
	    if (hash === undefined) {
	      hash = hashString(string);
	      if (STRING_HASH_CACHE_SIZE === STRING_HASH_CACHE_MAX_SIZE) {
	        STRING_HASH_CACHE_SIZE = 0;
	        stringHashCache = {};
	      }
	      STRING_HASH_CACHE_SIZE++;
	      stringHashCache[string] = hash;
	    }
	    return hash;
	  }

	  // http://jsperf.com/hashing-strings
	  function hashString(string) {
	    // This is the hash from JVM
	    // The hash code for a string is computed as
	    // s[0] * 31 ^ (n - 1) + s[1] * 31 ^ (n - 2) + ... + s[n - 1],
	    // where s[i] is the ith character of the string and n is the length of
	    // the string. We "mod" the result to make it between 0 (inclusive) and 2^31
	    // (exclusive) by dropping high bits.
	    var hash = 0;
	    for (var ii = 0; ii < string.length; ii++) {
	      hash = 31 * hash + string.charCodeAt(ii) | 0;
	    }
	    return smi(hash);
	  }

	  function hashJSObj(obj) {
	    var hash;
	    if (usingWeakMap) {
	      hash = weakMap.get(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = obj[UID_HASH_KEY];
	    if (hash !== undefined) {
	      return hash;
	    }

	    if (!canDefineProperty) {
	      hash = obj.propertyIsEnumerable && obj.propertyIsEnumerable[UID_HASH_KEY];
	      if (hash !== undefined) {
	        return hash;
	      }

	      hash = getIENodeHash(obj);
	      if (hash !== undefined) {
	        return hash;
	      }
	    }

	    hash = ++objHashUID;
	    if (objHashUID & 0x40000000) {
	      objHashUID = 0;
	    }

	    if (usingWeakMap) {
	      weakMap.set(obj, hash);
	    } else if (isExtensible !== undefined && isExtensible(obj) === false) {
	      throw new Error('Non-extensible objects are not allowed as keys.');
	    } else if (canDefineProperty) {
	      Object.defineProperty(obj, UID_HASH_KEY, {
	        'enumerable': false,
	        'configurable': false,
	        'writable': false,
	        'value': hash
	      });
	    } else if (obj.propertyIsEnumerable !== undefined &&
	               obj.propertyIsEnumerable === obj.constructor.prototype.propertyIsEnumerable) {
	      // Since we can't define a non-enumerable property on the object
	      // we'll hijack one of the less-used non-enumerable properties to
	      // save our hash on it. Since this is a function it will not show up in
	      // `JSON.stringify` which is what we want.
	      obj.propertyIsEnumerable = function() {
	        return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments);
	      };
	      obj.propertyIsEnumerable[UID_HASH_KEY] = hash;
	    } else if (obj.nodeType !== undefined) {
	      // At this point we couldn't get the IE `uniqueID` to use as a hash
	      // and we couldn't use a non-enumerable property to exploit the
	      // dontEnum bug so we simply add the `UID_HASH_KEY` on the node
	      // itself.
	      obj[UID_HASH_KEY] = hash;
	    } else {
	      throw new Error('Unable to set a non-enumerable property on object.');
	    }

	    return hash;
	  }

	  // Get references to ES5 object methods.
	  var isExtensible = Object.isExtensible;

	  // True if Object.defineProperty works as expected. IE8 fails this test.
	  var canDefineProperty = (function() {
	    try {
	      Object.defineProperty({}, '@', {});
	      return true;
	    } catch (e) {
	      return false;
	    }
	  }());

	  // IE has a `uniqueID` property on DOM nodes. We can construct the hash from it
	  // and avoid memory leaks from the IE cloneNode bug.
	  function getIENodeHash(node) {
	    if (node && node.nodeType > 0) {
	      switch (node.nodeType) {
	        case 1: // Element
	          return node.uniqueID;
	        case 9: // Document
	          return node.documentElement && node.documentElement.uniqueID;
	      }
	    }
	  }

	  // If possible, use a WeakMap.
	  var usingWeakMap = typeof WeakMap === 'function';
	  var weakMap;
	  if (usingWeakMap) {
	    weakMap = new WeakMap();
	  }

	  var objHashUID = 0;

	  var UID_HASH_KEY = '__immutablehash__';
	  if (typeof Symbol === 'function') {
	    UID_HASH_KEY = Symbol(UID_HASH_KEY);
	  }

	  var STRING_HASH_CACHE_MIN_STRLEN = 16;
	  var STRING_HASH_CACHE_MAX_SIZE = 255;
	  var STRING_HASH_CACHE_SIZE = 0;
	  var stringHashCache = {};

	  function invariant(condition, error) {
	    if (!condition) throw new Error(error);
	  }

	  function assertNotInfinite(size) {
	    invariant(
	      size !== Infinity,
	      'Cannot perform this action with an infinite size.'
	    );
	  }

	  createClass(ToKeyedSequence, KeyedSeq);
	    function ToKeyedSequence(indexed, useKeys) {
	      this._iter = indexed;
	      this._useKeys = useKeys;
	      this.size = indexed.size;
	    }

	    ToKeyedSequence.prototype.get = function(key, notSetValue) {
	      return this._iter.get(key, notSetValue);
	    };

	    ToKeyedSequence.prototype.has = function(key) {
	      return this._iter.has(key);
	    };

	    ToKeyedSequence.prototype.valueSeq = function() {
	      return this._iter.valueSeq();
	    };

	    ToKeyedSequence.prototype.reverse = function() {var this$0 = this;
	      var reversedSequence = reverseFactory(this, true);
	      if (!this._useKeys) {
	        reversedSequence.valueSeq = function()  {return this$0._iter.toSeq().reverse()};
	      }
	      return reversedSequence;
	    };

	    ToKeyedSequence.prototype.map = function(mapper, context) {var this$0 = this;
	      var mappedSequence = mapFactory(this, mapper, context);
	      if (!this._useKeys) {
	        mappedSequence.valueSeq = function()  {return this$0._iter.toSeq().map(mapper, context)};
	      }
	      return mappedSequence;
	    };

	    ToKeyedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var ii;
	      return this._iter.__iterate(
	        this._useKeys ?
	          function(v, k)  {return fn(v, k, this$0)} :
	          ((ii = reverse ? resolveSize(this) : 0),
	            function(v ) {return fn(v, reverse ? --ii : ii++, this$0)}),
	        reverse
	      );
	    };

	    ToKeyedSequence.prototype.__iterator = function(type, reverse) {
	      if (this._useKeys) {
	        return this._iter.__iterator(type, reverse);
	      }
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var ii = reverse ? resolveSize(this) : 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, reverse ? --ii : ii++, step.value, step);
	      });
	    };

	  ToKeyedSequence.prototype[IS_ORDERED_SENTINEL] = true;


	  createClass(ToIndexedSequence, IndexedSeq);
	    function ToIndexedSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToIndexedSequence.prototype.includes = function(value) {
	      return this._iter.includes(value);
	    };

	    ToIndexedSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      return this._iter.__iterate(function(v ) {return fn(v, iterations++, this$0)}, reverse);
	    };

	    ToIndexedSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, iterations++, step.value, step)
	      });
	    };



	  createClass(ToSetSequence, SetSeq);
	    function ToSetSequence(iter) {
	      this._iter = iter;
	      this.size = iter.size;
	    }

	    ToSetSequence.prototype.has = function(key) {
	      return this._iter.includes(key);
	    };

	    ToSetSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(v ) {return fn(v, v, this$0)}, reverse);
	    };

	    ToSetSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        return step.done ? step :
	          iteratorValue(type, step.value, step.value, step);
	      });
	    };



	  createClass(FromEntriesSequence, KeyedSeq);
	    function FromEntriesSequence(entries) {
	      this._iter = entries;
	      this.size = entries.size;
	    }

	    FromEntriesSequence.prototype.entrySeq = function() {
	      return this._iter.toSeq();
	    };

	    FromEntriesSequence.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._iter.__iterate(function(entry ) {
	        // Check if entry exists first so array access doesn't throw for holes
	        // in the parent iteration.
	        if (entry) {
	          validateEntry(entry);
	          var indexedIterable = isIterable(entry);
	          return fn(
	            indexedIterable ? entry.get(1) : entry[1],
	            indexedIterable ? entry.get(0) : entry[0],
	            this$0
	          );
	        }
	      }, reverse);
	    };

	    FromEntriesSequence.prototype.__iterator = function(type, reverse) {
	      var iterator = this._iter.__iterator(ITERATE_VALUES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          // Check if entry exists first so array access doesn't throw for holes
	          // in the parent iteration.
	          if (entry) {
	            validateEntry(entry);
	            var indexedIterable = isIterable(entry);
	            return iteratorValue(
	              type,
	              indexedIterable ? entry.get(0) : entry[0],
	              indexedIterable ? entry.get(1) : entry[1],
	              step
	            );
	          }
	        }
	      });
	    };


	  ToIndexedSequence.prototype.cacheResult =
	  ToKeyedSequence.prototype.cacheResult =
	  ToSetSequence.prototype.cacheResult =
	  FromEntriesSequence.prototype.cacheResult =
	    cacheResultThrough;


	  function flipFactory(iterable) {
	    var flipSequence = makeSequence(iterable);
	    flipSequence._iter = iterable;
	    flipSequence.size = iterable.size;
	    flipSequence.flip = function()  {return iterable};
	    flipSequence.reverse = function () {
	      var reversedSequence = iterable.reverse.apply(this); // super.reverse()
	      reversedSequence.flip = function()  {return iterable.reverse()};
	      return reversedSequence;
	    };
	    flipSequence.has = function(key ) {return iterable.includes(key)};
	    flipSequence.includes = function(key ) {return iterable.has(key)};
	    flipSequence.cacheResult = cacheResultThrough;
	    flipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(k, v, this$0) !== false}, reverse);
	    }
	    flipSequence.__iteratorUncached = function(type, reverse) {
	      if (type === ITERATE_ENTRIES) {
	        var iterator = iterable.__iterator(type, reverse);
	        return new src_Iterator__Iterator(function()  {
	          var step = iterator.next();
	          if (!step.done) {
	            var k = step.value[0];
	            step.value[0] = step.value[1];
	            step.value[1] = k;
	          }
	          return step;
	        });
	      }
	      return iterable.__iterator(
	        type === ITERATE_VALUES ? ITERATE_KEYS : ITERATE_VALUES,
	        reverse
	      );
	    }
	    return flipSequence;
	  }


	  function mapFactory(iterable, mapper, context) {
	    var mappedSequence = makeSequence(iterable);
	    mappedSequence.size = iterable.size;
	    mappedSequence.has = function(key ) {return iterable.has(key)};
	    mappedSequence.get = function(key, notSetValue)  {
	      var v = iterable.get(key, NOT_SET);
	      return v === NOT_SET ?
	        notSetValue :
	        mapper.call(context, v, key, iterable);
	    };
	    mappedSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(
	        function(v, k, c)  {return fn(mapper.call(context, v, k, c), k, this$0) !== false},
	        reverse
	      );
	    }
	    mappedSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var key = entry[0];
	        return iteratorValue(
	          type,
	          key,
	          mapper.call(context, entry[1], key, iterable),
	          step
	        );
	      });
	    }
	    return mappedSequence;
	  }


	  function reverseFactory(iterable, useKeys) {
	    var reversedSequence = makeSequence(iterable);
	    reversedSequence._iter = iterable;
	    reversedSequence.size = iterable.size;
	    reversedSequence.reverse = function()  {return iterable};
	    if (iterable.flip) {
	      reversedSequence.flip = function () {
	        var flipSequence = flipFactory(iterable);
	        flipSequence.reverse = function()  {return iterable.flip()};
	        return flipSequence;
	      };
	    }
	    reversedSequence.get = function(key, notSetValue) 
	      {return iterable.get(useKeys ? key : -1 - key, notSetValue)};
	    reversedSequence.has = function(key )
	      {return iterable.has(useKeys ? key : -1 - key)};
	    reversedSequence.includes = function(value ) {return iterable.includes(value)};
	    reversedSequence.cacheResult = cacheResultThrough;
	    reversedSequence.__iterate = function (fn, reverse) {var this$0 = this;
	      return iterable.__iterate(function(v, k)  {return fn(v, k, this$0)}, !reverse);
	    };
	    reversedSequence.__iterator =
	      function(type, reverse)  {return iterable.__iterator(type, !reverse)};
	    return reversedSequence;
	  }


	  function filterFactory(iterable, predicate, context, useKeys) {
	    var filterSequence = makeSequence(iterable);
	    if (useKeys) {
	      filterSequence.has = function(key ) {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && !!predicate.call(context, v, key, iterable);
	      };
	      filterSequence.get = function(key, notSetValue)  {
	        var v = iterable.get(key, NOT_SET);
	        return v !== NOT_SET && predicate.call(context, v, key, iterable) ?
	          v : notSetValue;
	      };
	    }
	    filterSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      }, reverse);
	      return iterations;
	    };
	    filterSequence.__iteratorUncached = function (type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (true) {
	          var step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	          var entry = step.value;
	          var key = entry[0];
	          var value = entry[1];
	          if (predicate.call(context, value, key, iterable)) {
	            return iteratorValue(type, useKeys ? key : iterations++, value, step);
	          }
	        }
	      });
	    }
	    return filterSequence;
	  }


	  function countByFactory(iterable, grouper, context) {
	    var groups = src_Map__Map().asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        0,
	        function(a ) {return a + 1}
	      );
	    });
	    return groups.asImmutable();
	  }


	  function groupByFactory(iterable, grouper, context) {
	    var isKeyedIter = isKeyed(iterable);
	    var groups = (isOrdered(iterable) ? OrderedMap() : src_Map__Map()).asMutable();
	    iterable.__iterate(function(v, k)  {
	      groups.update(
	        grouper.call(context, v, k, iterable),
	        function(a ) {return (a = a || [], a.push(isKeyedIter ? [k, v] : v), a)}
	      );
	    });
	    var coerce = iterableClass(iterable);
	    return groups.map(function(arr ) {return reify(iterable, coerce(arr))});
	  }


	  function sliceFactory(iterable, begin, end, useKeys) {
	    var originalSize = iterable.size;

	    if (wholeSlice(begin, end, originalSize)) {
	      return iterable;
	    }

	    var resolvedBegin = resolveBegin(begin, originalSize);
	    var resolvedEnd = resolveEnd(end, originalSize);

	    // begin or end will be NaN if they were provided as negative numbers and
	    // this iterable's size is unknown. In that case, cache first so there is
	    // a known size and these do not resolve to NaN.
	    if (resolvedBegin !== resolvedBegin || resolvedEnd !== resolvedEnd) {
	      return sliceFactory(iterable.toSeq().cacheResult(), begin, end, useKeys);
	    }

	    // Note: resolvedEnd is undefined when the original sequence's length is
	    // unknown and this slice did not supply an end and should contain all
	    // elements after resolvedBegin.
	    // In that case, resolvedSize will be NaN and sliceSize will remain undefined.
	    var resolvedSize = resolvedEnd - resolvedBegin;
	    var sliceSize;
	    if (resolvedSize === resolvedSize) {
	      sliceSize = resolvedSize < 0 ? 0 : resolvedSize;
	    }

	    var sliceSeq = makeSequence(iterable);

	    sliceSeq.size = sliceSize;

	    if (!useKeys && isSeq(iterable) && sliceSize >= 0) {
	      sliceSeq.get = function (index, notSetValue) {
	        index = wrapIndex(this, index);
	        return index >= 0 && index < sliceSize ?
	          iterable.get(index + resolvedBegin, notSetValue) :
	          notSetValue;
	      }
	    }

	    sliceSeq.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (sliceSize === 0) {
	        return 0;
	      }
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var skipped = 0;
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k)  {
	        if (!(isSkipping && (isSkipping = skipped++ < resolvedBegin))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0) !== false &&
	                 iterations !== sliceSize;
	        }
	      });
	      return iterations;
	    };

	    sliceSeq.__iteratorUncached = function(type, reverse) {
	      if (sliceSize !== 0 && reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      // Don't bother instantiating parent iterator if taking 0.
	      var iterator = sliceSize !== 0 && iterable.__iterator(type, reverse);
	      var skipped = 0;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (skipped++ < resolvedBegin) {
	          iterator.next();
	        }
	        if (++iterations > sliceSize) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (useKeys || type === ITERATE_VALUES) {
	          return step;
	        } else if (type === ITERATE_KEYS) {
	          return iteratorValue(type, iterations - 1, undefined, step);
	        } else {
	          return iteratorValue(type, iterations - 1, step.value[1], step);
	        }
	      });
	    }

	    return sliceSeq;
	  }


	  function takeWhileFactory(iterable, predicate, context) {
	    var takeSequence = makeSequence(iterable);
	    takeSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c) 
	        {return predicate.call(context, v, k, c) && ++iterations && fn(v, k, this$0)}
	      );
	      return iterations;
	    };
	    takeSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var iterating = true;
	      return new src_Iterator__Iterator(function()  {
	        if (!iterating) {
	          return iteratorDone();
	        }
	        var step = iterator.next();
	        if (step.done) {
	          return step;
	        }
	        var entry = step.value;
	        var k = entry[0];
	        var v = entry[1];
	        if (!predicate.call(context, v, k, this$0)) {
	          iterating = false;
	          return iteratorDone();
	        }
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return takeSequence;
	  }


	  function skipWhileFactory(iterable, predicate, context, useKeys) {
	    var skipSequence = makeSequence(iterable);
	    skipSequence.__iterateUncached = function (fn, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterate(fn, reverse);
	      }
	      var isSkipping = true;
	      var iterations = 0;
	      iterable.__iterate(function(v, k, c)  {
	        if (!(isSkipping && (isSkipping = predicate.call(context, v, k, c)))) {
	          iterations++;
	          return fn(v, useKeys ? k : iterations - 1, this$0);
	        }
	      });
	      return iterations;
	    };
	    skipSequence.__iteratorUncached = function(type, reverse) {var this$0 = this;
	      if (reverse) {
	        return this.cacheResult().__iterator(type, reverse);
	      }
	      var iterator = iterable.__iterator(ITERATE_ENTRIES, reverse);
	      var skipping = true;
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        var step, k, v;
	        do {
	          step = iterator.next();
	          if (step.done) {
	            if (useKeys || type === ITERATE_VALUES) {
	              return step;
	            } else if (type === ITERATE_KEYS) {
	              return iteratorValue(type, iterations++, undefined, step);
	            } else {
	              return iteratorValue(type, iterations++, step.value[1], step);
	            }
	          }
	          var entry = step.value;
	          k = entry[0];
	          v = entry[1];
	          skipping && (skipping = predicate.call(context, v, k, this$0));
	        } while (skipping);
	        return type === ITERATE_ENTRIES ? step :
	          iteratorValue(type, k, v, step);
	      });
	    };
	    return skipSequence;
	  }


	  function concatFactory(iterable, values) {
	    var isKeyedIterable = isKeyed(iterable);
	    var iters = [iterable].concat(values).map(function(v ) {
	      if (!isIterable(v)) {
	        v = isKeyedIterable ?
	          keyedSeqFromValue(v) :
	          indexedSeqFromValue(Array.isArray(v) ? v : [v]);
	      } else if (isKeyedIterable) {
	        v = KeyedIterable(v);
	      }
	      return v;
	    }).filter(function(v ) {return v.size !== 0});

	    if (iters.length === 0) {
	      return iterable;
	    }

	    if (iters.length === 1) {
	      var singleton = iters[0];
	      if (singleton === iterable ||
	          isKeyedIterable && isKeyed(singleton) ||
	          isIndexed(iterable) && isIndexed(singleton)) {
	        return singleton;
	      }
	    }

	    var concatSeq = new ArraySeq(iters);
	    if (isKeyedIterable) {
	      concatSeq = concatSeq.toKeyedSeq();
	    } else if (!isIndexed(iterable)) {
	      concatSeq = concatSeq.toSetSeq();
	    }
	    concatSeq = concatSeq.flatten(true);
	    concatSeq.size = iters.reduce(
	      function(sum, seq)  {
	        if (sum !== undefined) {
	          var size = seq.size;
	          if (size !== undefined) {
	            return sum + size;
	          }
	        }
	      },
	      0
	    );
	    return concatSeq;
	  }


	  function flattenFactory(iterable, depth, useKeys) {
	    var flatSequence = makeSequence(iterable);
	    flatSequence.__iterateUncached = function(fn, reverse) {
	      var iterations = 0;
	      var stopped = false;
	      function flatDeep(iter, currentDepth) {var this$0 = this;
	        iter.__iterate(function(v, k)  {
	          if ((!depth || currentDepth < depth) && isIterable(v)) {
	            flatDeep(v, currentDepth + 1);
	          } else if (fn(v, useKeys ? k : iterations++, this$0) === false) {
	            stopped = true;
	          }
	          return !stopped;
	        }, reverse);
	      }
	      flatDeep(iterable, 0);
	      return iterations;
	    }
	    flatSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(type, reverse);
	      var stack = [];
	      var iterations = 0;
	      return new src_Iterator__Iterator(function()  {
	        while (iterator) {
	          var step = iterator.next();
	          if (step.done !== false) {
	            iterator = stack.pop();
	            continue;
	          }
	          var v = step.value;
	          if (type === ITERATE_ENTRIES) {
	            v = v[1];
	          }
	          if ((!depth || stack.length < depth) && isIterable(v)) {
	            stack.push(iterator);
	            iterator = v.__iterator(type, reverse);
	          } else {
	            return useKeys ? step : iteratorValue(type, iterations++, v, step);
	          }
	        }
	        return iteratorDone();
	      });
	    }
	    return flatSequence;
	  }


	  function flatMapFactory(iterable, mapper, context) {
	    var coerce = iterableClass(iterable);
	    return iterable.toSeq().map(
	      function(v, k)  {return coerce(mapper.call(context, v, k, iterable))}
	    ).flatten(true);
	  }


	  function interposeFactory(iterable, separator) {
	    var interposedSequence = makeSequence(iterable);
	    interposedSequence.size = iterable.size && iterable.size * 2 -1;
	    interposedSequence.__iterateUncached = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      iterable.__iterate(function(v, k) 
	        {return (!iterations || fn(separator, iterations++, this$0) !== false) &&
	        fn(v, iterations++, this$0) !== false},
	        reverse
	      );
	      return iterations;
	    };
	    interposedSequence.__iteratorUncached = function(type, reverse) {
	      var iterator = iterable.__iterator(ITERATE_VALUES, reverse);
	      var iterations = 0;
	      var step;
	      return new src_Iterator__Iterator(function()  {
	        if (!step || iterations % 2) {
	          step = iterator.next();
	          if (step.done) {
	            return step;
	          }
	        }
	        return iterations % 2 ?
	          iteratorValue(type, iterations++, separator) :
	          iteratorValue(type, iterations++, step.value, step);
	      });
	    };
	    return interposedSequence;
	  }


	  function sortFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    var isKeyedIterable = isKeyed(iterable);
	    var index = 0;
	    var entries = iterable.toSeq().map(
	      function(v, k)  {return [k, v, index++, mapper ? mapper(v, k, iterable) : v]}
	    ).toArray();
	    entries.sort(function(a, b)  {return comparator(a[3], b[3]) || a[2] - b[2]}).forEach(
	      isKeyedIterable ?
	      function(v, i)  { entries[i].length = 2; } :
	      function(v, i)  { entries[i] = v[1]; }
	    );
	    return isKeyedIterable ? KeyedSeq(entries) :
	      isIndexed(iterable) ? IndexedSeq(entries) :
	      SetSeq(entries);
	  }


	  function maxFactory(iterable, comparator, mapper) {
	    if (!comparator) {
	      comparator = defaultComparator;
	    }
	    if (mapper) {
	      var entry = iterable.toSeq()
	        .map(function(v, k)  {return [v, mapper(v, k, iterable)]})
	        .reduce(function(a, b)  {return maxCompare(comparator, a[1], b[1]) ? b : a});
	      return entry && entry[0];
	    } else {
	      return iterable.reduce(function(a, b)  {return maxCompare(comparator, a, b) ? b : a});
	    }
	  }

	  function maxCompare(comparator, a, b) {
	    var comp = comparator(b, a);
	    // b is considered the new max if the comparator declares them equal, but
	    // they are not equal and b is in fact a nullish value.
	    return (comp === 0 && b !== a && (b === undefined || b === null || b !== b)) || comp > 0;
	  }


	  function zipWithFactory(keyIter, zipper, iters) {
	    var zipSequence = makeSequence(keyIter);
	    zipSequence.size = new ArraySeq(iters).map(function(i ) {return i.size}).min();
	    // Note: this a generic base implementation of __iterate in terms of
	    // __iterator which may be more generically useful in the future.
	    zipSequence.__iterate = function(fn, reverse) {
	      /* generic:
	      var iterator = this.__iterator(ITERATE_ENTRIES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        iterations++;
	        if (fn(step.value[1], step.value[0], this) === false) {
	          break;
	        }
	      }
	      return iterations;
	      */
	      // indexed:
	      var iterator = this.__iterator(ITERATE_VALUES, reverse);
	      var step;
	      var iterations = 0;
	      while (!(step = iterator.next()).done) {
	        if (fn(step.value, iterations++, this) === false) {
	          break;
	        }
	      }
	      return iterations;
	    };
	    zipSequence.__iteratorUncached = function(type, reverse) {
	      var iterators = iters.map(function(i )
	        {return (i = Iterable(i), getIterator(reverse ? i.reverse() : i))}
	      );
	      var iterations = 0;
	      var isDone = false;
	      return new src_Iterator__Iterator(function()  {
	        var steps;
	        if (!isDone) {
	          steps = iterators.map(function(i ) {return i.next()});
	          isDone = steps.some(function(s ) {return s.done});
	        }
	        if (isDone) {
	          return iteratorDone();
	        }
	        return iteratorValue(
	          type,
	          iterations++,
	          zipper.apply(null, steps.map(function(s ) {return s.value}))
	        );
	      });
	    };
	    return zipSequence
	  }


	  // #pragma Helper Functions

	  function reify(iter, seq) {
	    return isSeq(iter) ? seq : iter.constructor(seq);
	  }

	  function validateEntry(entry) {
	    if (entry !== Object(entry)) {
	      throw new TypeError('Expected [K, V] tuple: ' + entry);
	    }
	  }

	  function resolveSize(iter) {
	    assertNotInfinite(iter.size);
	    return ensureSize(iter);
	  }

	  function iterableClass(iterable) {
	    return isKeyed(iterable) ? KeyedIterable :
	      isIndexed(iterable) ? IndexedIterable :
	      SetIterable;
	  }

	  function makeSequence(iterable) {
	    return Object.create(
	      (
	        isKeyed(iterable) ? KeyedSeq :
	        isIndexed(iterable) ? IndexedSeq :
	        SetSeq
	      ).prototype
	    );
	  }

	  function cacheResultThrough() {
	    if (this._iter.cacheResult) {
	      this._iter.cacheResult();
	      this.size = this._iter.size;
	      return this;
	    } else {
	      return Seq.prototype.cacheResult.call(this);
	    }
	  }

	  function defaultComparator(a, b) {
	    return a > b ? 1 : a < b ? -1 : 0;
	  }

	  function forceIterator(keyPath) {
	    var iter = getIterator(keyPath);
	    if (!iter) {
	      // Array might not be iterable in this environment, so we need a fallback
	      // to our wrapped type.
	      if (!isArrayLike(keyPath)) {
	        throw new TypeError('Expected iterable or array-like: ' + keyPath);
	      }
	      iter = getIterator(Iterable(keyPath));
	    }
	    return iter;
	  }

	  createClass(src_Map__Map, KeyedCollection);

	    // @pragma Construction

	    function src_Map__Map(value) {
	      return value === null || value === undefined ? emptyMap() :
	        isMap(value) ? value :
	        emptyMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    src_Map__Map.prototype.toString = function() {
	      return this.__toString('Map {', '}');
	    };

	    // @pragma Access

	    src_Map__Map.prototype.get = function(k, notSetValue) {
	      return this._root ?
	        this._root.get(0, undefined, k, notSetValue) :
	        notSetValue;
	    };

	    // @pragma Modification

	    src_Map__Map.prototype.set = function(k, v) {
	      return updateMap(this, k, v);
	    };

	    src_Map__Map.prototype.setIn = function(keyPath, v) {
	      return this.updateIn(keyPath, NOT_SET, function()  {return v});
	    };

	    src_Map__Map.prototype.remove = function(k) {
	      return updateMap(this, k, NOT_SET);
	    };

	    src_Map__Map.prototype.deleteIn = function(keyPath) {
	      return this.updateIn(keyPath, function()  {return NOT_SET});
	    };

	    src_Map__Map.prototype.update = function(k, notSetValue, updater) {
	      return arguments.length === 1 ?
	        k(this) :
	        this.updateIn([k], notSetValue, updater);
	    };

	    src_Map__Map.prototype.updateIn = function(keyPath, notSetValue, updater) {
	      if (!updater) {
	        updater = notSetValue;
	        notSetValue = undefined;
	      }
	      var updatedValue = updateInDeepMap(
	        this,
	        forceIterator(keyPath),
	        notSetValue,
	        updater
	      );
	      return updatedValue === NOT_SET ? undefined : updatedValue;
	    };

	    src_Map__Map.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._root = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyMap();
	    };

	    // @pragma Composition

	    src_Map__Map.prototype.merge = function(/*...iters*/) {
	      return mergeIntoMapWith(this, undefined, arguments);
	    };

	    src_Map__Map.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, merger, iters);
	    };

	    src_Map__Map.prototype.mergeIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.merge === 'function' ?
	          m.merge.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    src_Map__Map.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoMapWith(this, deepMerger(undefined), arguments);
	    };

	    src_Map__Map.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoMapWith(this, deepMerger(merger), iters);
	    };

	    src_Map__Map.prototype.mergeDeepIn = function(keyPath) {var iters = SLICE$0.call(arguments, 1);
	      return this.updateIn(
	        keyPath,
	        emptyMap(),
	        function(m ) {return typeof m.mergeDeep === 'function' ?
	          m.mergeDeep.apply(m, iters) :
	          iters[iters.length - 1]}
	      );
	    };

	    src_Map__Map.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator));
	    };

	    src_Map__Map.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedMap(sortFactory(this, comparator, mapper));
	    };

	    // @pragma Mutability

	    src_Map__Map.prototype.withMutations = function(fn) {
	      var mutable = this.asMutable();
	      fn(mutable);
	      return mutable.wasAltered() ? mutable.__ensureOwner(this.__ownerID) : this;
	    };

	    src_Map__Map.prototype.asMutable = function() {
	      return this.__ownerID ? this : this.__ensureOwner(new OwnerID());
	    };

	    src_Map__Map.prototype.asImmutable = function() {
	      return this.__ensureOwner();
	    };

	    src_Map__Map.prototype.wasAltered = function() {
	      return this.__altered;
	    };

	    src_Map__Map.prototype.__iterator = function(type, reverse) {
	      return new MapIterator(this, type, reverse);
	    };

	    src_Map__Map.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      var iterations = 0;
	      this._root && this._root.iterate(function(entry ) {
	        iterations++;
	        return fn(entry[1], entry[0], this$0);
	      }, reverse);
	      return iterations;
	    };

	    src_Map__Map.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeMap(this.size, this._root, ownerID, this.__hash);
	    };


	  function isMap(maybeMap) {
	    return !!(maybeMap && maybeMap[IS_MAP_SENTINEL]);
	  }

	  src_Map__Map.isMap = isMap;

	  var IS_MAP_SENTINEL = '@@__IMMUTABLE_MAP__@@';

	  var MapPrototype = src_Map__Map.prototype;
	  MapPrototype[IS_MAP_SENTINEL] = true;
	  MapPrototype[DELETE] = MapPrototype.remove;
	  MapPrototype.removeIn = MapPrototype.deleteIn;


	  // #pragma Trie Nodes



	    function ArrayMapNode(ownerID, entries) {
	      this.ownerID = ownerID;
	      this.entries = entries;
	    }

	    ArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    ArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && entries.length === 1) {
	        return; // undefined
	      }

	      if (!exists && !removed && entries.length >= MAX_ARRAY_MAP_SIZE) {
	        return createNodes(ownerID, entries, key, value);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new ArrayMapNode(ownerID, newEntries);
	    };




	    function BitmapIndexedNode(ownerID, bitmap, nodes) {
	      this.ownerID = ownerID;
	      this.bitmap = bitmap;
	      this.nodes = nodes;
	    }

	    BitmapIndexedNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var bit = (1 << ((shift === 0 ? keyHash : keyHash >>> shift) & MASK));
	      var bitmap = this.bitmap;
	      return (bitmap & bit) === 0 ? notSetValue :
	        this.nodes[popCount(bitmap & (bit - 1))].get(shift + SHIFT, keyHash, key, notSetValue);
	    };

	    BitmapIndexedNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var keyHashFrag = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var bit = 1 << keyHashFrag;
	      var bitmap = this.bitmap;
	      var exists = (bitmap & bit) !== 0;

	      if (!exists && value === NOT_SET) {
	        return this;
	      }

	      var idx = popCount(bitmap & (bit - 1));
	      var nodes = this.nodes;
	      var node = exists ? nodes[idx] : undefined;
	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);

	      if (newNode === node) {
	        return this;
	      }

	      if (!exists && newNode && nodes.length >= MAX_BITMAP_INDEXED_SIZE) {
	        return expandNodes(ownerID, nodes, bitmap, keyHashFrag, newNode);
	      }

	      if (exists && !newNode && nodes.length === 2 && isLeafNode(nodes[idx ^ 1])) {
	        return nodes[idx ^ 1];
	      }

	      if (exists && newNode && nodes.length === 1 && isLeafNode(newNode)) {
	        return newNode;
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newBitmap = exists ? newNode ? bitmap : bitmap ^ bit : bitmap | bit;
	      var newNodes = exists ? newNode ?
	        setIn(nodes, idx, newNode, isEditable) :
	        spliceOut(nodes, idx, isEditable) :
	        spliceIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.bitmap = newBitmap;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new BitmapIndexedNode(ownerID, newBitmap, newNodes);
	    };




	    function HashArrayMapNode(ownerID, count, nodes) {
	      this.ownerID = ownerID;
	      this.count = count;
	      this.nodes = nodes;
	    }

	    HashArrayMapNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var node = this.nodes[idx];
	      return node ? node.get(shift + SHIFT, keyHash, key, notSetValue) : notSetValue;
	    };

	    HashArrayMapNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }
	      var idx = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;
	      var removed = value === NOT_SET;
	      var nodes = this.nodes;
	      var node = nodes[idx];

	      if (removed && !node) {
	        return this;
	      }

	      var newNode = updateNode(node, ownerID, shift + SHIFT, keyHash, key, value, didChangeSize, didAlter);
	      if (newNode === node) {
	        return this;
	      }

	      var newCount = this.count;
	      if (!node) {
	        newCount++;
	      } else if (!newNode) {
	        newCount--;
	        if (newCount < MIN_HASH_ARRAY_MAP_SIZE) {
	          return packNodes(ownerID, nodes, newCount, idx);
	        }
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newNodes = setIn(nodes, idx, newNode, isEditable);

	      if (isEditable) {
	        this.count = newCount;
	        this.nodes = newNodes;
	        return this;
	      }

	      return new HashArrayMapNode(ownerID, newCount, newNodes);
	    };




	    function HashCollisionNode(ownerID, keyHash, entries) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entries = entries;
	    }

	    HashCollisionNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      var entries = this.entries;
	      for (var ii = 0, len = entries.length; ii < len; ii++) {
	        if (is(key, entries[ii][0])) {
	          return entries[ii][1];
	        }
	      }
	      return notSetValue;
	    };

	    HashCollisionNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      if (keyHash === undefined) {
	        keyHash = hash(key);
	      }

	      var removed = value === NOT_SET;

	      if (keyHash !== this.keyHash) {
	        if (removed) {
	          return this;
	        }
	        SetRef(didAlter);
	        SetRef(didChangeSize);
	        return mergeIntoNode(this, ownerID, shift, keyHash, [key, value]);
	      }

	      var entries = this.entries;
	      var idx = 0;
	      for (var len = entries.length; idx < len; idx++) {
	        if (is(key, entries[idx][0])) {
	          break;
	        }
	      }
	      var exists = idx < len;

	      if (exists ? entries[idx][1] === value : removed) {
	        return this;
	      }

	      SetRef(didAlter);
	      (removed || !exists) && SetRef(didChangeSize);

	      if (removed && len === 2) {
	        return new ValueNode(ownerID, this.keyHash, entries[idx ^ 1]);
	      }

	      var isEditable = ownerID && ownerID === this.ownerID;
	      var newEntries = isEditable ? entries : arrCopy(entries);

	      if (exists) {
	        if (removed) {
	          idx === len - 1 ? newEntries.pop() : (newEntries[idx] = newEntries.pop());
	        } else {
	          newEntries[idx] = [key, value];
	        }
	      } else {
	        newEntries.push([key, value]);
	      }

	      if (isEditable) {
	        this.entries = newEntries;
	        return this;
	      }

	      return new HashCollisionNode(ownerID, this.keyHash, newEntries);
	    };




	    function ValueNode(ownerID, keyHash, entry) {
	      this.ownerID = ownerID;
	      this.keyHash = keyHash;
	      this.entry = entry;
	    }

	    ValueNode.prototype.get = function(shift, keyHash, key, notSetValue) {
	      return is(key, this.entry[0]) ? this.entry[1] : notSetValue;
	    };

	    ValueNode.prototype.update = function(ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	      var removed = value === NOT_SET;
	      var keyMatch = is(key, this.entry[0]);
	      if (keyMatch ? value === this.entry[1] : removed) {
	        return this;
	      }

	      SetRef(didAlter);

	      if (removed) {
	        SetRef(didChangeSize);
	        return; // undefined
	      }

	      if (keyMatch) {
	        if (ownerID && ownerID === this.ownerID) {
	          this.entry[1] = value;
	          return this;
	        }
	        return new ValueNode(ownerID, this.keyHash, [key, value]);
	      }

	      SetRef(didChangeSize);
	      return mergeIntoNode(this, ownerID, shift, hash(key), [key, value]);
	    };



	  // #pragma Iterators

	  ArrayMapNode.prototype.iterate =
	  HashCollisionNode.prototype.iterate = function (fn, reverse) {
	    var entries = this.entries;
	    for (var ii = 0, maxIndex = entries.length - 1; ii <= maxIndex; ii++) {
	      if (fn(entries[reverse ? maxIndex - ii : ii]) === false) {
	        return false;
	      }
	    }
	  }

	  BitmapIndexedNode.prototype.iterate =
	  HashArrayMapNode.prototype.iterate = function (fn, reverse) {
	    var nodes = this.nodes;
	    for (var ii = 0, maxIndex = nodes.length - 1; ii <= maxIndex; ii++) {
	      var node = nodes[reverse ? maxIndex - ii : ii];
	      if (node && node.iterate(fn, reverse) === false) {
	        return false;
	      }
	    }
	  }

	  ValueNode.prototype.iterate = function (fn, reverse) {
	    return fn(this.entry);
	  }

	  createClass(MapIterator, src_Iterator__Iterator);

	    function MapIterator(map, type, reverse) {
	      this._type = type;
	      this._reverse = reverse;
	      this._stack = map._root && mapIteratorFrame(map._root);
	    }

	    MapIterator.prototype.next = function() {
	      var type = this._type;
	      var stack = this._stack;
	      while (stack) {
	        var node = stack.node;
	        var index = stack.index++;
	        var maxIndex;
	        if (node.entry) {
	          if (index === 0) {
	            return mapIteratorValue(type, node.entry);
	          }
	        } else if (node.entries) {
	          maxIndex = node.entries.length - 1;
	          if (index <= maxIndex) {
	            return mapIteratorValue(type, node.entries[this._reverse ? maxIndex - index : index]);
	          }
	        } else {
	          maxIndex = node.nodes.length - 1;
	          if (index <= maxIndex) {
	            var subNode = node.nodes[this._reverse ? maxIndex - index : index];
	            if (subNode) {
	              if (subNode.entry) {
	                return mapIteratorValue(type, subNode.entry);
	              }
	              stack = this._stack = mapIteratorFrame(subNode, stack);
	            }
	            continue;
	          }
	        }
	        stack = this._stack = this._stack.__prev;
	      }
	      return iteratorDone();
	    };


	  function mapIteratorValue(type, entry) {
	    return iteratorValue(type, entry[0], entry[1]);
	  }

	  function mapIteratorFrame(node, prev) {
	    return {
	      node: node,
	      index: 0,
	      __prev: prev
	    };
	  }

	  function makeMap(size, root, ownerID, hash) {
	    var map = Object.create(MapPrototype);
	    map.size = size;
	    map._root = root;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_MAP;
	  function emptyMap() {
	    return EMPTY_MAP || (EMPTY_MAP = makeMap(0));
	  }

	  function updateMap(map, k, v) {
	    var newRoot;
	    var newSize;
	    if (!map._root) {
	      if (v === NOT_SET) {
	        return map;
	      }
	      newSize = 1;
	      newRoot = new ArrayMapNode(map.__ownerID, [[k, v]]);
	    } else {
	      var didChangeSize = MakeRef(CHANGE_LENGTH);
	      var didAlter = MakeRef(DID_ALTER);
	      newRoot = updateNode(map._root, map.__ownerID, 0, undefined, k, v, didChangeSize, didAlter);
	      if (!didAlter.value) {
	        return map;
	      }
	      newSize = map.size + (didChangeSize.value ? v === NOT_SET ? -1 : 1 : 0);
	    }
	    if (map.__ownerID) {
	      map.size = newSize;
	      map._root = newRoot;
	      map.__hash = undefined;
	      map.__altered = true;
	      return map;
	    }
	    return newRoot ? makeMap(newSize, newRoot) : emptyMap();
	  }

	  function updateNode(node, ownerID, shift, keyHash, key, value, didChangeSize, didAlter) {
	    if (!node) {
	      if (value === NOT_SET) {
	        return node;
	      }
	      SetRef(didAlter);
	      SetRef(didChangeSize);
	      return new ValueNode(ownerID, keyHash, [key, value]);
	    }
	    return node.update(ownerID, shift, keyHash, key, value, didChangeSize, didAlter);
	  }

	  function isLeafNode(node) {
	    return node.constructor === ValueNode || node.constructor === HashCollisionNode;
	  }

	  function mergeIntoNode(node, ownerID, shift, keyHash, entry) {
	    if (node.keyHash === keyHash) {
	      return new HashCollisionNode(ownerID, keyHash, [node.entry, entry]);
	    }

	    var idx1 = (shift === 0 ? node.keyHash : node.keyHash >>> shift) & MASK;
	    var idx2 = (shift === 0 ? keyHash : keyHash >>> shift) & MASK;

	    var newNode;
	    var nodes = idx1 === idx2 ?
	      [mergeIntoNode(node, ownerID, shift + SHIFT, keyHash, entry)] :
	      ((newNode = new ValueNode(ownerID, keyHash, entry)), idx1 < idx2 ? [node, newNode] : [newNode, node]);

	    return new BitmapIndexedNode(ownerID, (1 << idx1) | (1 << idx2), nodes);
	  }

	  function createNodes(ownerID, entries, key, value) {
	    if (!ownerID) {
	      ownerID = new OwnerID();
	    }
	    var node = new ValueNode(ownerID, hash(key), [key, value]);
	    for (var ii = 0; ii < entries.length; ii++) {
	      var entry = entries[ii];
	      node = node.update(ownerID, 0, undefined, entry[0], entry[1]);
	    }
	    return node;
	  }

	  function packNodes(ownerID, nodes, count, excluding) {
	    var bitmap = 0;
	    var packedII = 0;
	    var packedNodes = new Array(count);
	    for (var ii = 0, bit = 1, len = nodes.length; ii < len; ii++, bit <<= 1) {
	      var node = nodes[ii];
	      if (node !== undefined && ii !== excluding) {
	        bitmap |= bit;
	        packedNodes[packedII++] = node;
	      }
	    }
	    return new BitmapIndexedNode(ownerID, bitmap, packedNodes);
	  }

	  function expandNodes(ownerID, nodes, bitmap, including, node) {
	    var count = 0;
	    var expandedNodes = new Array(SIZE);
	    for (var ii = 0; bitmap !== 0; ii++, bitmap >>>= 1) {
	      expandedNodes[ii] = bitmap & 1 ? nodes[count++] : undefined;
	    }
	    expandedNodes[including] = node;
	    return new HashArrayMapNode(ownerID, count + 1, expandedNodes);
	  }

	  function mergeIntoMapWith(map, merger, iterables) {
	    var iters = [];
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = KeyedIterable(value);
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    return mergeIntoCollectionWith(map, merger, iters);
	  }

	  function deepMerger(merger) {
	    return function(existing, value, key) 
	      {return existing && existing.mergeDeepWith && isIterable(value) ?
	        existing.mergeDeepWith(merger, value) :
	        merger ? merger(existing, value, key) : value};
	  }

	  function mergeIntoCollectionWith(collection, merger, iters) {
	    iters = iters.filter(function(x ) {return x.size !== 0});
	    if (iters.length === 0) {
	      return collection;
	    }
	    if (collection.size === 0 && !collection.__ownerID && iters.length === 1) {
	      return collection.constructor(iters[0]);
	    }
	    return collection.withMutations(function(collection ) {
	      var mergeIntoMap = merger ?
	        function(value, key)  {
	          collection.update(key, NOT_SET, function(existing )
	            {return existing === NOT_SET ? value : merger(existing, value, key)}
	          );
	        } :
	        function(value, key)  {
	          collection.set(key, value);
	        }
	      for (var ii = 0; ii < iters.length; ii++) {
	        iters[ii].forEach(mergeIntoMap);
	      }
	    });
	  }

	  function updateInDeepMap(existing, keyPathIter, notSetValue, updater) {
	    var isNotSet = existing === NOT_SET;
	    var step = keyPathIter.next();
	    if (step.done) {
	      var existingValue = isNotSet ? notSetValue : existing;
	      var newValue = updater(existingValue);
	      return newValue === existingValue ? existing : newValue;
	    }
	    invariant(
	      isNotSet || (existing && existing.set),
	      'invalid keyPath'
	    );
	    var key = step.value;
	    var nextExisting = isNotSet ? NOT_SET : existing.get(key, NOT_SET);
	    var nextUpdated = updateInDeepMap(
	      nextExisting,
	      keyPathIter,
	      notSetValue,
	      updater
	    );
	    return nextUpdated === nextExisting ? existing :
	      nextUpdated === NOT_SET ? existing.remove(key) :
	      (isNotSet ? emptyMap() : existing).set(key, nextUpdated);
	  }

	  function popCount(x) {
	    x = x - ((x >> 1) & 0x55555555);
	    x = (x & 0x33333333) + ((x >> 2) & 0x33333333);
	    x = (x + (x >> 4)) & 0x0f0f0f0f;
	    x = x + (x >> 8);
	    x = x + (x >> 16);
	    return x & 0x7f;
	  }

	  function setIn(array, idx, val, canEdit) {
	    var newArray = canEdit ? array : arrCopy(array);
	    newArray[idx] = val;
	    return newArray;
	  }

	  function spliceIn(array, idx, val, canEdit) {
	    var newLen = array.length + 1;
	    if (canEdit && idx + 1 === newLen) {
	      array[idx] = val;
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        newArray[ii] = val;
	        after = -1;
	      } else {
	        newArray[ii] = array[ii + after];
	      }
	    }
	    return newArray;
	  }

	  function spliceOut(array, idx, canEdit) {
	    var newLen = array.length - 1;
	    if (canEdit && idx === newLen) {
	      array.pop();
	      return array;
	    }
	    var newArray = new Array(newLen);
	    var after = 0;
	    for (var ii = 0; ii < newLen; ii++) {
	      if (ii === idx) {
	        after = 1;
	      }
	      newArray[ii] = array[ii + after];
	    }
	    return newArray;
	  }

	  var MAX_ARRAY_MAP_SIZE = SIZE / 4;
	  var MAX_BITMAP_INDEXED_SIZE = SIZE / 2;
	  var MIN_HASH_ARRAY_MAP_SIZE = SIZE / 4;

	  createClass(List, IndexedCollection);

	    // @pragma Construction

	    function List(value) {
	      var empty = emptyList();
	      if (value === null || value === undefined) {
	        return empty;
	      }
	      if (isList(value)) {
	        return value;
	      }
	      var iter = IndexedIterable(value);
	      var size = iter.size;
	      if (size === 0) {
	        return empty;
	      }
	      assertNotInfinite(size);
	      if (size > 0 && size < SIZE) {
	        return makeList(0, size, SHIFT, null, new VNode(iter.toArray()));
	      }
	      return empty.withMutations(function(list ) {
	        list.setSize(size);
	        iter.forEach(function(v, i)  {return list.set(i, v)});
	      });
	    }

	    List.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    List.prototype.toString = function() {
	      return this.__toString('List [', ']');
	    };

	    // @pragma Access

	    List.prototype.get = function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      if (index < 0 || index >= this.size) {
	        return notSetValue;
	      }
	      index += this._origin;
	      var node = listNodeFor(this, index);
	      return node && node.array[index & MASK];
	    };

	    // @pragma Modification

	    List.prototype.set = function(index, value) {
	      return updateList(this, index, value);
	    };

	    List.prototype.remove = function(index) {
	      return !this.has(index) ? this :
	        index === 0 ? this.shift() :
	        index === this.size - 1 ? this.pop() :
	        this.splice(index, 1);
	    };

	    List.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = this._origin = this._capacity = 0;
	        this._level = SHIFT;
	        this._root = this._tail = null;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyList();
	    };

	    List.prototype.push = function(/*...values*/) {
	      var values = arguments;
	      var oldSize = this.size;
	      return this.withMutations(function(list ) {
	        setListBounds(list, 0, oldSize + values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(oldSize + ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.pop = function() {
	      return setListBounds(this, 0, -1);
	    };

	    List.prototype.unshift = function(/*...values*/) {
	      var values = arguments;
	      return this.withMutations(function(list ) {
	        setListBounds(list, -values.length);
	        for (var ii = 0; ii < values.length; ii++) {
	          list.set(ii, values[ii]);
	        }
	      });
	    };

	    List.prototype.shift = function() {
	      return setListBounds(this, 1);
	    };

	    // @pragma Composition

	    List.prototype.merge = function(/*...iters*/) {
	      return mergeIntoListWith(this, undefined, arguments);
	    };

	    List.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, merger, iters);
	    };

	    List.prototype.mergeDeep = function(/*...iters*/) {
	      return mergeIntoListWith(this, deepMerger(undefined), arguments);
	    };

	    List.prototype.mergeDeepWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return mergeIntoListWith(this, deepMerger(merger), iters);
	    };

	    List.prototype.setSize = function(size) {
	      return setListBounds(this, 0, size);
	    };

	    // @pragma Iteration

	    List.prototype.slice = function(begin, end) {
	      var size = this.size;
	      if (wholeSlice(begin, end, size)) {
	        return this;
	      }
	      return setListBounds(
	        this,
	        resolveBegin(begin, size),
	        resolveEnd(end, size)
	      );
	    };

	    List.prototype.__iterator = function(type, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      return new src_Iterator__Iterator(function()  {
	        var value = values();
	        return value === DONE ?
	          iteratorDone() :
	          iteratorValue(type, index++, value);
	      });
	    };

	    List.prototype.__iterate = function(fn, reverse) {
	      var index = 0;
	      var values = iterateList(this, reverse);
	      var value;
	      while ((value = values()) !== DONE) {
	        if (fn(value, index++, this) === false) {
	          break;
	        }
	      }
	      return index;
	    };

	    List.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        return this;
	      }
	      return makeList(this._origin, this._capacity, this._level, this._root, this._tail, ownerID, this.__hash);
	    };


	  function isList(maybeList) {
	    return !!(maybeList && maybeList[IS_LIST_SENTINEL]);
	  }

	  List.isList = isList;

	  var IS_LIST_SENTINEL = '@@__IMMUTABLE_LIST__@@';

	  var ListPrototype = List.prototype;
	  ListPrototype[IS_LIST_SENTINEL] = true;
	  ListPrototype[DELETE] = ListPrototype.remove;
	  ListPrototype.setIn = MapPrototype.setIn;
	  ListPrototype.deleteIn =
	  ListPrototype.removeIn = MapPrototype.removeIn;
	  ListPrototype.update = MapPrototype.update;
	  ListPrototype.updateIn = MapPrototype.updateIn;
	  ListPrototype.mergeIn = MapPrototype.mergeIn;
	  ListPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  ListPrototype.withMutations = MapPrototype.withMutations;
	  ListPrototype.asMutable = MapPrototype.asMutable;
	  ListPrototype.asImmutable = MapPrototype.asImmutable;
	  ListPrototype.wasAltered = MapPrototype.wasAltered;



	    function VNode(array, ownerID) {
	      this.array = array;
	      this.ownerID = ownerID;
	    }

	    // TODO: seems like these methods are very similar

	    VNode.prototype.removeBefore = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var originIndex = (index >>> level) & MASK;
	      if (originIndex >= this.array.length) {
	        return new VNode([], ownerID);
	      }
	      var removingFirst = originIndex === 0;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[originIndex];
	        newChild = oldChild && oldChild.removeBefore(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingFirst) {
	          return this;
	        }
	      }
	      if (removingFirst && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingFirst) {
	        for (var ii = 0; ii < originIndex; ii++) {
	          editable.array[ii] = undefined;
	        }
	      }
	      if (newChild) {
	        editable.array[originIndex] = newChild;
	      }
	      return editable;
	    };

	    VNode.prototype.removeAfter = function(ownerID, level, index) {
	      if (index === level ? 1 << level : 0 || this.array.length === 0) {
	        return this;
	      }
	      var sizeIndex = ((index - 1) >>> level) & MASK;
	      if (sizeIndex >= this.array.length) {
	        return this;
	      }
	      var removingLast = sizeIndex === this.array.length - 1;
	      var newChild;
	      if (level > 0) {
	        var oldChild = this.array[sizeIndex];
	        newChild = oldChild && oldChild.removeAfter(ownerID, level - SHIFT, index);
	        if (newChild === oldChild && removingLast) {
	          return this;
	        }
	      }
	      if (removingLast && !newChild) {
	        return this;
	      }
	      var editable = editableVNode(this, ownerID);
	      if (!removingLast) {
	        editable.array.pop();
	      }
	      if (newChild) {
	        editable.array[sizeIndex] = newChild;
	      }
	      return editable;
	    };



	  var DONE = {};

	  function iterateList(list, reverse) {
	    var left = list._origin;
	    var right = list._capacity;
	    var tailPos = getTailOffset(right);
	    var tail = list._tail;

	    return iterateNodeOrLeaf(list._root, list._level, 0);

	    function iterateNodeOrLeaf(node, level, offset) {
	      return level === 0 ?
	        iterateLeaf(node, offset) :
	        iterateNode(node, level, offset);
	    }

	    function iterateLeaf(node, offset) {
	      var array = offset === tailPos ? tail && tail.array : node && node.array;
	      var from = offset > left ? 0 : left - offset;
	      var to = right - offset;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        if (from === to) {
	          return DONE;
	        }
	        var idx = reverse ? --to : from++;
	        return array && array[idx];
	      };
	    }

	    function iterateNode(node, level, offset) {
	      var values;
	      var array = node && node.array;
	      var from = offset > left ? 0 : (left - offset) >> level;
	      var to = ((right - offset) >> level) + 1;
	      if (to > SIZE) {
	        to = SIZE;
	      }
	      return function()  {
	        do {
	          if (values) {
	            var value = values();
	            if (value !== DONE) {
	              return value;
	            }
	            values = null;
	          }
	          if (from === to) {
	            return DONE;
	          }
	          var idx = reverse ? --to : from++;
	          values = iterateNodeOrLeaf(
	            array && array[idx], level - SHIFT, offset + (idx << level)
	          );
	        } while (true);
	      };
	    }
	  }

	  function makeList(origin, capacity, level, root, tail, ownerID, hash) {
	    var list = Object.create(ListPrototype);
	    list.size = capacity - origin;
	    list._origin = origin;
	    list._capacity = capacity;
	    list._level = level;
	    list._root = root;
	    list._tail = tail;
	    list.__ownerID = ownerID;
	    list.__hash = hash;
	    list.__altered = false;
	    return list;
	  }

	  var EMPTY_LIST;
	  function emptyList() {
	    return EMPTY_LIST || (EMPTY_LIST = makeList(0, 0, SHIFT));
	  }

	  function updateList(list, index, value) {
	    index = wrapIndex(list, index);

	    if (index >= list.size || index < 0) {
	      return list.withMutations(function(list ) {
	        index < 0 ?
	          setListBounds(list, index).set(0, value) :
	          setListBounds(list, 0, index + 1).set(index, value)
	      });
	    }

	    index += list._origin;

	    var newTail = list._tail;
	    var newRoot = list._root;
	    var didAlter = MakeRef(DID_ALTER);
	    if (index >= getTailOffset(list._capacity)) {
	      newTail = updateVNode(newTail, list.__ownerID, 0, index, value, didAlter);
	    } else {
	      newRoot = updateVNode(newRoot, list.__ownerID, list._level, index, value, didAlter);
	    }

	    if (!didAlter.value) {
	      return list;
	    }

	    if (list.__ownerID) {
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(list._origin, list._capacity, list._level, newRoot, newTail);
	  }

	  function updateVNode(node, ownerID, level, index, value, didAlter) {
	    var idx = (index >>> level) & MASK;
	    var nodeHas = node && idx < node.array.length;
	    if (!nodeHas && value === undefined) {
	      return node;
	    }

	    var newNode;

	    if (level > 0) {
	      var lowerNode = node && node.array[idx];
	      var newLowerNode = updateVNode(lowerNode, ownerID, level - SHIFT, index, value, didAlter);
	      if (newLowerNode === lowerNode) {
	        return node;
	      }
	      newNode = editableVNode(node, ownerID);
	      newNode.array[idx] = newLowerNode;
	      return newNode;
	    }

	    if (nodeHas && node.array[idx] === value) {
	      return node;
	    }

	    SetRef(didAlter);

	    newNode = editableVNode(node, ownerID);
	    if (value === undefined && idx === newNode.array.length - 1) {
	      newNode.array.pop();
	    } else {
	      newNode.array[idx] = value;
	    }
	    return newNode;
	  }

	  function editableVNode(node, ownerID) {
	    if (ownerID && node && ownerID === node.ownerID) {
	      return node;
	    }
	    return new VNode(node ? node.array.slice() : [], ownerID);
	  }

	  function listNodeFor(list, rawIndex) {
	    if (rawIndex >= getTailOffset(list._capacity)) {
	      return list._tail;
	    }
	    if (rawIndex < 1 << (list._level + SHIFT)) {
	      var node = list._root;
	      var level = list._level;
	      while (node && level > 0) {
	        node = node.array[(rawIndex >>> level) & MASK];
	        level -= SHIFT;
	      }
	      return node;
	    }
	  }

	  function setListBounds(list, begin, end) {
	    var owner = list.__ownerID || new OwnerID();
	    var oldOrigin = list._origin;
	    var oldCapacity = list._capacity;
	    var newOrigin = oldOrigin + begin;
	    var newCapacity = end === undefined ? oldCapacity : end < 0 ? oldCapacity + end : oldOrigin + end;
	    if (newOrigin === oldOrigin && newCapacity === oldCapacity) {
	      return list;
	    }

	    // If it's going to end after it starts, it's empty.
	    if (newOrigin >= newCapacity) {
	      return list.clear();
	    }

	    var newLevel = list._level;
	    var newRoot = list._root;

	    // New origin might need creating a higher root.
	    var offsetShift = 0;
	    while (newOrigin + offsetShift < 0) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [undefined, newRoot] : [], owner);
	      newLevel += SHIFT;
	      offsetShift += 1 << newLevel;
	    }
	    if (offsetShift) {
	      newOrigin += offsetShift;
	      oldOrigin += offsetShift;
	      newCapacity += offsetShift;
	      oldCapacity += offsetShift;
	    }

	    var oldTailOffset = getTailOffset(oldCapacity);
	    var newTailOffset = getTailOffset(newCapacity);

	    // New size might need creating a higher root.
	    while (newTailOffset >= 1 << (newLevel + SHIFT)) {
	      newRoot = new VNode(newRoot && newRoot.array.length ? [newRoot] : [], owner);
	      newLevel += SHIFT;
	    }

	    // Locate or create the new tail.
	    var oldTail = list._tail;
	    var newTail = newTailOffset < oldTailOffset ?
	      listNodeFor(list, newCapacity - 1) :
	      newTailOffset > oldTailOffset ? new VNode([], owner) : oldTail;

	    // Merge Tail into tree.
	    if (oldTail && newTailOffset > oldTailOffset && newOrigin < oldCapacity && oldTail.array.length) {
	      newRoot = editableVNode(newRoot, owner);
	      var node = newRoot;
	      for (var level = newLevel; level > SHIFT; level -= SHIFT) {
	        var idx = (oldTailOffset >>> level) & MASK;
	        node = node.array[idx] = editableVNode(node.array[idx], owner);
	      }
	      node.array[(oldTailOffset >>> SHIFT) & MASK] = oldTail;
	    }

	    // If the size has been reduced, there's a chance the tail needs to be trimmed.
	    if (newCapacity < oldCapacity) {
	      newTail = newTail && newTail.removeAfter(owner, 0, newCapacity);
	    }

	    // If the new origin is within the tail, then we do not need a root.
	    if (newOrigin >= newTailOffset) {
	      newOrigin -= newTailOffset;
	      newCapacity -= newTailOffset;
	      newLevel = SHIFT;
	      newRoot = null;
	      newTail = newTail && newTail.removeBefore(owner, 0, newOrigin);

	    // Otherwise, if the root has been trimmed, garbage collect.
	    } else if (newOrigin > oldOrigin || newTailOffset < oldTailOffset) {
	      offsetShift = 0;

	      // Identify the new top root node of the subtree of the old root.
	      while (newRoot) {
	        var beginIndex = (newOrigin >>> newLevel) & MASK;
	        if (beginIndex !== (newTailOffset >>> newLevel) & MASK) {
	          break;
	        }
	        if (beginIndex) {
	          offsetShift += (1 << newLevel) * beginIndex;
	        }
	        newLevel -= SHIFT;
	        newRoot = newRoot.array[beginIndex];
	      }

	      // Trim the new sides of the new root.
	      if (newRoot && newOrigin > oldOrigin) {
	        newRoot = newRoot.removeBefore(owner, newLevel, newOrigin - offsetShift);
	      }
	      if (newRoot && newTailOffset < oldTailOffset) {
	        newRoot = newRoot.removeAfter(owner, newLevel, newTailOffset - offsetShift);
	      }
	      if (offsetShift) {
	        newOrigin -= offsetShift;
	        newCapacity -= offsetShift;
	      }
	    }

	    if (list.__ownerID) {
	      list.size = newCapacity - newOrigin;
	      list._origin = newOrigin;
	      list._capacity = newCapacity;
	      list._level = newLevel;
	      list._root = newRoot;
	      list._tail = newTail;
	      list.__hash = undefined;
	      list.__altered = true;
	      return list;
	    }
	    return makeList(newOrigin, newCapacity, newLevel, newRoot, newTail);
	  }

	  function mergeIntoListWith(list, merger, iterables) {
	    var iters = [];
	    var maxSize = 0;
	    for (var ii = 0; ii < iterables.length; ii++) {
	      var value = iterables[ii];
	      var iter = IndexedIterable(value);
	      if (iter.size > maxSize) {
	        maxSize = iter.size;
	      }
	      if (!isIterable(value)) {
	        iter = iter.map(function(v ) {return fromJS(v)});
	      }
	      iters.push(iter);
	    }
	    if (maxSize > list.size) {
	      list = list.setSize(maxSize);
	    }
	    return mergeIntoCollectionWith(list, merger, iters);
	  }

	  function getTailOffset(size) {
	    return size < SIZE ? 0 : (((size - 1) >>> SHIFT) << SHIFT);
	  }

	  createClass(OrderedMap, src_Map__Map);

	    // @pragma Construction

	    function OrderedMap(value) {
	      return value === null || value === undefined ? emptyOrderedMap() :
	        isOrderedMap(value) ? value :
	        emptyOrderedMap().withMutations(function(map ) {
	          var iter = KeyedIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v, k)  {return map.set(k, v)});
	        });
	    }

	    OrderedMap.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedMap.prototype.toString = function() {
	      return this.__toString('OrderedMap {', '}');
	    };

	    // @pragma Access

	    OrderedMap.prototype.get = function(k, notSetValue) {
	      var index = this._map.get(k);
	      return index !== undefined ? this._list.get(index)[1] : notSetValue;
	    };

	    // @pragma Modification

	    OrderedMap.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._map.clear();
	        this._list.clear();
	        return this;
	      }
	      return emptyOrderedMap();
	    };

	    OrderedMap.prototype.set = function(k, v) {
	      return updateOrderedMap(this, k, v);
	    };

	    OrderedMap.prototype.remove = function(k) {
	      return updateOrderedMap(this, k, NOT_SET);
	    };

	    OrderedMap.prototype.wasAltered = function() {
	      return this._map.wasAltered() || this._list.wasAltered();
	    };

	    OrderedMap.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._list.__iterate(
	        function(entry ) {return entry && fn(entry[1], entry[0], this$0)},
	        reverse
	      );
	    };

	    OrderedMap.prototype.__iterator = function(type, reverse) {
	      return this._list.fromEntrySeq().__iterator(type, reverse);
	    };

	    OrderedMap.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      var newList = this._list.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        this._list = newList;
	        return this;
	      }
	      return makeOrderedMap(newMap, newList, ownerID, this.__hash);
	    };


	  function isOrderedMap(maybeOrderedMap) {
	    return isMap(maybeOrderedMap) && isOrdered(maybeOrderedMap);
	  }

	  OrderedMap.isOrderedMap = isOrderedMap;

	  OrderedMap.prototype[IS_ORDERED_SENTINEL] = true;
	  OrderedMap.prototype[DELETE] = OrderedMap.prototype.remove;



	  function makeOrderedMap(map, list, ownerID, hash) {
	    var omap = Object.create(OrderedMap.prototype);
	    omap.size = map ? map.size : 0;
	    omap._map = map;
	    omap._list = list;
	    omap.__ownerID = ownerID;
	    omap.__hash = hash;
	    return omap;
	  }

	  var EMPTY_ORDERED_MAP;
	  function emptyOrderedMap() {
	    return EMPTY_ORDERED_MAP || (EMPTY_ORDERED_MAP = makeOrderedMap(emptyMap(), emptyList()));
	  }

	  function updateOrderedMap(omap, k, v) {
	    var map = omap._map;
	    var list = omap._list;
	    var i = map.get(k);
	    var has = i !== undefined;
	    var newMap;
	    var newList;
	    if (v === NOT_SET) { // removed
	      if (!has) {
	        return omap;
	      }
	      if (list.size >= SIZE && list.size >= map.size * 2) {
	        newList = list.filter(function(entry, idx)  {return entry !== undefined && i !== idx});
	        newMap = newList.toKeyedSeq().map(function(entry ) {return entry[0]}).flip().toMap();
	        if (omap.__ownerID) {
	          newMap.__ownerID = newList.__ownerID = omap.__ownerID;
	        }
	      } else {
	        newMap = map.remove(k);
	        newList = i === list.size - 1 ? list.pop() : list.set(i, undefined);
	      }
	    } else {
	      if (has) {
	        if (v === list.get(i)[1]) {
	          return omap;
	        }
	        newMap = map;
	        newList = list.set(i, [k, v]);
	      } else {
	        newMap = map.set(k, list.size);
	        newList = list.set(list.size, [k, v]);
	      }
	    }
	    if (omap.__ownerID) {
	      omap.size = newMap.size;
	      omap._map = newMap;
	      omap._list = newList;
	      omap.__hash = undefined;
	      return omap;
	    }
	    return makeOrderedMap(newMap, newList);
	  }

	  createClass(Stack, IndexedCollection);

	    // @pragma Construction

	    function Stack(value) {
	      return value === null || value === undefined ? emptyStack() :
	        isStack(value) ? value :
	        emptyStack().unshiftAll(value);
	    }

	    Stack.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    Stack.prototype.toString = function() {
	      return this.__toString('Stack [', ']');
	    };

	    // @pragma Access

	    Stack.prototype.get = function(index, notSetValue) {
	      var head = this._head;
	      index = wrapIndex(this, index);
	      while (head && index--) {
	        head = head.next;
	      }
	      return head ? head.value : notSetValue;
	    };

	    Stack.prototype.peek = function() {
	      return this._head && this._head.value;
	    };

	    // @pragma Modification

	    Stack.prototype.push = function(/*...values*/) {
	      if (arguments.length === 0) {
	        return this;
	      }
	      var newSize = this.size + arguments.length;
	      var head = this._head;
	      for (var ii = arguments.length - 1; ii >= 0; ii--) {
	        head = {
	          value: arguments[ii],
	          next: head
	        };
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pushAll = function(iter) {
	      iter = IndexedIterable(iter);
	      if (iter.size === 0) {
	        return this;
	      }
	      assertNotInfinite(iter.size);
	      var newSize = this.size;
	      var head = this._head;
	      iter.reverse().forEach(function(value ) {
	        newSize++;
	        head = {
	          value: value,
	          next: head
	        };
	      });
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    Stack.prototype.pop = function() {
	      return this.slice(1);
	    };

	    Stack.prototype.unshift = function(/*...values*/) {
	      return this.push.apply(this, arguments);
	    };

	    Stack.prototype.unshiftAll = function(iter) {
	      return this.pushAll(iter);
	    };

	    Stack.prototype.shift = function() {
	      return this.pop.apply(this, arguments);
	    };

	    Stack.prototype.clear = function() {
	      if (this.size === 0) {
	        return this;
	      }
	      if (this.__ownerID) {
	        this.size = 0;
	        this._head = undefined;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return emptyStack();
	    };

	    Stack.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      var resolvedBegin = resolveBegin(begin, this.size);
	      var resolvedEnd = resolveEnd(end, this.size);
	      if (resolvedEnd !== this.size) {
	        // super.slice(begin, end);
	        return IndexedCollection.prototype.slice.call(this, begin, end);
	      }
	      var newSize = this.size - resolvedBegin;
	      var head = this._head;
	      while (resolvedBegin--) {
	        head = head.next;
	      }
	      if (this.__ownerID) {
	        this.size = newSize;
	        this._head = head;
	        this.__hash = undefined;
	        this.__altered = true;
	        return this;
	      }
	      return makeStack(newSize, head);
	    };

	    // @pragma Mutability

	    Stack.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this.__altered = false;
	        return this;
	      }
	      return makeStack(this.size, this._head, ownerID, this.__hash);
	    };

	    // @pragma Iteration

	    Stack.prototype.__iterate = function(fn, reverse) {
	      if (reverse) {
	        return this.reverse().__iterate(fn);
	      }
	      var iterations = 0;
	      var node = this._head;
	      while (node) {
	        if (fn(node.value, iterations++, this) === false) {
	          break;
	        }
	        node = node.next;
	      }
	      return iterations;
	    };

	    Stack.prototype.__iterator = function(type, reverse) {
	      if (reverse) {
	        return this.reverse().__iterator(type);
	      }
	      var iterations = 0;
	      var node = this._head;
	      return new src_Iterator__Iterator(function()  {
	        if (node) {
	          var value = node.value;
	          node = node.next;
	          return iteratorValue(type, iterations++, value);
	        }
	        return iteratorDone();
	      });
	    };


	  function isStack(maybeStack) {
	    return !!(maybeStack && maybeStack[IS_STACK_SENTINEL]);
	  }

	  Stack.isStack = isStack;

	  var IS_STACK_SENTINEL = '@@__IMMUTABLE_STACK__@@';

	  var StackPrototype = Stack.prototype;
	  StackPrototype[IS_STACK_SENTINEL] = true;
	  StackPrototype.withMutations = MapPrototype.withMutations;
	  StackPrototype.asMutable = MapPrototype.asMutable;
	  StackPrototype.asImmutable = MapPrototype.asImmutable;
	  StackPrototype.wasAltered = MapPrototype.wasAltered;


	  function makeStack(size, head, ownerID, hash) {
	    var map = Object.create(StackPrototype);
	    map.size = size;
	    map._head = head;
	    map.__ownerID = ownerID;
	    map.__hash = hash;
	    map.__altered = false;
	    return map;
	  }

	  var EMPTY_STACK;
	  function emptyStack() {
	    return EMPTY_STACK || (EMPTY_STACK = makeStack(0));
	  }

	  createClass(src_Set__Set, SetCollection);

	    // @pragma Construction

	    function src_Set__Set(value) {
	      return value === null || value === undefined ? emptySet() :
	        isSet(value) ? value :
	        emptySet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    src_Set__Set.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    src_Set__Set.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    src_Set__Set.prototype.toString = function() {
	      return this.__toString('Set {', '}');
	    };

	    // @pragma Access

	    src_Set__Set.prototype.has = function(value) {
	      return this._map.has(value);
	    };

	    // @pragma Modification

	    src_Set__Set.prototype.add = function(value) {
	      return updateSet(this, this._map.set(value, true));
	    };

	    src_Set__Set.prototype.remove = function(value) {
	      return updateSet(this, this._map.remove(value));
	    };

	    src_Set__Set.prototype.clear = function() {
	      return updateSet(this, this._map.clear());
	    };

	    // @pragma Composition

	    src_Set__Set.prototype.union = function() {var iters = SLICE$0.call(arguments, 0);
	      iters = iters.filter(function(x ) {return x.size !== 0});
	      if (iters.length === 0) {
	        return this;
	      }
	      if (this.size === 0 && !this.__ownerID && iters.length === 1) {
	        return this.constructor(iters[0]);
	      }
	      return this.withMutations(function(set ) {
	        for (var ii = 0; ii < iters.length; ii++) {
	          SetIterable(iters[ii]).forEach(function(value ) {return set.add(value)});
	        }
	      });
	    };

	    src_Set__Set.prototype.intersect = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (!iters.every(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    src_Set__Set.prototype.subtract = function() {var iters = SLICE$0.call(arguments, 0);
	      if (iters.length === 0) {
	        return this;
	      }
	      iters = iters.map(function(iter ) {return SetIterable(iter)});
	      var originalSet = this;
	      return this.withMutations(function(set ) {
	        originalSet.forEach(function(value ) {
	          if (iters.some(function(iter ) {return iter.includes(value)})) {
	            set.remove(value);
	          }
	        });
	      });
	    };

	    src_Set__Set.prototype.merge = function() {
	      return this.union.apply(this, arguments);
	    };

	    src_Set__Set.prototype.mergeWith = function(merger) {var iters = SLICE$0.call(arguments, 1);
	      return this.union.apply(this, iters);
	    };

	    src_Set__Set.prototype.sort = function(comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator));
	    };

	    src_Set__Set.prototype.sortBy = function(mapper, comparator) {
	      // Late binding
	      return OrderedSet(sortFactory(this, comparator, mapper));
	    };

	    src_Set__Set.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    src_Set__Set.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return this._map.__iterate(function(_, k)  {return fn(k, k, this$0)}, reverse);
	    };

	    src_Set__Set.prototype.__iterator = function(type, reverse) {
	      return this._map.map(function(_, k)  {return k}).__iterator(type, reverse);
	    };

	    src_Set__Set.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return this.__make(newMap, ownerID);
	    };


	  function isSet(maybeSet) {
	    return !!(maybeSet && maybeSet[IS_SET_SENTINEL]);
	  }

	  src_Set__Set.isSet = isSet;

	  var IS_SET_SENTINEL = '@@__IMMUTABLE_SET__@@';

	  var SetPrototype = src_Set__Set.prototype;
	  SetPrototype[IS_SET_SENTINEL] = true;
	  SetPrototype[DELETE] = SetPrototype.remove;
	  SetPrototype.mergeDeep = SetPrototype.merge;
	  SetPrototype.mergeDeepWith = SetPrototype.mergeWith;
	  SetPrototype.withMutations = MapPrototype.withMutations;
	  SetPrototype.asMutable = MapPrototype.asMutable;
	  SetPrototype.asImmutable = MapPrototype.asImmutable;

	  SetPrototype.__empty = emptySet;
	  SetPrototype.__make = makeSet;

	  function updateSet(set, newMap) {
	    if (set.__ownerID) {
	      set.size = newMap.size;
	      set._map = newMap;
	      return set;
	    }
	    return newMap === set._map ? set :
	      newMap.size === 0 ? set.__empty() :
	      set.__make(newMap);
	  }

	  function makeSet(map, ownerID) {
	    var set = Object.create(SetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_SET;
	  function emptySet() {
	    return EMPTY_SET || (EMPTY_SET = makeSet(emptyMap()));
	  }

	  createClass(OrderedSet, src_Set__Set);

	    // @pragma Construction

	    function OrderedSet(value) {
	      return value === null || value === undefined ? emptyOrderedSet() :
	        isOrderedSet(value) ? value :
	        emptyOrderedSet().withMutations(function(set ) {
	          var iter = SetIterable(value);
	          assertNotInfinite(iter.size);
	          iter.forEach(function(v ) {return set.add(v)});
	        });
	    }

	    OrderedSet.of = function(/*...values*/) {
	      return this(arguments);
	    };

	    OrderedSet.fromKeys = function(value) {
	      return this(KeyedIterable(value).keySeq());
	    };

	    OrderedSet.prototype.toString = function() {
	      return this.__toString('OrderedSet {', '}');
	    };


	  function isOrderedSet(maybeOrderedSet) {
	    return isSet(maybeOrderedSet) && isOrdered(maybeOrderedSet);
	  }

	  OrderedSet.isOrderedSet = isOrderedSet;

	  var OrderedSetPrototype = OrderedSet.prototype;
	  OrderedSetPrototype[IS_ORDERED_SENTINEL] = true;

	  OrderedSetPrototype.__empty = emptyOrderedSet;
	  OrderedSetPrototype.__make = makeOrderedSet;

	  function makeOrderedSet(map, ownerID) {
	    var set = Object.create(OrderedSetPrototype);
	    set.size = map ? map.size : 0;
	    set._map = map;
	    set.__ownerID = ownerID;
	    return set;
	  }

	  var EMPTY_ORDERED_SET;
	  function emptyOrderedSet() {
	    return EMPTY_ORDERED_SET || (EMPTY_ORDERED_SET = makeOrderedSet(emptyOrderedMap()));
	  }

	  createClass(Record, KeyedCollection);

	    function Record(defaultValues, name) {
	      var hasInitialized;

	      var RecordType = function Record(values) {
	        if (values instanceof RecordType) {
	          return values;
	        }
	        if (!(this instanceof RecordType)) {
	          return new RecordType(values);
	        }
	        if (!hasInitialized) {
	          hasInitialized = true;
	          var keys = Object.keys(defaultValues);
	          setProps(RecordTypePrototype, keys);
	          RecordTypePrototype.size = keys.length;
	          RecordTypePrototype._name = name;
	          RecordTypePrototype._keys = keys;
	          RecordTypePrototype._defaultValues = defaultValues;
	        }
	        this._map = src_Map__Map(values);
	      };

	      var RecordTypePrototype = RecordType.prototype = Object.create(RecordPrototype);
	      RecordTypePrototype.constructor = RecordType;

	      return RecordType;
	    }

	    Record.prototype.toString = function() {
	      return this.__toString(recordName(this) + ' {', '}');
	    };

	    // @pragma Access

	    Record.prototype.has = function(k) {
	      return this._defaultValues.hasOwnProperty(k);
	    };

	    Record.prototype.get = function(k, notSetValue) {
	      if (!this.has(k)) {
	        return notSetValue;
	      }
	      var defaultVal = this._defaultValues[k];
	      return this._map ? this._map.get(k, defaultVal) : defaultVal;
	    };

	    // @pragma Modification

	    Record.prototype.clear = function() {
	      if (this.__ownerID) {
	        this._map && this._map.clear();
	        return this;
	      }
	      var RecordType = this.constructor;
	      return RecordType._empty || (RecordType._empty = makeRecord(this, emptyMap()));
	    };

	    Record.prototype.set = function(k, v) {
	      if (!this.has(k)) {
	        throw new Error('Cannot set unknown key "' + k + '" on ' + recordName(this));
	      }
	      var newMap = this._map && this._map.set(k, v);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.remove = function(k) {
	      if (!this.has(k)) {
	        return this;
	      }
	      var newMap = this._map && this._map.remove(k);
	      if (this.__ownerID || newMap === this._map) {
	        return this;
	      }
	      return makeRecord(this, newMap);
	    };

	    Record.prototype.wasAltered = function() {
	      return this._map.wasAltered();
	    };

	    Record.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterator(type, reverse);
	    };

	    Record.prototype.__iterate = function(fn, reverse) {var this$0 = this;
	      return KeyedIterable(this._defaultValues).map(function(_, k)  {return this$0.get(k)}).__iterate(fn, reverse);
	    };

	    Record.prototype.__ensureOwner = function(ownerID) {
	      if (ownerID === this.__ownerID) {
	        return this;
	      }
	      var newMap = this._map && this._map.__ensureOwner(ownerID);
	      if (!ownerID) {
	        this.__ownerID = ownerID;
	        this._map = newMap;
	        return this;
	      }
	      return makeRecord(this, newMap, ownerID);
	    };


	  var RecordPrototype = Record.prototype;
	  RecordPrototype[DELETE] = RecordPrototype.remove;
	  RecordPrototype.deleteIn =
	  RecordPrototype.removeIn = MapPrototype.removeIn;
	  RecordPrototype.merge = MapPrototype.merge;
	  RecordPrototype.mergeWith = MapPrototype.mergeWith;
	  RecordPrototype.mergeIn = MapPrototype.mergeIn;
	  RecordPrototype.mergeDeep = MapPrototype.mergeDeep;
	  RecordPrototype.mergeDeepWith = MapPrototype.mergeDeepWith;
	  RecordPrototype.mergeDeepIn = MapPrototype.mergeDeepIn;
	  RecordPrototype.setIn = MapPrototype.setIn;
	  RecordPrototype.update = MapPrototype.update;
	  RecordPrototype.updateIn = MapPrototype.updateIn;
	  RecordPrototype.withMutations = MapPrototype.withMutations;
	  RecordPrototype.asMutable = MapPrototype.asMutable;
	  RecordPrototype.asImmutable = MapPrototype.asImmutable;


	  function makeRecord(likeRecord, map, ownerID) {
	    var record = Object.create(Object.getPrototypeOf(likeRecord));
	    record._map = map;
	    record.__ownerID = ownerID;
	    return record;
	  }

	  function recordName(record) {
	    return record._name || record.constructor.name || 'Record';
	  }

	  function setProps(prototype, names) {
	    try {
	      names.forEach(setProp.bind(undefined, prototype));
	    } catch (error) {
	      // Object.defineProperty failed. Probably IE8.
	    }
	  }

	  function setProp(prototype, name) {
	    Object.defineProperty(prototype, name, {
	      get: function() {
	        return this.get(name);
	      },
	      set: function(value) {
	        invariant(this.__ownerID, 'Cannot set on an immutable record.');
	        this.set(name, value);
	      }
	    });
	  }

	  function deepEqual(a, b) {
	    if (a === b) {
	      return true;
	    }

	    if (
	      !isIterable(b) ||
	      a.size !== undefined && b.size !== undefined && a.size !== b.size ||
	      a.__hash !== undefined && b.__hash !== undefined && a.__hash !== b.__hash ||
	      isKeyed(a) !== isKeyed(b) ||
	      isIndexed(a) !== isIndexed(b) ||
	      isOrdered(a) !== isOrdered(b)
	    ) {
	      return false;
	    }

	    if (a.size === 0 && b.size === 0) {
	      return true;
	    }

	    var notAssociative = !isAssociative(a);

	    if (isOrdered(a)) {
	      var entries = a.entries();
	      return b.every(function(v, k)  {
	        var entry = entries.next().value;
	        return entry && is(entry[1], v) && (notAssociative || is(entry[0], k));
	      }) && entries.next().done;
	    }

	    var flipped = false;

	    if (a.size === undefined) {
	      if (b.size === undefined) {
	        if (typeof a.cacheResult === 'function') {
	          a.cacheResult();
	        }
	      } else {
	        flipped = true;
	        var _ = a;
	        a = b;
	        b = _;
	      }
	    }

	    var allEqual = true;
	    var bSize = b.__iterate(function(v, k)  {
	      if (notAssociative ? !a.has(v) :
	          flipped ? !is(v, a.get(k, NOT_SET)) : !is(a.get(k, NOT_SET), v)) {
	        allEqual = false;
	        return false;
	      }
	    });

	    return allEqual && a.size === bSize;
	  }

	  createClass(Range, IndexedSeq);

	    function Range(start, end, step) {
	      if (!(this instanceof Range)) {
	        return new Range(start, end, step);
	      }
	      invariant(step !== 0, 'Cannot step a Range by 0');
	      start = start || 0;
	      if (end === undefined) {
	        end = Infinity;
	      }
	      step = step === undefined ? 1 : Math.abs(step);
	      if (end < start) {
	        step = -step;
	      }
	      this._start = start;
	      this._end = end;
	      this._step = step;
	      this.size = Math.max(0, Math.ceil((end - start) / step - 1) + 1);
	      if (this.size === 0) {
	        if (EMPTY_RANGE) {
	          return EMPTY_RANGE;
	        }
	        EMPTY_RANGE = this;
	      }
	    }

	    Range.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Range []';
	      }
	      return 'Range [ ' +
	        this._start + '...' + this._end +
	        (this._step > 1 ? ' by ' + this._step : '') +
	      ' ]';
	    };

	    Range.prototype.get = function(index, notSetValue) {
	      return this.has(index) ?
	        this._start + wrapIndex(this, index) * this._step :
	        notSetValue;
	    };

	    Range.prototype.includes = function(searchValue) {
	      var possibleIndex = (searchValue - this._start) / this._step;
	      return possibleIndex >= 0 &&
	        possibleIndex < this.size &&
	        possibleIndex === Math.floor(possibleIndex);
	    };

	    Range.prototype.slice = function(begin, end) {
	      if (wholeSlice(begin, end, this.size)) {
	        return this;
	      }
	      begin = resolveBegin(begin, this.size);
	      end = resolveEnd(end, this.size);
	      if (end <= begin) {
	        return new Range(0, 0);
	      }
	      return new Range(this.get(begin, this._end), this.get(end, this._end), this._step);
	    };

	    Range.prototype.indexOf = function(searchValue) {
	      var offsetValue = searchValue - this._start;
	      if (offsetValue % this._step === 0) {
	        var index = offsetValue / this._step;
	        if (index >= 0 && index < this.size) {
	          return index
	        }
	      }
	      return -1;
	    };

	    Range.prototype.lastIndexOf = function(searchValue) {
	      return this.indexOf(searchValue);
	    };

	    Range.prototype.__iterate = function(fn, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      for (var ii = 0; ii <= maxIndex; ii++) {
	        if (fn(value, ii, this) === false) {
	          return ii + 1;
	        }
	        value += reverse ? -step : step;
	      }
	      return ii;
	    };

	    Range.prototype.__iterator = function(type, reverse) {
	      var maxIndex = this.size - 1;
	      var step = this._step;
	      var value = reverse ? this._start + maxIndex * step : this._start;
	      var ii = 0;
	      return new src_Iterator__Iterator(function()  {
	        var v = value;
	        value += reverse ? -step : step;
	        return ii > maxIndex ? iteratorDone() : iteratorValue(type, ii++, v);
	      });
	    };

	    Range.prototype.equals = function(other) {
	      return other instanceof Range ?
	        this._start === other._start &&
	        this._end === other._end &&
	        this._step === other._step :
	        deepEqual(this, other);
	    };


	  var EMPTY_RANGE;

	  createClass(Repeat, IndexedSeq);

	    function Repeat(value, times) {
	      if (!(this instanceof Repeat)) {
	        return new Repeat(value, times);
	      }
	      this._value = value;
	      this.size = times === undefined ? Infinity : Math.max(0, times);
	      if (this.size === 0) {
	        if (EMPTY_REPEAT) {
	          return EMPTY_REPEAT;
	        }
	        EMPTY_REPEAT = this;
	      }
	    }

	    Repeat.prototype.toString = function() {
	      if (this.size === 0) {
	        return 'Repeat []';
	      }
	      return 'Repeat [ ' + this._value + ' ' + this.size + ' times ]';
	    };

	    Repeat.prototype.get = function(index, notSetValue) {
	      return this.has(index) ? this._value : notSetValue;
	    };

	    Repeat.prototype.includes = function(searchValue) {
	      return is(this._value, searchValue);
	    };

	    Repeat.prototype.slice = function(begin, end) {
	      var size = this.size;
	      return wholeSlice(begin, end, size) ? this :
	        new Repeat(this._value, resolveEnd(end, size) - resolveBegin(begin, size));
	    };

	    Repeat.prototype.reverse = function() {
	      return this;
	    };

	    Repeat.prototype.indexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return 0;
	      }
	      return -1;
	    };

	    Repeat.prototype.lastIndexOf = function(searchValue) {
	      if (is(this._value, searchValue)) {
	        return this.size;
	      }
	      return -1;
	    };

	    Repeat.prototype.__iterate = function(fn, reverse) {
	      for (var ii = 0; ii < this.size; ii++) {
	        if (fn(this._value, ii, this) === false) {
	          return ii + 1;
	        }
	      }
	      return ii;
	    };

	    Repeat.prototype.__iterator = function(type, reverse) {var this$0 = this;
	      var ii = 0;
	      return new src_Iterator__Iterator(function() 
	        {return ii < this$0.size ? iteratorValue(type, ii++, this$0._value) : iteratorDone()}
	      );
	    };

	    Repeat.prototype.equals = function(other) {
	      return other instanceof Repeat ?
	        is(this._value, other._value) :
	        deepEqual(other);
	    };


	  var EMPTY_REPEAT;

	  /**
	   * Contributes additional methods to a constructor
	   */
	  function mixin(ctor, methods) {
	    var keyCopier = function(key ) { ctor.prototype[key] = methods[key]; };
	    Object.keys(methods).forEach(keyCopier);
	    Object.getOwnPropertySymbols &&
	      Object.getOwnPropertySymbols(methods).forEach(keyCopier);
	    return ctor;
	  }

	  Iterable.Iterator = src_Iterator__Iterator;

	  mixin(Iterable, {

	    // ### Conversion to other types

	    toArray: function() {
	      assertNotInfinite(this.size);
	      var array = new Array(this.size || 0);
	      this.valueSeq().__iterate(function(v, i)  { array[i] = v; });
	      return array;
	    },

	    toIndexedSeq: function() {
	      return new ToIndexedSequence(this);
	    },

	    toJS: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJS === 'function' ? value.toJS() : value}
	      ).__toJS();
	    },

	    toJSON: function() {
	      return this.toSeq().map(
	        function(value ) {return value && typeof value.toJSON === 'function' ? value.toJSON() : value}
	      ).__toJS();
	    },

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, true);
	    },

	    toMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return src_Map__Map(this.toKeyedSeq());
	    },

	    toObject: function() {
	      assertNotInfinite(this.size);
	      var object = {};
	      this.__iterate(function(v, k)  { object[k] = v; });
	      return object;
	    },

	    toOrderedMap: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedMap(this.toKeyedSeq());
	    },

	    toOrderedSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return OrderedSet(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSet: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return src_Set__Set(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toSetSeq: function() {
	      return new ToSetSequence(this);
	    },

	    toSeq: function() {
	      return isIndexed(this) ? this.toIndexedSeq() :
	        isKeyed(this) ? this.toKeyedSeq() :
	        this.toSetSeq();
	    },

	    toStack: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return Stack(isKeyed(this) ? this.valueSeq() : this);
	    },

	    toList: function() {
	      // Use Late Binding here to solve the circular dependency.
	      return List(isKeyed(this) ? this.valueSeq() : this);
	    },


	    // ### Common JavaScript methods and properties

	    toString: function() {
	      return '[Iterable]';
	    },

	    __toString: function(head, tail) {
	      if (this.size === 0) {
	        return head + tail;
	      }
	      return head + ' ' + this.toSeq().map(this.__toStringMapper).join(', ') + ' ' + tail;
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    concat: function() {var values = SLICE$0.call(arguments, 0);
	      return reify(this, concatFactory(this, values));
	    },

	    contains: function(searchValue) {
	      return this.includes(searchValue);
	    },

	    includes: function(searchValue) {
	      return this.some(function(value ) {return is(value, searchValue)});
	    },

	    entries: function() {
	      return this.__iterator(ITERATE_ENTRIES);
	    },

	    every: function(predicate, context) {
	      assertNotInfinite(this.size);
	      var returnValue = true;
	      this.__iterate(function(v, k, c)  {
	        if (!predicate.call(context, v, k, c)) {
	          returnValue = false;
	          return false;
	        }
	      });
	      return returnValue;
	    },

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, true));
	    },

	    find: function(predicate, context, notSetValue) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[1] : notSetValue;
	    },

	    findEntry: function(predicate, context) {
	      var found;
	      this.__iterate(function(v, k, c)  {
	        if (predicate.call(context, v, k, c)) {
	          found = [k, v];
	          return false;
	        }
	      });
	      return found;
	    },

	    findLastEntry: function(predicate, context) {
	      return this.toSeq().reverse().findEntry(predicate, context);
	    },

	    forEach: function(sideEffect, context) {
	      assertNotInfinite(this.size);
	      return this.__iterate(context ? sideEffect.bind(context) : sideEffect);
	    },

	    join: function(separator) {
	      assertNotInfinite(this.size);
	      separator = separator !== undefined ? '' + separator : ',';
	      var joined = '';
	      var isFirst = true;
	      this.__iterate(function(v ) {
	        isFirst ? (isFirst = false) : (joined += separator);
	        joined += v !== null && v !== undefined ? v.toString() : '';
	      });
	      return joined;
	    },

	    keys: function() {
	      return this.__iterator(ITERATE_KEYS);
	    },

	    map: function(mapper, context) {
	      return reify(this, mapFactory(this, mapper, context));
	    },

	    reduce: function(reducer, initialReduction, context) {
	      assertNotInfinite(this.size);
	      var reduction;
	      var useFirst;
	      if (arguments.length < 2) {
	        useFirst = true;
	      } else {
	        reduction = initialReduction;
	      }
	      this.__iterate(function(v, k, c)  {
	        if (useFirst) {
	          useFirst = false;
	          reduction = v;
	        } else {
	          reduction = reducer.call(context, reduction, v, k, c);
	        }
	      });
	      return reduction;
	    },

	    reduceRight: function(reducer, initialReduction, context) {
	      var reversed = this.toKeyedSeq().reverse();
	      return reversed.reduce.apply(reversed, arguments);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, true));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, true));
	    },

	    some: function(predicate, context) {
	      return !this.every(not(predicate), context);
	    },

	    sort: function(comparator) {
	      return reify(this, sortFactory(this, comparator));
	    },

	    values: function() {
	      return this.__iterator(ITERATE_VALUES);
	    },


	    // ### More sequential methods

	    butLast: function() {
	      return this.slice(0, -1);
	    },

	    isEmpty: function() {
	      return this.size !== undefined ? this.size === 0 : !this.some(function()  {return true});
	    },

	    count: function(predicate, context) {
	      return ensureSize(
	        predicate ? this.toSeq().filter(predicate, context) : this
	      );
	    },

	    countBy: function(grouper, context) {
	      return countByFactory(this, grouper, context);
	    },

	    equals: function(other) {
	      return deepEqual(this, other);
	    },

	    entrySeq: function() {
	      var iterable = this;
	      if (iterable._cache) {
	        // We cache as an entries array, so we can just return the cache!
	        return new ArraySeq(iterable._cache);
	      }
	      var entriesSequence = iterable.toSeq().map(entryMapper).toIndexedSeq();
	      entriesSequence.fromEntrySeq = function()  {return iterable.toSeq()};
	      return entriesSequence;
	    },

	    filterNot: function(predicate, context) {
	      return this.filter(not(predicate), context);
	    },

	    findLast: function(predicate, context, notSetValue) {
	      return this.toKeyedSeq().reverse().find(predicate, context, notSetValue);
	    },

	    first: function() {
	      return this.find(returnTrue);
	    },

	    flatMap: function(mapper, context) {
	      return reify(this, flatMapFactory(this, mapper, context));
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, true));
	    },

	    fromEntrySeq: function() {
	      return new FromEntriesSequence(this);
	    },

	    get: function(searchKey, notSetValue) {
	      return this.find(function(_, key)  {return is(key, searchKey)}, undefined, notSetValue);
	    },

	    getIn: function(searchKeyPath, notSetValue) {
	      var nested = this;
	      // Note: in an ES6 environment, we would prefer:
	      // for (var key of searchKeyPath) {
	      var iter = forceIterator(searchKeyPath);
	      var step;
	      while (!(step = iter.next()).done) {
	        var key = step.value;
	        nested = nested && nested.get ? nested.get(key, NOT_SET) : NOT_SET;
	        if (nested === NOT_SET) {
	          return notSetValue;
	        }
	      }
	      return nested;
	    },

	    groupBy: function(grouper, context) {
	      return groupByFactory(this, grouper, context);
	    },

	    has: function(searchKey) {
	      return this.get(searchKey, NOT_SET) !== NOT_SET;
	    },

	    hasIn: function(searchKeyPath) {
	      return this.getIn(searchKeyPath, NOT_SET) !== NOT_SET;
	    },

	    isSubset: function(iter) {
	      iter = typeof iter.includes === 'function' ? iter : Iterable(iter);
	      return this.every(function(value ) {return iter.includes(value)});
	    },

	    isSuperset: function(iter) {
	      return iter.isSubset(this);
	    },

	    keySeq: function() {
	      return this.toSeq().map(keyMapper).toIndexedSeq();
	    },

	    last: function() {
	      return this.toSeq().reverse().first();
	    },

	    max: function(comparator) {
	      return maxFactory(this, comparator);
	    },

	    maxBy: function(mapper, comparator) {
	      return maxFactory(this, comparator, mapper);
	    },

	    min: function(comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator);
	    },

	    minBy: function(mapper, comparator) {
	      return maxFactory(this, comparator ? neg(comparator) : defaultNegComparator, mapper);
	    },

	    rest: function() {
	      return this.slice(1);
	    },

	    skip: function(amount) {
	      return this.slice(Math.max(0, amount));
	    },

	    skipLast: function(amount) {
	      return reify(this, this.toSeq().reverse().skip(amount).reverse());
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, true));
	    },

	    skipUntil: function(predicate, context) {
	      return this.skipWhile(not(predicate), context);
	    },

	    sortBy: function(mapper, comparator) {
	      return reify(this, sortFactory(this, comparator, mapper));
	    },

	    take: function(amount) {
	      return this.slice(0, Math.max(0, amount));
	    },

	    takeLast: function(amount) {
	      return reify(this, this.toSeq().reverse().take(amount).reverse());
	    },

	    takeWhile: function(predicate, context) {
	      return reify(this, takeWhileFactory(this, predicate, context));
	    },

	    takeUntil: function(predicate, context) {
	      return this.takeWhile(not(predicate), context);
	    },

	    valueSeq: function() {
	      return this.toIndexedSeq();
	    },


	    // ### Hashable Object

	    hashCode: function() {
	      return this.__hash || (this.__hash = hashIterable(this));
	    },


	    // ### Internal

	    // abstract __iterate(fn, reverse)

	    // abstract __iterator(type, reverse)
	  });

	  // var IS_ITERABLE_SENTINEL = '@@__IMMUTABLE_ITERABLE__@@';
	  // var IS_KEYED_SENTINEL = '@@__IMMUTABLE_KEYED__@@';
	  // var IS_INDEXED_SENTINEL = '@@__IMMUTABLE_INDEXED__@@';
	  // var IS_ORDERED_SENTINEL = '@@__IMMUTABLE_ORDERED__@@';

	  var IterablePrototype = Iterable.prototype;
	  IterablePrototype[IS_ITERABLE_SENTINEL] = true;
	  IterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.values;
	  IterablePrototype.__toJS = IterablePrototype.toArray;
	  IterablePrototype.__toStringMapper = quoteString;
	  IterablePrototype.inspect =
	  IterablePrototype.toSource = function() { return this.toString(); };
	  IterablePrototype.chain = IterablePrototype.flatMap;

	  // Temporary warning about using length
	  (function () {
	    try {
	      Object.defineProperty(IterablePrototype, 'length', {
	        get: function () {
	          if (!Iterable.noLengthWarning) {
	            var stack;
	            try {
	              throw new Error();
	            } catch (error) {
	              stack = error.stack;
	            }
	            if (stack.indexOf('_wrapObject') === -1) {
	              console && console.warn && console.warn(
	                'iterable.length has been deprecated, '+
	                'use iterable.size or iterable.count(). '+
	                'This warning will become a silent error in a future version. ' +
	                stack
	              );
	              return this.size;
	            }
	          }
	        }
	      });
	    } catch (e) {}
	  })();



	  mixin(KeyedIterable, {

	    // ### More sequential methods

	    flip: function() {
	      return reify(this, flipFactory(this));
	    },

	    findKey: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry && entry[0];
	    },

	    findLastKey: function(predicate, context) {
	      return this.toSeq().reverse().findKey(predicate, context);
	    },

	    keyOf: function(searchValue) {
	      return this.findKey(function(value ) {return is(value, searchValue)});
	    },

	    lastKeyOf: function(searchValue) {
	      return this.findLastKey(function(value ) {return is(value, searchValue)});
	    },

	    mapEntries: function(mapper, context) {var this$0 = this;
	      var iterations = 0;
	      return reify(this,
	        this.toSeq().map(
	          function(v, k)  {return mapper.call(context, [k, v], iterations++, this$0)}
	        ).fromEntrySeq()
	      );
	    },

	    mapKeys: function(mapper, context) {var this$0 = this;
	      return reify(this,
	        this.toSeq().flip().map(
	          function(k, v)  {return mapper.call(context, k, v, this$0)}
	        ).flip()
	      );
	    },

	  });

	  var KeyedIterablePrototype = KeyedIterable.prototype;
	  KeyedIterablePrototype[IS_KEYED_SENTINEL] = true;
	  KeyedIterablePrototype[ITERATOR_SYMBOL] = IterablePrototype.entries;
	  KeyedIterablePrototype.__toJS = IterablePrototype.toObject;
	  KeyedIterablePrototype.__toStringMapper = function(v, k)  {return JSON.stringify(k) + ': ' + quoteString(v)};



	  mixin(IndexedIterable, {

	    // ### Conversion to other types

	    toKeyedSeq: function() {
	      return new ToKeyedSequence(this, false);
	    },


	    // ### ES6 Collection methods (ES6 Array and Map)

	    filter: function(predicate, context) {
	      return reify(this, filterFactory(this, predicate, context, false));
	    },

	    findIndex: function(predicate, context) {
	      var entry = this.findEntry(predicate, context);
	      return entry ? entry[0] : -1;
	    },

	    indexOf: function(searchValue) {
	      var key = this.toKeyedSeq().keyOf(searchValue);
	      return key === undefined ? -1 : key;
	    },

	    lastIndexOf: function(searchValue) {
	      return this.toSeq().reverse().indexOf(searchValue);
	    },

	    reverse: function() {
	      return reify(this, reverseFactory(this, false));
	    },

	    slice: function(begin, end) {
	      return reify(this, sliceFactory(this, begin, end, false));
	    },

	    splice: function(index, removeNum /*, ...values*/) {
	      var numArgs = arguments.length;
	      removeNum = Math.max(removeNum | 0, 0);
	      if (numArgs === 0 || (numArgs === 2 && !removeNum)) {
	        return this;
	      }
	      index = resolveBegin(index, this.size);
	      var spliced = this.slice(0, index);
	      return reify(
	        this,
	        numArgs === 1 ?
	          spliced :
	          spliced.concat(arrCopy(arguments, 2), this.slice(index + removeNum))
	      );
	    },


	    // ### More collection methods

	    findLastIndex: function(predicate, context) {
	      var key = this.toKeyedSeq().findLastKey(predicate, context);
	      return key === undefined ? -1 : key;
	    },

	    first: function() {
	      return this.get(0);
	    },

	    flatten: function(depth) {
	      return reify(this, flattenFactory(this, depth, false));
	    },

	    get: function(index, notSetValue) {
	      index = wrapIndex(this, index);
	      return (index < 0 || (this.size === Infinity ||
	          (this.size !== undefined && index > this.size))) ?
	        notSetValue :
	        this.find(function(_, key)  {return key === index}, undefined, notSetValue);
	    },

	    has: function(index) {
	      index = wrapIndex(this, index);
	      return index >= 0 && (this.size !== undefined ?
	        this.size === Infinity || index < this.size :
	        this.indexOf(index) !== -1
	      );
	    },

	    interpose: function(separator) {
	      return reify(this, interposeFactory(this, separator));
	    },

	    interleave: function(/*...iterables*/) {
	      var iterables = [this].concat(arrCopy(arguments));
	      var zipped = zipWithFactory(this.toSeq(), IndexedSeq.of, iterables);
	      var interleaved = zipped.flatten(true);
	      if (zipped.size) {
	        interleaved.size = zipped.size * iterables.length;
	      }
	      return reify(this, interleaved);
	    },

	    last: function() {
	      return this.get(-1);
	    },

	    skipWhile: function(predicate, context) {
	      return reify(this, skipWhileFactory(this, predicate, context, false));
	    },

	    zip: function(/*, ...iterables */) {
	      var iterables = [this].concat(arrCopy(arguments));
	      return reify(this, zipWithFactory(this, defaultZipper, iterables));
	    },

	    zipWith: function(zipper/*, ...iterables */) {
	      var iterables = arrCopy(arguments);
	      iterables[0] = this;
	      return reify(this, zipWithFactory(this, zipper, iterables));
	    },

	  });

	  IndexedIterable.prototype[IS_INDEXED_SENTINEL] = true;
	  IndexedIterable.prototype[IS_ORDERED_SENTINEL] = true;



	  mixin(SetIterable, {

	    // ### ES6 Collection methods (ES6 Array and Map)

	    get: function(value, notSetValue) {
	      return this.has(value) ? value : notSetValue;
	    },

	    includes: function(value) {
	      return this.has(value);
	    },


	    // ### More sequential methods

	    keySeq: function() {
	      return this.valueSeq();
	    },

	  });

	  SetIterable.prototype.has = IterablePrototype.includes;


	  // Mixin subclasses

	  mixin(KeyedSeq, KeyedIterable.prototype);
	  mixin(IndexedSeq, IndexedIterable.prototype);
	  mixin(SetSeq, SetIterable.prototype);

	  mixin(KeyedCollection, KeyedIterable.prototype);
	  mixin(IndexedCollection, IndexedIterable.prototype);
	  mixin(SetCollection, SetIterable.prototype);


	  // #pragma Helper functions

	  function keyMapper(v, k) {
	    return k;
	  }

	  function entryMapper(v, k) {
	    return [k, v];
	  }

	  function not(predicate) {
	    return function() {
	      return !predicate.apply(this, arguments);
	    }
	  }

	  function neg(predicate) {
	    return function() {
	      return -predicate.apply(this, arguments);
	    }
	  }

	  function quoteString(value) {
	    return typeof value === 'string' ? JSON.stringify(value) : value;
	  }

	  function defaultZipper() {
	    return arrCopy(arguments);
	  }

	  function defaultNegComparator(a, b) {
	    return a < b ? 1 : a > b ? -1 : 0;
	  }

	  function hashIterable(iterable) {
	    if (iterable.size === Infinity) {
	      return 0;
	    }
	    var ordered = isOrdered(iterable);
	    var keyed = isKeyed(iterable);
	    var h = ordered ? 1 : 0;
	    var size = iterable.__iterate(
	      keyed ?
	        ordered ?
	          function(v, k)  { h = 31 * h + hashMerge(hash(v), hash(k)) | 0; } :
	          function(v, k)  { h = h + hashMerge(hash(v), hash(k)) | 0; } :
	        ordered ?
	          function(v ) { h = 31 * h + hash(v) | 0; } :
	          function(v ) { h = h + hash(v) | 0; }
	    );
	    return murmurHashOfSize(size, h);
	  }

	  function murmurHashOfSize(size, h) {
	    h = src_Math__imul(h, 0xCC9E2D51);
	    h = src_Math__imul(h << 15 | h >>> -15, 0x1B873593);
	    h = src_Math__imul(h << 13 | h >>> -13, 5);
	    h = (h + 0xE6546B64 | 0) ^ size;
	    h = src_Math__imul(h ^ h >>> 16, 0x85EBCA6B);
	    h = src_Math__imul(h ^ h >>> 13, 0xC2B2AE35);
	    h = smi(h ^ h >>> 16);
	    return h;
	  }

	  function hashMerge(a, b) {
	    return a ^ b + 0x9E3779B9 + (a << 6) + (a >> 2) | 0; // int
	  }

	  var Immutable = {

	    Iterable: Iterable,

	    Seq: Seq,
	    Collection: Collection,
	    Map: src_Map__Map,
	    OrderedMap: OrderedMap,
	    List: List,
	    Stack: Stack,
	    Set: src_Set__Set,
	    OrderedSet: OrderedSet,

	    Record: Record,
	    Range: Range,
	    Repeat: Repeat,

	    is: is,
	    fromJS: fromJS,

	  };

	  return Immutable;

	}));

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    draining = true;
	    var currentQueue;
	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        var i = -1;
	        while (++i < len) {
	            currentQueue[i]();
	        }
	        len = queue.length;
	    }
	    draining = false;
	}
	process.nextTick = function (fun) {
	    queue.push(fun);
	    if (!draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(setImmediate, clearImmediate) {var nextTick = __webpack_require__(45).nextTick;
	var apply = Function.prototype.apply;
	var slice = Array.prototype.slice;
	var immediateIds = {};
	var nextImmediateId = 0;

	// DOM APIs, for completeness

	exports.setTimeout = function() {
	  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
	};
	exports.setInterval = function() {
	  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) { timeout.close(); };

	function Timeout(id, clearFn) {
	  this._id = id;
	  this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
	  this._clearFn.call(window, this._id);
	};

	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = msecs;
	};

	exports.unenroll = function(item) {
	  clearTimeout(item._idleTimeoutId);
	  item._idleTimeout = -1;
	};

	exports._unrefActive = exports.active = function(item) {
	  clearTimeout(item._idleTimeoutId);

	  var msecs = item._idleTimeout;
	  if (msecs >= 0) {
	    item._idleTimeoutId = setTimeout(function onTimeout() {
	      if (item._onTimeout)
	        item._onTimeout();
	    }, msecs);
	  }
	};

	// That's not how node.js implements it but the exposed api is the same.
	exports.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
	  var id = nextImmediateId++;
	  var args = arguments.length < 2 ? false : slice.call(arguments, 1);

	  immediateIds[id] = true;

	  nextTick(function onNextTick() {
	    if (immediateIds[id]) {
	      // fn.call() is faster so we optimize for the common use-case
	      // @see http://jsperf.com/call-apply-segu
	      if (args) {
	        fn.apply(null, args);
	      } else {
	        fn.call(null);
	      }
	      // Prevent ids from leaking
	      exports.clearImmediate(id);
	    }
	  });

	  return id;
	};

	exports.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
	  delete immediateIds[id];
	};
	/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(27).setImmediate, __webpack_require__(27).clearImmediate))

/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A module of methods that you want to include in all actions.
	 * This module is consumed by `createAction`.
	 */
	module.exports = {
	};


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(40),
	    maker = __webpack_require__(39).instanceJoinCreator;

	/**
	 * Extract child listenables from a parent from their
	 * children property and return them in a keyed Object
	 *
	 * @param {Object} listenable The parent listenable
	 */
	var mapChildListenables = function(listenable) {
	    var i = 0, children = {}, childName;
	    for (;i < (listenable.children||[]).length; ++i) {
	        childName = listenable.children[i];
	        if(listenable[childName]){
	            children[childName] = listenable[childName];
	        }
	    }
	    return children;
	};

	/**
	 * Make a flat dictionary of all listenables including their
	 * possible children (recursively), concatenating names in camelCase.
	 *
	 * @param {Object} listenables The top-level listenables
	 */
	var flattenListenables = function(listenables) {
	    var flattened = {};
	    for(var key in listenables){
	        var listenable = listenables[key];
	        var childMap = mapChildListenables(listenable);

	        // recursively flatten children
	        var children = flattenListenables(childMap);

	        // add the primary listenable and chilren
	        flattened[key] = listenable;
	        for(var childKey in children){
	            var childListenable = children[childKey];
	            flattened[key + _.capitalize(childKey)] = childListenable;
	        }
	    }

	    return flattened;
	};

	/**
	 * A module of methods related to listening.
	 */
	module.exports = {

	    /**
	     * An internal utility function used by `validateListening`
	     *
	     * @param {Action|Store} listenable The listenable we want to search for
	     * @returns {Boolean} The result of a recursive search among `this.subscriptions`
	     */
	    hasListener: function(listenable) {
	        var i = 0, j, listener, listenables;
	        for (;i < (this.subscriptions||[]).length; ++i) {
	            listenables = [].concat(this.subscriptions[i].listenable);
	            for (j = 0; j < listenables.length; j++){
	                listener = listenables[j];
	                if (listener === listenable || listener.hasListener && listener.hasListener(listenable)) {
	                    return true;
	                }
	            }
	        }
	        return false;
	    },

	    /**
	     * A convenience method that listens to all listenables in the given object.
	     *
	     * @param {Object} listenables An object of listenables. Keys will be used as callback method names.
	     */
	    listenToMany: function(listenables){
	        var allListenables = flattenListenables(listenables);
	        for(var key in allListenables){
	            var cbname = _.callbackName(key),
	                localname = this[cbname] ? cbname : this[key] ? key : undefined;
	            if (localname){
	                this.listenTo(allListenables[key],localname,this[cbname+"Default"]||this[localname+"Default"]||localname);
	            }
	        }
	    },

	    /**
	     * Checks if the current context can listen to the supplied listenable
	     *
	     * @param {Action|Store} listenable An Action or Store that should be
	     *  listened to.
	     * @returns {String|Undefined} An error message, or undefined if there was no problem.
	     */
	    validateListening: function(listenable){
	        if (listenable === this) {
	            return "Listener is not able to listen to itself";
	        }
	        if (!_.isFunction(listenable.listen)) {
	            return listenable + " is missing a listen method";
	        }
	        if (listenable.hasListener && listenable.hasListener(this)) {
	            return "Listener cannot listen to this listenable because of circular loop";
	        }
	    },

	    /**
	     * Sets up a subscription to the given listenable for the context object
	     *
	     * @param {Action|Store} listenable An Action or Store that should be
	     *  listened to.
	     * @param {Function|String} callback The callback to register as event handler
	     * @param {Function|String} defaultCallback The callback to register as default handler
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to
	     */
	    listenTo: function(listenable, callback, defaultCallback) {
	        var desub, unsubscriber, subscriptionobj, subs = this.subscriptions = this.subscriptions || [];
	        _.throwIf(this.validateListening(listenable));
	        this.fetchInitialState(listenable, defaultCallback);
	        desub = listenable.listen(this[callback]||callback, this);
	        unsubscriber = function() {
	            var index = subs.indexOf(subscriptionobj);
	            _.throwIf(index === -1,'Tried to remove listen already gone from subscriptions list!');
	            subs.splice(index, 1);
	            desub();
	        };
	        subscriptionobj = {
	            stop: unsubscriber,
	            listenable: listenable
	        };
	        subs.push(subscriptionobj);
	        return subscriptionobj;
	    },

	    /**
	     * Stops listening to a single listenable
	     *
	     * @param {Action|Store} listenable The action or store we no longer want to listen to
	     * @returns {Boolean} True if a subscription was found and removed, otherwise false.
	     */
	    stopListeningTo: function(listenable){
	        var sub, i = 0, subs = this.subscriptions || [];
	        for(;i < subs.length; i++){
	            sub = subs[i];
	            if (sub.listenable === listenable){
	                sub.stop();
	                _.throwIf(subs.indexOf(sub)!==-1,'Failed to remove listen from subscriptions list!');
	                return true;
	            }
	        }
	        return false;
	    },

	    /**
	     * Stops all subscriptions and empties subscriptions array
	     */
	    stopListeningToAll: function(){
	        var remaining, subs = this.subscriptions || [];
	        while((remaining=subs.length)){
	            subs[0].stop();
	            _.throwIf(subs.length!==remaining-1,'Failed to remove listen from subscriptions list!');
	        }
	    },

	    /**
	     * Used in `listenTo`. Fetches initial data from a publisher if it has a `getInitialState` method.
	     * @param {Action|Store} listenable The publisher we want to get initial state from
	     * @param {Function|String} defaultCallback The method to receive the data
	     */
	    fetchInitialState: function (listenable, defaultCallback) {
	        defaultCallback = (defaultCallback && this[defaultCallback]) || defaultCallback;
	        var me = this;
	        if (_.isFunction(defaultCallback) && _.isFunction(listenable.getInitialState)) {
	            var data = listenable.getInitialState();
	            if (data && _.isFunction(data.then)) {
	                data.then(function() {
	                    defaultCallback.apply(me, arguments);
	                });
	            } else {
	                defaultCallback.call(this, data);
	            }
	        }
	    },

	    /**
	     * The callback will be called once all listenables have triggered at least once.
	     * It will be invoked with the last emission from each listenable.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinTrailing: maker("last"),

	    /**
	     * The callback will be called once all listenables have triggered at least once.
	     * It will be invoked with the first emission from each listenable.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinLeading: maker("first"),

	    /**
	     * The callback will be called once all listenables have triggered at least once.
	     * It will be invoked with all emission from each listenable.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinConcat: maker("all"),

	    /**
	     * The callback will be called once all listenables have triggered.
	     * If a callback triggers twice before that happens, an error is thrown.
	     * @param {...Publishers} publishers Publishers that should be tracked.
	     * @param {Function|String} callback The method to call when all publishers have emitted
	     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables
	     */
	    joinStrict: maker("strict")
	};


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(40);

	/**
	 * A module of methods for object that you want to be able to listen to.
	 * This module is consumed by `createStore` and `createAction`
	 */
	module.exports = {

	    /**
	     * Hook used by the publisher that is invoked before emitting
	     * and before `shouldEmit`. The arguments are the ones that the action
	     * is invoked with. If this function returns something other than
	     * undefined, that will be passed on as arguments for shouldEmit and
	     * emission.
	     */
	    preEmit: function() {},

	    /**
	     * Hook used by the publisher after `preEmit` to determine if the
	     * event should be emitted with given arguments. This may be overridden
	     * in your application, default implementation always returns true.
	     *
	     * @returns {Boolean} true if event should be emitted
	     */
	    shouldEmit: function() { return true; },

	    /**
	     * Subscribes the given callback for action triggered
	     *
	     * @param {Function} callback The callback to register as event handler
	     * @param {Mixed} [optional] bindContext The context to bind the callback with
	     * @returns {Function} Callback that unsubscribes the registered event handler
	     */
	    listen: function(callback, bindContext) {
	        bindContext = bindContext || this;
	        var eventHandler = function(args) {
	            if (aborted){
	                return;
	            }
	            callback.apply(bindContext, args);
	        }, me = this, aborted = false;
	        this.emitter.addListener(this.eventLabel, eventHandler);
	        return function() {
	            aborted = true;
	            me.emitter.removeListener(me.eventLabel, eventHandler);
	        };
	    },

	    /**
	     * Attach handlers to promise that trigger the completed and failed
	     * child publishers, if available.
	     *
	     * @param {Object} The promise to attach to
	     */
	    promise: function(promise) {
	        var me = this;

	        var canHandlePromise =
	            this.children.indexOf('completed') >= 0 &&
	            this.children.indexOf('failed') >= 0;

	        if (!canHandlePromise){
	            throw new Error('Publisher must have "completed" and "failed" child publishers');
	        }

	        promise.then(function(response) {
	            return me.completed(response);
	        }, function(error) {
	            return me.failed(error);
	        });
	    },

	    /**
	     * Subscribes the given callback for action triggered, which should
	     * return a promise that in turn is passed to `this.promise`
	     *
	     * @param {Function} callback The callback to register as event handler
	     */
	    listenAndPromise: function(callback, bindContext) {
	        var me = this;
	        bindContext = bindContext || this;
	        this.willCallPromise = (this.willCallPromise || 0) + 1;

	        var removeListen = this.listen(function() {

	            if (!callback) {
	                throw new Error('Expected a function returning a promise but got ' + callback);
	            }

	            var args = arguments,
	                promise = callback.apply(bindContext, args);
	            return me.promise.call(me, promise);
	        }, bindContext);

	        return function () {
	          me.willCallPromise--;
	          removeListen.call(me);
	        };

	    },

	    /**
	     * Publishes an event using `this.emitter` (if `shouldEmit` agrees)
	     */
	    trigger: function() {
	        var args = arguments,
	            pre = this.preEmit.apply(this, args);
	        args = pre === undefined ? args : _.isArguments(pre) ? pre : [].concat(pre);
	        if (this.shouldEmit.apply(this, args)) {
	            this.emitter.emit(this.eventLabel, args);
	        }
	    },

	    /**
	     * Tries to publish the event on the next tick
	     */
	    triggerAsync: function(){
	        var args = arguments,me = this;
	        _.nextTick(function() {
	            me.trigger.apply(me, args);
	        });
	    },

	    /**
	     * Returns a Promise for the triggered action
	     *
	     * @return {Promise}
	     *   Resolved by completed child action.
	     *   Rejected by failed child action.
	     *   If listenAndPromise'd, then promise associated to this trigger.
	     *   Otherwise, the promise is for next child action completion.
	     */
	    triggerPromise: function(){
	        var me = this;
	        var args = arguments;

	        var canHandlePromise =
	            this.children.indexOf('completed') >= 0 &&
	            this.children.indexOf('failed') >= 0;

	        var promise = _.createPromise(function(resolve, reject) {
	            // If `listenAndPromise` is listening
	            // patch `promise` w/ context-loaded resolve/reject
	            if (me.willCallPromise) {
	                _.nextTick(function() {
	                    var old_promise_method = me.promise;
	                    me.promise = function (promise) {
	                        promise.then(resolve, reject);
	                        // Back to your regularly schedule programming.
	                        me.promise = old_promise_method;
	                        return me.promise.apply(me, arguments);
	                    };
	                    me.trigger.apply(me, args);
	                });
	                return;
	            }

	            if (canHandlePromise) {
	                var removeSuccess = me.completed.listen(function(args) {
	                    removeSuccess();
	                    removeFailed();
	                    resolve(args);
	                });

	                var removeFailed = me.failed.listen(function(args) {
	                    removeSuccess();
	                    removeFailed();
	                    reject(args);
	                });
	            }

	            me.triggerAsync.apply(me, args);

	            if (!canHandlePromise) {
	                resolve();
	            }
	        });

	        return promise;
	    }
	};


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * A module of methods that you want to include in all stores.
	 * This module is consumed by `createStore`.
	 */
	module.exports = {
	};


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(40),
	    Reflux = __webpack_require__(23),
	    Keep = __webpack_require__(41),
	    allowed = {preEmit:1,shouldEmit:1};

	/**
	 * Creates an action functor object. It is mixed in with functions
	 * from the `PublisherMethods` mixin. `preEmit` and `shouldEmit` may
	 * be overridden in the definition object.
	 *
	 * @param {Object} definition The action object definition
	 */
	var createAction = function(definition) {

	    definition = definition || {};
	    if (!_.isObject(definition)){
	        definition = {actionName: definition};
	    }

	    for(var a in Reflux.ActionMethods){
	        if (!allowed[a] && Reflux.PublisherMethods[a]) {
	            throw new Error("Cannot override API method " + a +
	                " in Reflux.ActionMethods. Use another method name or override it on Reflux.PublisherMethods instead."
	            );
	        }
	    }

	    for(var d in definition){
	        if (!allowed[d] && Reflux.PublisherMethods[d]) {
	            throw new Error("Cannot override API method " + d +
	                " in action creation. Use another method name or override it on Reflux.PublisherMethods instead."
	            );
	        }
	    }

	    definition.children = definition.children || [];
	    if (definition.asyncResult){
	        definition.children = definition.children.concat(["completed","failed"]);
	    }

	    var i = 0, childActions = {};
	    for (; i < definition.children.length; i++) {
	        var name = definition.children[i];
	        childActions[name] = createAction(name);
	    }

	    var context = _.extend({
	        eventLabel: "action",
	        emitter: new _.EventEmitter(),
	        _isAction: true
	    }, Reflux.PublisherMethods, Reflux.ActionMethods, definition);

	    var functor = function() {
	        return functor[functor.sync?"trigger":"triggerPromise"].apply(functor, arguments);
	    };

	    _.extend(functor,childActions,context);

	    Keep.createdActions.push(functor);

	    return functor;

	};

	module.exports = createAction;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(40),
	    Reflux = __webpack_require__(23),
	    Keep = __webpack_require__(41),
	    mixer = __webpack_require__(43),
	    allowed = {preEmit:1,shouldEmit:1},
	    bindMethods = __webpack_require__(44);

	/**
	 * Creates an event emitting Data Store. It is mixed in with functions
	 * from the `ListenerMethods` and `PublisherMethods` mixins. `preEmit`
	 * and `shouldEmit` may be overridden in the definition object.
	 *
	 * @param {Object} definition The data store object definition
	 * @returns {Store} A data store instance
	 */
	module.exports = function(definition) {

	    definition = definition || {};

	    for(var a in Reflux.StoreMethods){
	        if (!allowed[a] && (Reflux.PublisherMethods[a] || Reflux.ListenerMethods[a])){
	            throw new Error("Cannot override API method " + a +
	                " in Reflux.StoreMethods. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead."
	            );
	        }
	    }

	    for(var d in definition){
	        if (!allowed[d] && (Reflux.PublisherMethods[d] || Reflux.ListenerMethods[d])){
	            throw new Error("Cannot override API method " + d +
	                " in store creation. Use another method name or override it on Reflux.PublisherMethods / Reflux.ListenerMethods instead."
	            );
	        }
	    }

	    definition = mixer(definition);

	    function Store() {
	        var i=0, arr;
	        this.subscriptions = [];
	        this.emitter = new _.EventEmitter();
	        this.eventLabel = "change";
	        bindMethods(this, definition);
	        if (this.init && _.isFunction(this.init)) {
	            this.init();
	        }
	        if (this.listenables){
	            arr = [].concat(this.listenables);
	            for(;i < arr.length;i++){
	                this.listenToMany(arr[i]);
	            }
	        }
	    }

	    _.extend(Store.prototype, Reflux.ListenerMethods, Reflux.PublisherMethods, Reflux.StoreMethods, definition);

	    var store = new Store();
	    Keep.createdStores.push(store);

	    return store;
	};


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

	var Reflux = __webpack_require__(23),
	    _ = __webpack_require__(40);

	module.exports = function(listenable,key){
	    return {
	        getInitialState: function(){
	            if (!_.isFunction(listenable.getInitialState)) {
	                return {};
	            } else if (key === undefined) {
	                return listenable.getInitialState();
	            } else {
	                return _.object([key],[listenable.getInitialState()]);
	            }
	        },
	        componentDidMount: function(){
	            _.extend(this,Reflux.ListenerMethods);
	            var me = this, cb = (key === undefined ? this.setState : function(v){me.setState(_.object([key],[v]));});
	            this.listenTo(listenable,cb);
	        },
	        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount
	    };
	};


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

	var Reflux = __webpack_require__(23),
	  _ = __webpack_require__(40);

	module.exports = function(listenable, key, filterFunc) {
	    filterFunc = _.isFunction(key) ? key : filterFunc;
	    return {
	        getInitialState: function() {
	            if (!_.isFunction(listenable.getInitialState)) {
	                return {};
	            } else if (_.isFunction(key)) {
	                return filterFunc.call(this, listenable.getInitialState());
	            } else {
	                // Filter initial payload from store.
	                var result = filterFunc.call(this, listenable.getInitialState());
	                if (result) {
	                  return _.object([key], [result]);
	                } else {
	                  return {};
	                }
	            }
	        },
	        componentDidMount: function() {
	            _.extend(this, Reflux.ListenerMethods);
	            var me = this;
	            var cb = function(value) {
	                if (_.isFunction(key)) {
	                    me.setState(filterFunc.call(me, value));
	                } else {
	                    var result = filterFunc.call(me, value);
	                    me.setState(_.object([key], [result]));
	                }
	            };

	            this.listenTo(listenable, cb);
	        },
	        componentWillUnmount: Reflux.ListenerMixin.componentWillUnmount
	    };
	};



/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(40),
	    ListenerMethods = __webpack_require__(29);

	/**
	 * A module meant to be consumed as a mixin by a React component. Supplies the methods from
	 * `ListenerMethods` mixin and takes care of teardown of subscriptions.
	 * Note that if you're using the `connect` mixin you don't need this mixin, as connect will
	 * import everything this mixin contains!
	 */
	module.exports = _.extend({

	    /**
	     * Cleans up all listener previously registered.
	     */
	    componentWillUnmount: ListenerMethods.stopListeningToAll

	}, ListenerMethods);


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	var Reflux = __webpack_require__(23);


	/**
	 * A mixin factory for a React component. Meant as a more convenient way of using the `ListenerMixin`,
	 * without having to manually set listeners in the `componentDidMount` method.
	 *
	 * @param {Action|Store} listenable An Action or Store that should be
	 *  listened to.
	 * @param {Function|String} callback The callback to register as event handler
	 * @param {Function|String} defaultCallback The callback to register as default handler
	 * @returns {Object} An object to be used as a mixin, which sets up the listener for the given listenable.
	 */
	module.exports = function(listenable,callback,initial){
	    return {
	        /**
	         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
	         * and then make the call to `listenTo` with the arguments provided to the factory function
	         */
	        componentDidMount: function() {
	            for(var m in Reflux.ListenerMethods){
	                if (this[m] !== Reflux.ListenerMethods[m]){
	                    if (this[m]){
	                        throw "Can't have other property '"+m+"' when using Reflux.listenTo!";
	                    }
	                    this[m] = Reflux.ListenerMethods[m];
	                }
	            }
	            this.listenTo(listenable,callback,initial);
	        },
	        /**
	         * Cleans up all listener previously registered.
	         */
	        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll
	    };
	};


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	var Reflux = __webpack_require__(23);

	/**
	 * A mixin factory for a React component. Meant as a more convenient way of using the `listenerMixin`,
	 * without having to manually set listeners in the `componentDidMount` method. This version is used
	 * to automatically set up a `listenToMany` call.
	 *
	 * @param {Object} listenables An object of listenables
	 * @returns {Object} An object to be used as a mixin, which sets up the listeners for the given listenables.
	 */
	module.exports = function(listenables){
	    return {
	        /**
	         * Set up the mixin before the initial rendering occurs. Import methods from `ListenerMethods`
	         * and then make the call to `listenTo` with the arguments provided to the factory function
	         */
	        componentDidMount: function() {
	            for(var m in Reflux.ListenerMethods){
	                if (this[m] !== Reflux.ListenerMethods[m]){
	                    if (this[m]){
	                        throw "Can't have other property '"+m+"' when using Reflux.listenToMany!";
	                    }
	                    this[m] = Reflux.ListenerMethods[m];
	                }
	            }
	            this.listenToMany(listenables);
	        },
	        /**
	         * Cleans up all listener previously registered.
	         */
	        componentWillUnmount: Reflux.ListenerMethods.stopListeningToAll
	    };
	};


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	/**
	 * Internal module used to create static and instance join methods
	 */

	var slice = Array.prototype.slice,
	    _ = __webpack_require__(40),
	    createStore = __webpack_require__(33),
	    strategyMethodNames = {
	        strict: "joinStrict",
	        first: "joinLeading",
	        last: "joinTrailing",
	        all: "joinConcat"
	    };

	/**
	 * Used in `index.js` to create the static join methods
	 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
	 * @returns {Function} A static function which returns a store with a join listen on the given listenables using the given strategy
	 */
	exports.staticJoinCreator = function(strategy){
	    return function(/* listenables... */) {
	        var listenables = slice.call(arguments);
	        return createStore({
	            init: function(){
	                this[strategyMethodNames[strategy]].apply(this,listenables.concat("triggerAsync"));
	            }
	        });
	    };
	};

	/**
	 * Used in `ListenerMethods.js` to create the instance join methods
	 * @param {String} strategy Which strategy to use when tracking listenable trigger arguments
	 * @returns {Function} An instance method which sets up a join listen on the given listenables using the given strategy
	 */
	exports.instanceJoinCreator = function(strategy){
	    return function(/* listenables..., callback*/){
	        _.throwIf(arguments.length < 3,'Cannot create a join with less than 2 listenables!');
	        var listenables = slice.call(arguments),
	            callback = listenables.pop(),
	            numberOfListenables = listenables.length,
	            join = {
	                numberOfListenables: numberOfListenables,
	                callback: this[callback]||callback,
	                listener: this,
	                strategy: strategy
	            }, i, cancels = [], subobj;
	        for (i = 0; i < numberOfListenables; i++) {
	            _.throwIf(this.validateListening(listenables[i]));
	        }
	        for (i = 0; i < numberOfListenables; i++) {
	            cancels.push(listenables[i].listen(newListener(i,join),this));
	        }
	        reset(join);
	        subobj = {listenable: listenables};
	        subobj.stop = makeStopper(subobj,cancels,this);
	        this.subscriptions = (this.subscriptions || []).concat(subobj);
	        return subobj;
	    };
	};

	// ---- internal join functions ----

	function makeStopper(subobj,cancels,context){
	    return function() {
	        var i, subs = context.subscriptions,
	            index = (subs ? subs.indexOf(subobj) : -1);
	        _.throwIf(index === -1,'Tried to remove join already gone from subscriptions list!');
	        for(i=0;i < cancels.length; i++){
	            cancels[i]();
	        }
	        subs.splice(index, 1);
	    };
	}

	function reset(join) {
	    join.listenablesEmitted = new Array(join.numberOfListenables);
	    join.args = new Array(join.numberOfListenables);
	}

	function newListener(i,join) {
	    return function() {
	        var callargs = slice.call(arguments);
	        if (join.listenablesEmitted[i]){
	            switch(join.strategy){
	                case "strict": throw new Error("Strict join failed because listener triggered twice.");
	                case "last": join.args[i] = callargs; break;
	                case "all": join.args[i].push(callargs);
	            }
	        } else {
	            join.listenablesEmitted[i] = true;
	            join.args[i] = (join.strategy==="all"?[callargs]:callargs);
	        }
	        emitIfAllListenablesEmitted(join);
	    };
	}

	function emitIfAllListenablesEmitted(join) {
	    for (var i = 0; i < join.numberOfListenables; i++) {
	        if (!join.listenablesEmitted[i]) {
	            return;
	        }
	    }
	    join.callback.apply(join.listener,join.args);
	    reset(join);
	}


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	/*
	 * isObject, extend, isFunction, isArguments are taken from undescore/lodash in
	 * order to remove the dependency
	 */
	var isObject = exports.isObject = function(obj) {
	    var type = typeof obj;
	    return type === 'function' || type === 'object' && !!obj;
	};

	exports.extend = function(obj) {
	    if (!isObject(obj)) {
	        return obj;
	    }
	    var source, prop;
	    for (var i = 1, length = arguments.length; i < length; i++) {
	        source = arguments[i];
	        for (prop in source) {
	            if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
	                var propertyDescriptor = Object.getOwnPropertyDescriptor(source, prop);
	                Object.defineProperty(obj, prop, propertyDescriptor);
	            } else {
	                obj[prop] = source[prop];
	            }
	        }
	    }
	    return obj;
	};

	exports.isFunction = function(value) {
	    return typeof value === 'function';
	};

	exports.EventEmitter = __webpack_require__(46);

	exports.nextTick = function(callback) {
	    setTimeout(callback, 0);
	};

	exports.capitalize = function(string){
	    return string.charAt(0).toUpperCase()+string.slice(1);
	};

	exports.callbackName = function(string){
	    return "on"+exports.capitalize(string);
	};

	exports.object = function(keys,vals){
	    var o={}, i=0;
	    for(;i<keys.length;i++){
	        o[keys[i]] = vals[i];
	    }
	    return o;
	};

	exports.Promise = __webpack_require__(47);

	exports.createPromise = function(resolver) {
	    return new exports.Promise(resolver);
	};

	exports.isArguments = function(value) {
	    return typeof value === 'object' && ('callee' in value) && typeof value.length === 'number';
	};

	exports.throwIf = function(val,msg){
	    if (val){
	        throw Error(msg||val);
	    }
	};


/***/ },
/* 41 */
/***/ function(module, exports, __webpack_require__) {

	exports.createdStores = [];

	exports.createdActions = [];

	exports.reset = function() {
	    while(exports.createdStores.length) {
	        exports.createdStores.pop();
	    }
	    while(exports.createdActions.length) {
	        exports.createdActions.pop();
	    }
	};


/***/ },
/* 42 */
/***/ function(module, exports, __webpack_require__) {

	console.log("I'm `fs` modules");


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

	var _ = __webpack_require__(40);

	module.exports = function mix(def) {
	    var composed = {
	        init: [],
	        preEmit: [],
	        shouldEmit: []
	    };

	    var updated = (function mixDef(mixin) {
	        var mixed = {};
	        if (mixin.mixins) {
	            mixin.mixins.forEach(function (subMixin) {
	                _.extend(mixed, mixDef(subMixin));
	            });
	        }
	        _.extend(mixed, mixin);
	        Object.keys(composed).forEach(function (composable) {
	            if (mixin.hasOwnProperty(composable)) {
	                composed[composable].push(mixin[composable]);
	            }
	        });
	        return mixed;
	    }(def));

	    if (composed.init.length > 1) {
	        updated.init = function () {
	            var args = arguments;
	            composed.init.forEach(function (init) {
	                init.apply(this, args);
	            }, this);
	        };
	    }
	    if (composed.preEmit.length > 1) {
	        updated.preEmit = function () {
	            return composed.preEmit.reduce(function (args, preEmit) {
	                var newValue = preEmit.apply(this, args);
	                return newValue === undefined ? args : [newValue];
	            }.bind(this), arguments);
	        };
	    }
	    if (composed.shouldEmit.length > 1) {
	        updated.shouldEmit = function () {
	            var args = arguments;
	            return !composed.shouldEmit.some(function (shouldEmit) {
	                return !shouldEmit.apply(this, args);
	            }, this);
	        };
	    }
	    Object.keys(composed).forEach(function (composable) {
	        if (composed[composable].length === 1) {
	            updated[composable] = composed[composable][0];
	        }
	    });

	    return updated;
	};


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = function(store, definition) {
	  for (var name in definition) {
	    if (Object.getOwnPropertyDescriptor && Object.defineProperty) {
	        var propertyDescriptor = Object.getOwnPropertyDescriptor(definition, name);

	        if (!propertyDescriptor.value || typeof propertyDescriptor.value !== 'function' || !definition.hasOwnProperty(name)) {
	            continue;
	        }

	        store[name] = definition[name].bind(store);
	    } else {
	        var property = definition[name];

	        if (typeof property !== 'function' || !definition.hasOwnProperty(name)) {
	            continue;
	        }

	        store[name] = property.bind(store);
	    }
	  }

	  return store;
	};


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

	// shim for using process in browser

	var process = module.exports = {};
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;

	function cleanUpNextTick() {
	    draining = false;
	    if (currentQueue.length) {
	        queue = currentQueue.concat(queue);
	    } else {
	        queueIndex = -1;
	    }
	    if (queue.length) {
	        drainQueue();
	    }
	}

	function drainQueue() {
	    if (draining) {
	        return;
	    }
	    var timeout = setTimeout(cleanUpNextTick);
	    draining = true;

	    var len = queue.length;
	    while(len) {
	        currentQueue = queue;
	        queue = [];
	        while (++queueIndex < len) {
	            currentQueue[queueIndex].run();
	        }
	        queueIndex = -1;
	        len = queue.length;
	    }
	    currentQueue = null;
	    draining = false;
	    clearTimeout(timeout);
	}

	process.nextTick = function (fun) {
	    var args = new Array(arguments.length - 1);
	    if (arguments.length > 1) {
	        for (var i = 1; i < arguments.length; i++) {
	            args[i - 1] = arguments[i];
	        }
	    }
	    queue.push(new Item(fun, args));
	    if (queue.length === 1 && !draining) {
	        setTimeout(drainQueue, 0);
	    }
	};

	// v8 likes predictible objects
	function Item(fun, array) {
	    this.fun = fun;
	    this.array = array;
	}
	Item.prototype.run = function () {
	    this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};

	function noop() {}

	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;

	process.binding = function (name) {
	    throw new Error('process.binding is not supported');
	};

	// TODO(shtylman)
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
	    throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	/**
	 * Representation of a single EventEmitter function.
	 *
	 * @param {Function} fn Event handler to be called.
	 * @param {Mixed} context Context for function execution.
	 * @param {Boolean} once Only emit once
	 * @api private
	 */
	function EE(fn, context, once) {
	  this.fn = fn;
	  this.context = context;
	  this.once = once || false;
	}

	/**
	 * Minimal EventEmitter interface that is molded against the Node.js
	 * EventEmitter interface.
	 *
	 * @constructor
	 * @api public
	 */
	function EventEmitter() { /* Nothing to set */ }

	/**
	 * Holds the assigned EventEmitters by name.
	 *
	 * @type {Object}
	 * @private
	 */
	EventEmitter.prototype._events = undefined;

	/**
	 * Return a list of assigned event listeners.
	 *
	 * @param {String} event The events that should be listed.
	 * @returns {Array}
	 * @api public
	 */
	EventEmitter.prototype.listeners = function listeners(event) {
	  if (!this._events || !this._events[event]) return [];
	  if (this._events[event].fn) return [this._events[event].fn];

	  for (var i = 0, l = this._events[event].length, ee = new Array(l); i < l; i++) {
	    ee[i] = this._events[event][i].fn;
	  }

	  return ee;
	};

	/**
	 * Emit an event to all registered event listeners.
	 *
	 * @param {String} event The name of the event.
	 * @returns {Boolean} Indication if we've emitted an event.
	 * @api public
	 */
	EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
	  if (!this._events || !this._events[event]) return false;

	  var listeners = this._events[event]
	    , len = arguments.length
	    , args
	    , i;

	  if ('function' === typeof listeners.fn) {
	    if (listeners.once) this.removeListener(event, listeners.fn, true);

	    switch (len) {
	      case 1: return listeners.fn.call(listeners.context), true;
	      case 2: return listeners.fn.call(listeners.context, a1), true;
	      case 3: return listeners.fn.call(listeners.context, a1, a2), true;
	      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;
	      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
	      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
	    }

	    for (i = 1, args = new Array(len -1); i < len; i++) {
	      args[i - 1] = arguments[i];
	    }

	    listeners.fn.apply(listeners.context, args);
	  } else {
	    var length = listeners.length
	      , j;

	    for (i = 0; i < length; i++) {
	      if (listeners[i].once) this.removeListener(event, listeners[i].fn, true);

	      switch (len) {
	        case 1: listeners[i].fn.call(listeners[i].context); break;
	        case 2: listeners[i].fn.call(listeners[i].context, a1); break;
	        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;
	        default:
	          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {
	            args[j - 1] = arguments[j];
	          }

	          listeners[i].fn.apply(listeners[i].context, args);
	      }
	    }
	  }

	  return true;
	};

	/**
	 * Register a new EventListener for the given event.
	 *
	 * @param {String} event Name of the event.
	 * @param {Functon} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.on = function on(event, fn, context) {
	  var listener = new EE(fn, context || this);

	  if (!this._events) this._events = {};
	  if (!this._events[event]) this._events[event] = listener;
	  else {
	    if (!this._events[event].fn) this._events[event].push(listener);
	    else this._events[event] = [
	      this._events[event], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Add an EventListener that's only called once.
	 *
	 * @param {String} event Name of the event.
	 * @param {Function} fn Callback function.
	 * @param {Mixed} context The context of the function.
	 * @api public
	 */
	EventEmitter.prototype.once = function once(event, fn, context) {
	  var listener = new EE(fn, context || this, true);

	  if (!this._events) this._events = {};
	  if (!this._events[event]) this._events[event] = listener;
	  else {
	    if (!this._events[event].fn) this._events[event].push(listener);
	    else this._events[event] = [
	      this._events[event], listener
	    ];
	  }

	  return this;
	};

	/**
	 * Remove event listeners.
	 *
	 * @param {String} event The event we want to remove.
	 * @param {Function} fn The listener that we need to find.
	 * @param {Boolean} once Only remove once listeners.
	 * @api public
	 */
	EventEmitter.prototype.removeListener = function removeListener(event, fn, once) {
	  if (!this._events || !this._events[event]) return this;

	  var listeners = this._events[event]
	    , events = [];

	  if (fn) {
	    if (listeners.fn && (listeners.fn !== fn || (once && !listeners.once))) {
	      events.push(listeners);
	    }
	    if (!listeners.fn) for (var i = 0, length = listeners.length; i < length; i++) {
	      if (listeners[i].fn !== fn || (once && !listeners[i].once)) {
	        events.push(listeners[i]);
	      }
	    }
	  }

	  //
	  // Reset the array, or remove it completely if we have no more listeners.
	  //
	  if (events.length) {
	    this._events[event] = events.length === 1 ? events[0] : events;
	  } else {
	    delete this._events[event];
	  }

	  return this;
	};

	/**
	 * Remove all listeners or only the listeners for the specified event.
	 *
	 * @param {String} event The event want to remove all listeners for.
	 * @api public
	 */
	EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
	  if (!this._events) return this;

	  if (event) delete this._events[event];
	  else this._events = {};

	  return this;
	};

	//
	// Alias methods names because people roll like that.
	//
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	EventEmitter.prototype.addListener = EventEmitter.prototype.on;

	//
	// This function doesn't apply anymore.
	//
	EventEmitter.prototype.setMaxListeners = function setMaxListeners() {
	  return this;
	};

	//
	// Expose the module.
	//
	EventEmitter.EventEmitter = EventEmitter;
	EventEmitter.EventEmitter2 = EventEmitter;
	EventEmitter.EventEmitter3 = EventEmitter;

	//
	// Expose the module.
	//
	module.exports = EventEmitter;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

	var __WEBPACK_AMD_DEFINE_RESULT__;/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*! Native Promise Only
	    v0.7.6-a (c) Kyle Simpson
	    MIT License: http://getify.mit-license.org
	*/
	!function(t,n,e){n[t]=n[t]||e(),"undefined"!=typeof module&&module.exports?module.exports=n[t]:"function"=="function"&&__webpack_require__(48)&&!(__WEBPACK_AMD_DEFINE_RESULT__ = function(){return n[t]}.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))}("Promise","undefined"!=typeof global?global:this,function(){"use strict";function t(t,n){l.add(t,n),h||(h=y(l.drain))}function n(t){var n,e=typeof t;return null==t||"object"!=e&&"function"!=e||(n=t.then),"function"==typeof n?n:!1}function e(){for(var t=0;t<this.chain.length;t++)o(this,1===this.state?this.chain[t].success:this.chain[t].failure,this.chain[t]);this.chain.length=0}function o(t,e,o){var r,i;try{e===!1?o.reject(t.msg):(r=e===!0?t.msg:e.call(void 0,t.msg),r===o.promise?o.reject(TypeError("Promise-chain cycle")):(i=n(r))?i.call(r,o.resolve,o.reject):o.resolve(r))}catch(c){o.reject(c)}}function r(o){var c,u,a=this;if(!a.triggered){a.triggered=!0,a.def&&(a=a.def);try{(c=n(o))?(u=new f(a),c.call(o,function(){r.apply(u,arguments)},function(){i.apply(u,arguments)})):(a.msg=o,a.state=1,a.chain.length>0&&t(e,a))}catch(s){i.call(u||new f(a),s)}}}function i(n){var o=this;o.triggered||(o.triggered=!0,o.def&&(o=o.def),o.msg=n,o.state=2,o.chain.length>0&&t(e,o))}function c(t,n,e,o){for(var r=0;r<n.length;r++)!function(r){t.resolve(n[r]).then(function(t){e(r,t)},o)}(r)}function f(t){this.def=t,this.triggered=!1}function u(t){this.promise=t,this.state=0,this.triggered=!1,this.chain=[],this.msg=void 0}function a(n){if("function"!=typeof n)throw TypeError("Not a function");if(0!==this.__NPO__)throw TypeError("Not a promise");this.__NPO__=1;var o=new u(this);this.then=function(n,r){var i={success:"function"==typeof n?n:!0,failure:"function"==typeof r?r:!1};return i.promise=new this.constructor(function(t,n){if("function"!=typeof t||"function"!=typeof n)throw TypeError("Not a function");i.resolve=t,i.reject=n}),o.chain.push(i),0!==o.state&&t(e,o),i.promise},this["catch"]=function(t){return this.then(void 0,t)};try{n.call(void 0,function(t){r.call(o,t)},function(t){i.call(o,t)})}catch(c){i.call(o,c)}}var s,h,l,p=Object.prototype.toString,y="undefined"!=typeof setImmediate?function(t){return setImmediate(t)}:setTimeout;try{Object.defineProperty({},"x",{}),s=function(t,n,e,o){return Object.defineProperty(t,n,{value:e,writable:!0,configurable:o!==!1})}}catch(d){s=function(t,n,e){return t[n]=e,t}}l=function(){function t(t,n){this.fn=t,this.self=n,this.next=void 0}var n,e,o;return{add:function(r,i){o=new t(r,i),e?e.next=o:n=o,e=o,o=void 0},drain:function(){var t=n;for(n=e=h=void 0;t;)t.fn.call(t.self),t=t.next}}}();var g=s({},"constructor",a,!1);return s(a,"prototype",g,!1),s(g,"__NPO__",0,!1),s(a,"resolve",function(t){var n=this;return t&&"object"==typeof t&&1===t.__NPO__?t:new n(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");n(t)})}),s(a,"reject",function(t){return new this(function(n,e){if("function"!=typeof n||"function"!=typeof e)throw TypeError("Not a function");e(t)})}),s(a,"all",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):0===t.length?n.resolve([]):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");var r=t.length,i=Array(r),f=0;c(n,t,function(t,n){i[t]=n,++f===r&&e(i)},o)})}),s(a,"race",function(t){var n=this;return"[object Array]"!=p.call(t)?n.reject(TypeError("Not an array")):new n(function(e,o){if("function"!=typeof e||"function"!=typeof o)throw TypeError("Not a function");c(n,t,function(t,n){e(n)},o)})}),a});

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }()), __webpack_require__(27).setImmediate))

/***/ },
/* 48 */
/***/ function(module, exports, __webpack_require__) {

	/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {module.exports = __webpack_amd_options__;

	/* WEBPACK VAR INJECTION */}.call(exports, {}))

/***/ }
/******/ ])
});
;